//     Underscore.js 1.4.2
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
(function(){var e=this,t=e._,n={},r=Array.prototype,i=Object.prototype,s=Function.prototype,o=r.push,u=r.slice,a=r.concat,f=r.unshift,l=i.toString,c=i.hasOwnProperty,h=r.forEach,p=r.map,d=r.reduce,v=r.reduceRight,m=r.filter,g=r.every,y=r.some,b=r.indexOf,w=r.lastIndexOf,E=Array.isArray,S=Object.keys,x=s.bind,T=function(e){if(e instanceof T)return e;if(!(this instanceof T))return new T(e);this._wrapped=e};typeof exports!="undefined"?(typeof module!="undefined"&&module.exports&&(exports=module.exports=T),exports._=T):e._=T,T.VERSION="1.4.2";var N=T.each=T.forEach=function(e,t,r){if(e==null)return;if(h&&e.forEach===h)e.forEach(t,r);else if(e.length===+e.length){for(var i=0,s=e.length;i<s;i++)if(t.call(r,e[i],i,e)===n)return}else for(var o in e)if(T.has(e,o)&&t.call(r,e[o],o,e)===n)return};T.map=T.collect=function(e,t,n){var r=[];return e==null?r:p&&e.map===p?e.map(t,n):(N(e,function(e,i,s){r[r.length]=t.call(n,e,i,s)}),r)},T.reduce=T.foldl=T.inject=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(d&&e.reduce===d)return r&&(t=T.bind(t,r)),i?e.reduce(t,n):e.reduce(t);N(e,function(e,s,o){i?n=t.call(r,n,e,s,o):(n=e,i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.reduceRight=T.foldr=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(v&&e.reduceRight===v)return r&&(t=T.bind(t,r)),arguments.length>2?e.reduceRight(t,n):e.reduceRight(t);var s=e.length;if(s!==+s){var o=T.keys(e);s=o.length}N(e,function(u,a,f){a=o?o[--s]:--s,i?n=t.call(r,n,e[a],a,f):(n=e[a],i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.find=T.detect=function(e,t,n){var r;return C(e,function(e,i,s){if(t.call(n,e,i,s))return r=e,!0}),r},T.filter=T.select=function(e,t,n){var r=[];return e==null?r:m&&e.filter===m?e.filter(t,n):(N(e,function(e,i,s){t.call(n,e,i,s)&&(r[r.length]=e)}),r)},T.reject=function(e,t,n){var r=[];return e==null?r:(N(e,function(e,i,s){t.call(n,e,i,s)||(r[r.length]=e)}),r)},T.every=T.all=function(e,t,r){t||(t=T.identity);var i=!0;return e==null?i:g&&e.every===g?e.every(t,r):(N(e,function(e,s,o){if(!(i=i&&t.call(r,e,s,o)))return n}),!!i)};var C=T.some=T.any=function(e,t,r){t||(t=T.identity);var i=!1;return e==null?i:y&&e.some===y?e.some(t,r):(N(e,function(e,s,o){if(i||(i=t.call(r,e,s,o)))return n}),!!i)};T.contains=T.include=function(e,t){var n=!1;return e==null?n:b&&e.indexOf===b?e.indexOf(t)!=-1:(n=C(e,function(e){return e===t}),n)},T.invoke=function(e,t){var n=u.call(arguments,2);return T.map(e,function(e){return(T.isFunction(t)?t:e[t]).apply(e,n)})},T.pluck=function(e,t){return T.map(e,function(e){return e[t]})},T.where=function(e,t){return T.isEmpty(t)?[]:T.filter(e,function(e){for(var n in t)if(t[n]!==e[n])return!1;return!0})},T.max=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.max.apply(Math,e);if(!t&&T.isEmpty(e))return-Infinity;var r={computed:-Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o>=r.computed&&(r={value:e,computed:o})}),r.value},T.min=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.min.apply(Math,e);if(!t&&T.isEmpty(e))return Infinity;var r={computed:Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o<r.computed&&(r={value:e,computed:o})}),r.value},T.shuffle=function(e){var t,n=0,r=[];return N(e,function(e){t=T.random(n++),r[n-1]=r[t],r[t]=e}),r};var k=function(e){return T.isFunction(e)?e:function(t){return t[e]}};T.sortBy=function(e,t,n){var r=k(t);return T.pluck(T.map(e,function(e,t,i){return{value:e,index:t,criteria:r.call(n,e,t,i)}}).sort(function(e,t){var n=e.criteria,r=t.criteria;if(n!==r){if(n>r||n===void 0)return 1;if(n<r||r===void 0)return-1}return e.index<t.index?-1:1}),"value")};var L=function(e,t,n,r){var i={},s=k(t);return N(e,function(t,o){var u=s.call(n,t,o,e);r(i,u,t)}),i};T.groupBy=function(e,t,n){return L(e,t,n,function(e,t,n){(T.has(e,t)?e[t]:e[t]=[]).push(n)})},T.countBy=function(e,t,n){return L(e,t,n,function(e,t,n){T.has(e,t)||(e[t]=0),e[t]++})},T.sortedIndex=function(e,t,n,r){n=n==null?T.identity:k(n);var i=n.call(r,t),s=0,o=e.length;while(s<o){var u=s+o>>>1;n.call(r,e[u])<i?s=u+1:o=u}return s},T.toArray=function(e){return e?e.length===+e.length?u.call(e):T.values(e):[]},T.size=function(e){return e.length===+e.length?e.length:T.keys(e).length},T.first=T.head=T.take=function(e,t,n){return t!=null&&!n?u.call(e,0,t):e[0]},T.initial=function(e,t,n){return u.call(e,0,e.length-(t==null||n?1:t))},T.last=function(e,t,n){return t!=null&&!n?u.call(e,Math.max(e.length-t,0)):e[e.length-1]},T.rest=T.tail=T.drop=function(e,t,n){return u.call(e,t==null||n?1:t)},T.compact=function(e){return T.filter(e,function(e){return!!e})};var A=function(e,t,n){return N(e,function(e){T.isArray(e)?t?o.apply(n,e):A(e,t,n):n.push(e)}),n};T.flatten=function(e,t){return A(e,t,[])},T.without=function(e){return T.difference(e,u.call(arguments,1))},T.uniq=T.unique=function(e,t,n,r){var i=n?T.map(e,n,r):e,s=[],o=[];return N(i,function(n,r){if(t?!r||o[o.length-1]!==n:!T.contains(o,n))o.push(n),s.push(e[r])}),s},T.union=function(){return T.uniq(a.apply(r,arguments))},T.intersection=function(e){var t=u.call(arguments,1);return T.filter(T.uniq(e),function(e){return T.every(t,function(t){return T.indexOf(t,e)>=0})})},T.difference=function(e){var t=a.apply(r,u.call(arguments,1));return T.filter(e,function(e){return!T.contains(t,e)})},T.zip=function(){var e=u.call(arguments),t=T.max(T.pluck(e,"length")),n=new Array(t);for(var r=0;r<t;r++)n[r]=T.pluck(e,""+r);return n},T.object=function(e,t){var n={};for(var r=0,i=e.length;r<i;r++)t?n[e[r]]=t[r]:n[e[r][0]]=e[r][1];return n},T.indexOf=function(e,t,n){if(e==null)return-1;var r=0,i=e.length;if(n){if(typeof n!="number")return r=T.sortedIndex(e,t),e[r]===t?r:-1;r=n<0?Math.max(0,i+n):n}if(b&&e.indexOf===b)return e.indexOf(t,n);for(;r<i;r++)if(e[r]===t)return r;return-1},T.lastIndexOf=function(e,t,n){if(e==null)return-1;var r=n!=null;if(w&&e.lastIndexOf===w)return r?e.lastIndexOf(t,n):e.lastIndexOf(t);var i=r?n:e.length;while(i--)if(e[i]===t)return i;return-1},T.range=function(e,t,n){arguments.length<=1&&(t=e||0,e=0),n=arguments[2]||1;var r=Math.max(Math.ceil((t-e)/n),0),i=0,s=new Array(r);while(i<r)s[i++]=e,e+=n;return s};var O=function(){};T.bind=function(t,n){var r,i;if(t.bind===x&&x)return x.apply(t,u.call(arguments,1));if(!T.isFunction(t))throw new TypeError;return i=u.call(arguments,2),r=function(){if(this instanceof r){O.prototype=t.prototype;var e=new O,s=t.apply(e,i.concat(u.call(arguments)));return Object(s)===s?s:e}return t.apply(n,i.concat(u.call(arguments)))}},T.bindAll=function(e){var t=u.call(arguments,1);return t.length==0&&(t=T.functions(e)),N(t,function(t){e[t]=T.bind(e[t],e)}),e},T.memoize=function(e,t){var n={};return t||(t=T.identity),function(){var r=t.apply(this,arguments);return T.has(n,r)?n[r]:n[r]=e.apply(this,arguments)}},T.delay=function(e,t){var n=u.call(arguments,2);return setTimeout(function(){return e.apply(null,n)},t)},T.defer=function(e){return T.delay.apply(T,[e,1].concat(u.call(arguments,1)))},T.throttle=function(e,t){var n,r,i,s,o,u,a=T.debounce(function(){o=s=!1},t);return function(){n=this,r=arguments;var f=function(){i=null,o&&(u=e.apply(n,r)),a()};return i||(i=setTimeout(f,t)),s?o=!0:(s=!0,u=e.apply(n,r)),a(),u}},T.debounce=function(e,t,n){var r,i;return function(){var s=this,o=arguments,u=function(){r=null,n||(i=e.apply(s,o))},a=n&&!r;return clearTimeout(r),r=setTimeout(u,t),a&&(i=e.apply(s,o)),i}},T.once=function(e){var t=!1,n;return function(){return t?n:(t=!0,n=e.apply(this,arguments),e=null,n)}},T.wrap=function(e,t){return function(){var n=[e];return o.apply(n,arguments),t.apply(this,n)}},T.compose=function(){var e=arguments;return function(){var t=arguments;for(var n=e.length-1;n>=0;n--)t=[e[n].apply(this,t)];return t[0]}},T.after=function(e,t){return e<=0?t():function(){if(--e<1)return t.apply(this,arguments)}},T.keys=S||function(e){if(e!==Object(e))throw new TypeError("Invalid object");var t=[];for(var n in e)T.has(e,n)&&(t[t.length]=n);return t},T.values=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push(e[n]);return t},T.pairs=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push([n,e[n]]);return t},T.invert=function(e){var t={};for(var n in e)T.has(e,n)&&(t[e[n]]=n);return t},T.functions=T.methods=function(e){var t=[];for(var n in e)T.isFunction(e[n])&&t.push(n);return t.sort()},T.extend=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]=t[n]}),e},T.pick=function(e){var t={},n=a.apply(r,u.call(arguments,1));return N(n,function(n){n in e&&(t[n]=e[n])}),t},T.omit=function(e){var t={},n=a.apply(r,u.call(arguments,1));for(var i in e)T.contains(n,i)||(t[i]=e[i]);return t},T.defaults=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]==null&&(e[n]=t[n])}),e},T.clone=function(e){return T.isObject(e)?T.isArray(e)?e.slice():T.extend({},e):e},T.tap=function(e,t){return t(e),e};var M=function(e,t,n,r){if(e===t)return e!==0||1/e==1/t;if(e==null||t==null)return e===t;e instanceof T&&(e=e._wrapped),t instanceof T&&(t=t._wrapped);var i=l.call(e);if(i!=l.call(t))return!1;switch(i){case"[object String]":return e==String(t);case"[object Number]":return e!=+e?t!=+t:e==0?1/e==1/t:e==+t;case"[object Date]":case"[object Boolean]":return+e==+t;case"[object RegExp]":return e.source==t.source&&e.global==t.global&&e.multiline==t.multiline&&e.ignoreCase==t.ignoreCase}if(typeof e!="object"||typeof t!="object")return!1;var s=n.length;while(s--)if(n[s]==e)return r[s]==t;n.push(e),r.push(t);var o=0,u=!0;if(i=="[object Array]"){o=e.length,u=o==t.length;if(u)while(o--)if(!(u=M(e[o],t[o],n,r)))break}else{var a=e.constructor,f=t.constructor;if(a!==f&&!(T.isFunction(a)&&a instanceof a&&T.isFunction(f)&&f instanceof f))return!1;for(var c in e)if(T.has(e,c)){o++;if(!(u=T.has(t,c)&&M(e[c],t[c],n,r)))break}if(u){for(c in t)if(T.has(t,c)&&!(o--))break;u=!o}}return n.pop(),r.pop(),u};T.isEqual=function(e,t){return M(e,t,[],[])},T.isEmpty=function(e){if(e==null)return!0;if(T.isArray(e)||T.isString(e))return e.length===0;for(var t in e)if(T.has(e,t))return!1;return!0},T.isElement=function(e){return!!e&&e.nodeType===1},T.isArray=E||function(e){return l.call(e)=="[object Array]"},T.isObject=function(e){return e===Object(e)},N(["Arguments","Function","String","Number","Date","RegExp"],function(e){T["is"+e]=function(t){return l.call(t)=="[object "+e+"]"}}),T.isArguments(arguments)||(T.isArguments=function(e){return!!e&&!!T.has(e,"callee")}),typeof /./!="function"&&(T.isFunction=function(e){return typeof e=="function"}),T.isFinite=function(e){return T.isNumber(e)&&isFinite(e)},T.isNaN=function(e){return T.isNumber(e)&&e!=+e},T.isBoolean=function(e){return e===!0||e===!1||l.call(e)=="[object Boolean]"},T.isNull=function(e){return e===null},T.isUndefined=function(e){return e===void 0},T.has=function(e,t){return c.call(e,t)},T.noConflict=function(){return e._=t,this},T.identity=function(e){return e},T.times=function(e,t,n){for(var r=0;r<e;r++)t.call(n,r)},T.random=function(e,t){return t==null&&(t=e,e=0),e+(0|Math.random()*(t-e+1))};var _={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};_.unescape=T.invert(_.escape);var D={escape:new RegExp("["+T.keys(_.escape).join("")+"]","g"),unescape:new RegExp("("+T.keys(_.unescape).join("|")+")","g")};T.each(["escape","unescape"],function(e){T[e]=function(t){return t==null?"":(""+t).replace(D[e],function(t){return _[e][t]})}}),T.result=function(e,t){if(e==null)return null;var n=e[t];return T.isFunction(n)?n.call(e):n},T.mixin=function(e){N(T.functions(e),function(t){var n=T[t]=e[t];T.prototype[t]=function(){var e=[this._wrapped];return o.apply(e,arguments),F.call(this,n.apply(T,e))}})};var P=0;T.uniqueId=function(e){var t=P++;return e?e+t:t},T.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var H=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},j=/\\|'|\r|\n|\t|\u2028|\u2029/g;T.template=function(e,t,n){n=T.defaults({},n,T.templateSettings);var r=new RegExp([(n.escape||H).source,(n.interpolate||H).source,(n.evaluate||H).source].join("|")+"|$","g"),i=0,s="__p+='";e.replace(r,function(t,n,r,o,u){s+=e.slice(i,u).replace(j,function(e){return"\\"+B[e]}),s+=n?"'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'":r?"'+\n((__t=("+r+"))==null?'':__t)+\n'":o?"';\n"+o+"\n__p+='":"",i=u+t.length}),s+="';\n",n.variable||(s="with(obj||{}){\n"+s+"}\n"),s="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+s+"return __p;\n";try{var o=new Function(n.variable||"obj","_",s)}catch(u){throw u.source=s,u}if(t)return o(t,T);var a=function(e){return o.call(this,e,T)};return a.source="function("+(n.variable||"obj")+"){\n"+s+"}",a},T.chain=function(e){return T(e).chain()};var F=function(e){return this._chain?T(e).chain():e};T.mixin(T),N(["pop","push","reverse","shift","sort","splice","unshift"],function(e){var t=r[e];T.prototype[e]=function(){var n=this._wrapped;return t.apply(n,arguments),(e=="shift"||e=="splice")&&n.length===0&&delete n[0],F.call(this,n)}}),N(["concat","join","slice"],function(e){var t=r[e];T.prototype[e]=function(){return F.call(this,t.apply(this._wrapped,arguments))}}),T.extend(T.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
/**
 * @class RCBase64
 * This class Encode and Decode Base64
 * @singleton
 */
var RCBase64 = {
    /**
     * @private
     * @type {String} Valid Characters for Base64
     */
    keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
        "abcdefghijklmnopqrstuvwxyz0123456789+/=",

    //
    /**
     * Public method for encoding
     * @param input
     * @return {String}
     */
    encode : function (input) {
        var output = "",
            chr1,
            chr2,
            chr3,
            enc1,
            enc2,
            enc3,
            enc4,
            i = 0;

        input = this.utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
                this.keyStr.charAt(enc1) + this.keyStr.charAt(enc2) +
                this.keyStr.charAt(enc3) + this.keyStr.charAt(enc4);

        }

        return output;
    },

    /**
     * Public method for decoding
     * @param input
     * @return {String}
     */
    decode : function (input) {
        var output = "",
            chr1,
            chr2,
            chr3,
            enc1,
            enc2,
            enc3,
            enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this.keyStr.indexOf(input.charAt(i++));
            enc2 = this.keyStr.indexOf(input.charAt(i++));
            enc3 = this.keyStr.indexOf(input.charAt(i++));
            enc4 = this.keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
            }

        }

        output = this.utf8_decode(output);

        return output;

    },

    /**
     * private method for UTF-8 encoding
     * @param string
     * @return {String}
     * @private
     */
    utf8_encode : function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "", n, c;

        for (n = 0; n < string.length; n++) {

            c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    /**
     * private method for UTF-8 decoding
     * @param utftext
     * @return {String}
     * @private
     */
    utf8_decode : function (utftext) {
        var string = "",
            i = 0,
            c = 0,
            c2 = 0,
            c3 = 0;

        while (i < utftext.length) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) |
                    ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }

        }

        return string;
    }
};
/**
 * @class RestClient
 * Little REST Client written in JS
 *
 * Usage:
 *
 *      var rc,
 *          success;
 *
 *      //Instantiate an new RestClient Object
 *      rc= new RestClient();
 *      //Set the authorization mode to OAuth 2.0
 *      rc.setAuthorizationType('oauth2');
 *      //Set the client Credentials
 *      rc.setClient('client_id', 'client_secret');
 *      //Set the rest authorization endpoint
 *      rc.setAuthorizationServer('http://rest.example.com/authorize');
 *      //Set the OAuth 2.0 Grant Type
 *      rc.setGrantType('client');
 *
 *      //Make the call
 *      success = rc.authorize({
 *          success: function (xhr, response) {
 *              //Process Access Token
 *          },
 *          failure: function(xhr, response){
 *              //Process Failure
 *          }
 *      });
 *
 *  Other Example:
 *
 *      var rc,
 *          success;
 *
 *      //Instantiate an new RestClient Object
 *      rc= new RestClient();
 *      //Set the authorization mode to none
 *      rc.setAuthorizationType('none');
 *
 *      //Make the REST call
 *      success = rc.consume({
 *          url: 'http://rest.example.com/resource',
 *          operation: 'read',
 *          success: function (xhr, response) {
 *              //Process REST Response
 *          },
 *          failure: function(xhr, response){
 *              //Process Failure
 *          }
 *      });
 *
 *
 * @constructor
 * Create the RestClient namespace and object
 *
 *      var rc = new RestClient();
 *
 * @return {RestClient}
 */
var RestClient;
RestClient = function () {
    /**
     * Library's Version
     * @type {String}
     */
    this.VERSION = '0.1.5';
    /**
     * Stores the authorization variables
     * @cfg {Object}
     */
    this.authorization = {};
    /**
     * Stores the server variables
     * @cfg {Object}
     */
    this.server = {};
    /**
     * Stores the response variables
     * @cfg {Object}
     */
    this.response = {};
    /**
     * Stores the header variables
     * @cfg {Object}
     */
    this.headers = {};
    /**
     * Stores the Oauth2.0 access token
     * @cfg {Object}
     */
    this.accessToken = {};
    /**
     * Set if the RestClient send automatically the refresh token during a request
     * @type {Boolean}
     */
    this.autoUseRefreshToken = true;

    /**
     * Set if the RestClient stores automatically a valid access token received
     * @type {Boolean}
     */
    this.autoStoreAccessToken = true;
    /**
     * Stores the authorization type. Values Accepted: none, basic, oauth2
     * @type {String}
     */
    this.authorizationType = 'none';

    /**
     * Stores the request content-type
     * @type {String}
     */
    this.contentType = 'application/json';

    /**
     * Stores if the RestClient will send and Bearer Authorization Header
     * @type {Boolean}
     */
    this.sendOAuthBearerAuthorization = false;

    /**
     * Stores the information about the way to process the response
     *
     * Valid values are: 'json', 'plain','form', 'html'
     * @type {String}
     */

    this.dataType = 'json';

    /**
     * Stores if OAuth 2.0 Authorization need set Authorization Header
     * @type {Boolean}
     */
    this.oauth2NeedsAuthorization = true;

    /**
     * Stores the message to compare when an access token is expired
     * @type {String}
     */
    this.expiredAccessTokenMessage = '';

    /**
     * Sets if the restclient will apply REST or AJAX to connect the server
     * @type {Boolean}
     */
    this.restfulBehavior = true;

    /**
     * Sets the backup URL when the restful is not available
     * @type {String}
     */
    this.backupAJAXURL = null;

    /**
     * Stores the REST method/verbs accepted
     * @type {Object}
     * @private
     */
    this.RESTMethods = {
        'create' : 'POST',
        'read' : 'GET',
        'update' : 'PUT',
        'delete' : 'DELETE'
    };
    /**
     * Setting the OAUTH2 Grant Types
     * @type {Object}
     * @private
     */
    this.OAUTH2GrantTypes = {
        'code' : 'authorization_code',
        'implicit' : 'token',
        'user' : 'password',
        'client' : 'client_credentials',
        'refresh' : 'refresh_token'
    };

    RestClient.prototype.initObject.call(this);
};

/**
 * Http Success Constant
 * @type {Number}
 */
RestClient.prototype.HTTP_SUCCESS = 200;
/**
 * Http Bad Request Constant
 * @type {Number}
 */
RestClient.prototype.HTTP_BAD_REQUEST = 400;
/**
 * Http Unauthorized Constant
 * @type {Number}
 */
RestClient.prototype.HTTP_UNAUTHORIZED = 401;

/**
 * OAuth 2.0 Invalid Grant Error Message
 * @type {String}
 */
RestClient.prototype.OAUTH2_INVALID_GRANT = "invalid_grant";


/**
 * Resets the RestClient
 */
RestClient.prototype.initObject = function () {
    this.authorization = {};
    this.server = {};
    this.response = {};
    this.headers = {};
    this.accessToken = {};
    this.autoUseRefreshToken = true;
    this.autoStoreAccessToken = true;
    this.authorizationType = 'none';
    this.contentType = 'application/json';
    this.sendOAuthBearerAuthorization = false;
    this.oauth2NeedsAuthorization = true;
    this.dataType = 'json';
    this.expiredAccessTokenMessage = 'The access token provided has expired.';
};

/**
 * Set the value for use refresh token automatically
 * @param value
 * @return {*}
 */
RestClient.prototype.setUseRefreshTokenAutomatically = function (value) {
    if (_.isBoolean(value)) {
        this.autoUseRefreshToken = value;
    }
    return this;
};

/**
 * Set if the access token should be stored automatically
 * @param value
 * @return {*}
 */
RestClient.prototype.setStoreAccessTokenAutomatically = function (value) {
    if (_.isBoolean(value)) {
        this.autoStoreAccessToken = value;
    }
    return this;
};

/**
 * Sets the authorization type
 * @param {String} type Valid Authorization Type
 * @return {*}
 */
RestClient.prototype.setAuthorizationType = function (type) {
    var acceptedTypes = {none: 1, basic: 1, oauth2: 1};
    if (acceptedTypes[type]) {
        this.authorizationType = type;
    }
    return this;
};

/**
 * Set the request content-type
 * @param value
 * @return {*}
 */
RestClient.prototype.setContentType = function (value) {
    this.contentType = value;
    return this;
};

/**
 * Sets if into OAuth 2.0 mode should be sent the bearer authorization header
 * @param value
 * @return {*}
 */
RestClient.prototype.setSendBearerAuthorization = function (value) {
    if (_.isBoolean(value)) {
        this.sendOAuthBearerAuthorization = value;
    }
    return this;
};

/**
 * Set if OAuth 2.0 Authorization Request sends Authorization Header
 * @param value
 * @return {*}
 */
RestClient.prototype.setOAuth2NeedsAuthorization = function (value) {
    if (_.isBoolean(value)) {
        this.oauth2NeedsAuthorization = value;
    }
    return this;
};
/**
 * Set the DataType used to request data
 * @param type
 * @return {*}
 */
RestClient.prototype.setDataType = function (type) {
    var acceptedDataTypes = {
        json: 'application/json',
        plain: 'text/plain',
        form: 'application/x-www-form-urlencoded',
        html: 'text/html'
    };
    if (acceptedDataTypes[type]) {
        this.dataType = type;
        this.contentType = acceptedDataTypes[type];
    }
    return this;
};

/**
 * Set the message to compare when and access token is expired
 * @param {String} msg
 * @return {*}
 */
RestClient.prototype.setAccessTokenExpiredMessage = function (msg) {
    this.expiredAccessTokenMessage = msg;
    return this;
};

/**
 * Returns the library version
 * @return {String} RestClient Version
 */
RestClient.prototype.getVersion = function () {
    return this.VERSION;
};

/**
 * Setting the client authorization credentials
 * @param {String} client_id Client Identifier
 * @param {String} client_secret Client Secret or Password
 * @param {String} client_url Authorization URL
 * @return {RestClient}
 */
RestClient.prototype.setClient = function (client_id, client_secret,
                                           client_url) {
    this.authorization.client_id = client_id;
    this.authorization.client_secret = client_secret;
    this.authorization.client_url = (client_url !== 'undefined') ? client_url
        : null;
    return this;
};

/**
 * Setting the OAuth2 Grant Type and Data
 * @param {String} type Grant Type
 * @param {Object} data
 * @return {RestClient}
 */
RestClient.prototype.setGrantType = function (type, data) {
    this.authorization.grant_type = (this.OAUTH2GrantTypes[type] !==
        'undefined') ? this.OAUTH2GrantTypes[type]
        : null;
    this.authorization = _.extend(this.authorization, data);
    return this;
};

/**
 * Setting the Server URL to consume REST
 * @param {String} url Authorization URL
 * @return {Boolean}
 */
RestClient.prototype.setAuthorizationServer = function (url) {
    var result = true,
        reg_url;
    if (typeof url === 'undefined' || url === null) {
        result = false;
    } else {
        reg_url = /(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        if (url.match(reg_url)) {
            this.server.rest_auth_uri = url;
        } else {
            result = false;
        }
    }
    return result;
};

/**
 * Add HTML header information to send though XHR
 * @param {String} name Name Field
 * @param {String} value Value Field
 * @return {Boolean}
 */
RestClient.prototype.setHeader = function (name, value) {
    var response = true,
        addObj;
    if (name && value) {
        addObj = JSON.parse('{"' + name + '" :  "' + value + '"}');
        this.headers = _.extend(this.headers, addObj);
    } else {
        response = false;
    }
    return response;
};

/**
 * Set the user and password for the basic authentication method
 * @param {String} username
 * @param {String} password
 * @return {RestClient}
 */
RestClient.prototype.setBasicCredentials = function (username, password) {
    this.authorization.basic_user = username;
    this.authorization.basic_password = password;
    return this;
};
/**
 * Set manually with an access token
 * @param {Object} obj
 * @return {*}
 */
RestClient.prototype.setAccessToken = function (obj) {
    if (typeof obj === 'object') {
        this.accessToken = obj;
    }
    return this;
};

/**
 * Sets the restful behavior for this object
 * @param {Boolean} value
 * @return {*}
 */
RestClient.prototype.setRestfulBehavior = function (value) {
    if (_.isBoolean(value)) {
        this.restfulBehavior = value;
    }
    return this;
};

/**
 * Sets the backup Ajax URL
 * @param {String} url
 * @return {*}
 */
RestClient.prototype.setBackupAjaxUrl = function (url) {
    this.backupAJAXURL = url;
    return this;
};

/**
 * Convert an Object to Key/Value string
 * @param {Object} obj Input Object
 * @return {String}
 * @private
 */
RestClient.prototype.toParams = function (obj) {
    var keys = _.keys(obj),
        out = [];
    _.each(keys, function (key) {
        out.push(key + '=' + obj[key]);
    });
    return out.join('&');
};

/**
 * Prepares the data to send through XHR depending of the content-type defined
 * @param {*} data
 * @return {String}
 */
RestClient.prototype.prepareBody = function (data) {
    var out = '';
    if (this.dataType === 'json' || this.dataType === 'jsonp') {
        if (typeof data === 'object') {
            out = JSON.stringify(data);
        }
    } else {
        out = this.toParams(data);
    }
    return out;
};

/**
 * Create an object XmlHttpRequest or returns false if fails
 * @return {*}
 */
RestClient.prototype.createXHR = function () {
    var httpRequest;
    if (window.XMLHttpRequest) {
        httpRequest = new XMLHttpRequest();
    } else {
        try {
            httpRequest = new ActiveXObject("MSXML2.XMLHTTP");
        } catch (e) {
            try {
                httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
            } catch (ex) {
            }
        }
    }
    if (!httpRequest) {
        return false;
    }
    return httpRequest;
};

/**
 * Request an OAuth 2.0 Access Token
 * @param {Object} [options] Authorization Options
 *
 * Options Example:
 *
 *     {
 *         //fires when the authorize method is success
 *         success: function (xhr, response) {
 *             //Process Success
 *         },
 *         //fires when the authorize method is failure
 *         failure: function (xhr, response) {
 *             //Process Failure
 *         },
 *         //fires when the XmlHttpRequest is ready
 *         ready: function (xhr) {
 *             //Show States
 *         },
 *         //fires when the restclient obtain a new access token successfully
 *         autorefresh: function (accessToken) {
 *            //Update Token
 *         },
 *         //fires if the restclient cannot create a XmlHttpRequest Object
 *         xhrfailure: function (error, data) {
 *            //Notify Client Browser Not Supported
 *         }
 *     }
 *
 * @return {Boolean}
 */
RestClient.prototype.authorize = function (options) {
    var self = this,
        success = false,
        operation = 'create',
        method = this.RESTMethods[operation],
        basicHash,
        xhr,
        body,
        response;

    basicHash = RCBase64.encode(this.authorization.client_id + ':' +
        this.authorization.client_secret);

    xhr = this.createXHR();
    try {
        xhr.open(method, this.server.rest_auth_uri, false);
    } catch (e) {
        if (options.xhrfailure) {
            options.xhrfailure(e, {});
        } else {
            this.XHRFailure(e, {});
        }
        return success;
    }

    xhr.onreadystatechange = function () {
        if (options.ready) {
            options.ready(xhr);
        } else {
            self.AuthorizeReady(xhr);
        }
        if (xhr.readyState === 4) {
            if (xhr.status === self.HTTP_SUCCESS) {
                try {
                    response = JSON.parse(xhr.responseText);
                    if (self.autoStoreAccessToken) {
                        self.accessToken = response.token || {};
                    }
                    success = true;
                    if (options.success) {
                        options.success(xhr, response);
                    } else {
                        self.AuthorizeSuccess(xhr, response);
                    }
                } catch (e) {
                    response = {
                        'success': false,
                        'error' : {
                            'error' : self.HTTP_BAD_REQUEST,
                            'error_description' : 'Response is not a valid JSON'
                        }
                    };
                    if (options.failure) {
                        options.failure(xhr, response);
                    } else {
                        self.AuthorizeFailure(xhr, response);
                    }
                }
            } else {
                response = {};
                try {
                    response = JSON.parse(xhr.responseText);
                } catch (ex) {}
                if (options.failure) {
                    options.failure(xhr, response);
                } else {
                    self.AuthorizeFailure(xhr, response);
                }
            }
        }
    };

    body = {};

    if (this.authorization.grant_type) {
        body.grant_type = this.authorization.grant_type;
        switch (this.authorization.grant_type) {
        case 'authorization_code':
            body.code = this.authorization.code;
            break;
        case 'token':
            body.token = this.authorization.token;
            break;
        case 'password':
            body.username = this.authorization.username;
            body.password = this.authorization.password;
            break;
        case 'client_credentials':
            body.client_id = this.authorization.client_id;
            body.client_id = this.authorization.client_secret;
            break;
        case 'refresh_token':
            body.refresh_token = this.authorization.refresh_token;
            break;
        }
    }

    //SEND HEADERS
    if (this.oauth2NeedsAuthorization) {
        xhr.setRequestHeader("Authorization", "Basic " + basicHash);
    }
    xhr.setRequestHeader("Content-Type", this.contentType);

    //Insert Headers
    _.each(this.headers, function (value, key) {
        xhr.setRequestHeader(key, value);
    });

    xhr.send(this.prepareBody(body));

    return success;
};

/**
 * Prepare the error object when exists required fields not found
 * @param {Array} fields Required Fields Array
 * @return {Object} Error Object
 * @private
 */
RestClient.prototype.prepareReqFields = function (fields) {
    var response;
    response = {
        success: false,
        error: {
            error: this.HTTP_BAD_REQUEST,
            error_description : 'Required fields not found'
        },
        fields: fields
    };
    return response;
};

/**
 * Prepares the consume URL using configurations
 * @param {String} operation
 * @param {String} url
 * @param {String} id
 * @param {Object} data
 * @return {Object}
 */
RestClient.prototype.prepareConsumeUrl = function (operation, url, id, data) {
    var auxUrl,
        auxBody,
        auxContentType = this.contentType,
        usedQuestionMark = false;
    if (this.restfulBehavior) {
        switch (operation) {
        case 'read':
            auxUrl = url;
            if (id) {
                auxUrl += id;
            }
            if (this.authorizationType === 'oauth2' && !this.sendOAuthBearerAuthorization) {
                usedQuestionMark = true;
                auxUrl += '?access_token=' + this.accessToken.access_token;
            }
            if (data && data !== {}) {
                if (usedQuestionMark) {
                    auxUrl += "&";
                } else {
                    auxUrl += "?";
                }
                auxUrl += this.toParams(data);
            }
            auxBody = null;
            auxContentType = 'application/x-www-form-urlencoded';
            break;
        case 'create':
            auxUrl = url;
            auxBody = data || {};
            if (this.authorizationType === 'oauth2' && !this.sendOAuthBearerAuthorization) {
                auxBody.access_token = this.accessToken.access_token;
            }
            auxBody = this.prepareBody(auxBody);
            break;
        case 'update':
            auxUrl = url;
            if (id) {
                auxUrl += id;
            }
            auxBody = data || {};
            if (this.authorizationType === 'oauth2' && !this.sendOAuthBearerAuthorization) {
                auxBody.access_token = this.accessToken.access_token;
            }
            auxBody = this.prepareBody(auxBody);
            break;
        case 'delete':
            auxUrl = url;
            if (id) {
                auxUrl += id;
            }
            auxBody = data || {};
            if (this.authorizationType === 'oauth2' && !this.sendOAuthBearerAuthorization) {
                auxBody.access_token = this.accessToken.access_token;
            }
            auxBody = this.prepareBody(auxBody);
            break;
        }
    } else {
        auxUrl = this.backupAJAXURL;
        auxBody = {
            operation: operation,
            url: url,
            id: id,
            data: data
        };
        auxBody = "data='" + encodeURIComponent(JSON.stringify(auxBody)) + "'";
        auxContentType = 'application/x-www-form-urlencoded';
    }
    return {
        url: auxUrl,
        body: auxBody,
        content_type: auxContentType
    };

};

/**
 * Consume REST through GET Method
 * @param {Object} config Configuration Object
 *
 * To view an example of this config object go to {@link #consume} method
 * @return {Boolean} REST Response Status
 */
RestClient.prototype.getCall = function (config) {
    config.operation = 'read';
    return this.consume(config);
};

/**
 * Consume REST through POST Method
 * @param {Object} config Configuration Object
 *
 * To view an example of this config object go to {@link #consume} method
 * @return {Boolean} REST Response Status
 */
RestClient.prototype.postCall = function (config) {
    config.operation = 'create';
    return this.consume(config);
};

/**
 * Consume REST through PUT Method
 * @param {Object} config Configuration Object
 *
 * To view an example of this config object go to {@link #consume} method
 * @return {Boolean} REST Response Status
 */
RestClient.prototype.putCall = function (config) {
    config.operation = 'update';
    return this.consume(config);
};

/**
 * Consume REST through DELETE Method
 * @param {Object} config Configuration Object
 *
 * To view an example of this config object go to {@link #consume} method
 * @return {Boolean} REST Response Status
 */
RestClient.prototype.deleteCall = function (config) {
    config.operation = 'delete';
    return this.consume(config);
};

/**
 * Consume  REST method
 * @param {Object} options Consume Options
 *
 * Options Example:
 *
 *     {
 *         //ID related to the operation (optional)
 *         id : 12,
 *         //URL to consume the rest
 *         url: 'http://rest.colosa.com/resource',
 *         //operation to consume: 'create', 'read', 'update', 'delete'
 *         operation: 'create',
 *         //{Object} to be sent
 *         data: {},
 *         //fires when the authorize method is success
 *         success: function (xhr, response) {
 *             //Process Success
 *         },
 *         //fires when the authorize method is failure
 *         failure: function (xhr, response) {
 *             //Process Failure
 *         },
 *         //fires when the XmlHttpRequest is ready
 *         ready: function (xhr) {
 *             //Show States
 *         },
 *         //fires if the restclient cannot create a XmlHttpRequest Object
 *         xhrfailure: function (error, data) {
 *            //Notify Client Browser Not Supported
 *         }
 *     }
 * @return {Boolean}
 */
RestClient.prototype.consume = function (options) {
    var basicHash,
        xhr,
        operation,
        method,
        response = {},
        body,
        prepareUrl,
        self,
        error,
        success = true,
        url,
        requiredFields = [],
        data,
        id,
        prepare,
        bearerText,
        contentType,
        accessTokenExpired = false;

    if (options.operation) {
        operation = options.operation;
    } else {
        success = false;
        requiredFields.push('operation');
    }

    if (options.url) {
        url = options.url;
    } else {
        success = false;
        requiredFields.push('url');
    }

    data = options.data || null;
    id = options.id || null;

    if (!success) {
        if (options.failure) {
            options.failure(null, this.prepareReqFields(requiredFields));
        } else {
            this.ConsumeFailure(null, this.prepareReqFields(requiredFields));
        }
        return success;
    }

    prepare = this.prepareConsumeUrl(operation, url, id, data);
    prepareUrl = prepare.url;
    body = prepare.body;
    contentType = prepare.content_type;

    xhr = this.createXHR();
    switch (this.authorizationType) {
    case 'none':
        break;
    case 'basic':
        basicHash = RCBase64.encode(this.authorization.basic_user + ':' +
            this.authorization.basic_user);
        xhr.setRequestHeader("Authorization", "Basic " + basicHash);
        break;
    case 'oauth2':
        if (!this.accessToken.access_token) {
            success = false;
            requiredFields.push('access_token');
            error = {
                success: false,
                error : {
                    error : this.HTTP_BAD_REQUEST,
                    error_description: 'Access Token not defined'
                }
            };
            if (options.failure) {
                options.failure(null, this.prepareReqFields(requiredFields));
            } else {
                this.ConsumeFailure(null, this.prepareReqFields(requiredFields));
            }
            return success;
        } else {
            if (this.sendOAuthBearerAuthorization) {
                bearerText = "Bearer: " + this.accessToken.access_token;
                xhr.setRequestHeader("Authorization", bearerText);
            }
        }
        break;
    }
    if (this.restfulBehavior) {
        method = this.RESTMethods[operation];
    } else {
        method = this.RESTMethods.create;
    }
    try {
        xhr.open(method, prepareUrl, false);
    } catch (exc) {
        if (options.xhrfailure) {
            options.xhrfailure(exc, data);
        } else {
            this.XHRFailure(exc, data);
        }
        return false;
    }

    self = this;
    xhr.onreadystatechange = function () {
        if (options.ready) {
            options.ready(xhr);
        } else {
            self.ConsumeReady(xhr);
        }
        if (xhr.readyState === 4) {
            if (xhr.status === self.HTTP_SUCCESS) {
                try {
                    response = JSON.parse(xhr.responseText);
                } catch (ex) {
                    response = {
                        'success': false,
                        'error' : {
                            'error' : self.HTTP_BAD_REQUEST,
                            'error_description' : 'Response is not a valid JSON'
                        }
                    };
                    if (options.failure) {
                        options.failure(xhr, response);
                    } else {
                        self.ConsumeFailure(xhr, response);
                    }
                }
                if (options.success) {
                    options.success(xhr, response);
                } else {
                    self.ConsumeSuccess(xhr, response);
                }
            } else {
                try {
                    response = JSON.parse(xhr.responseText);

                    if (response.error === self.OAUTH2_INVALID_GRANT &&
                        response.error_description === self.expiredAccessTokenMessage){
                        accessTokenExpired = true;
                    }
                    if (xhr.status === self.HTTP_UNAUTHORIZED && self.autoUseRefreshToken && accessTokenExpired) {

                        if (self.accessToken.refresh_token) {
                            self.setGrantType('refresh', {refresh_token: self.accessToken.refresh_token});
                            self.authorize({
                                success: function (x, data) {
                                    success = self.consume(options);
                                    if (success) {
                                        if (options.autorefresh) {
                                            options.autorefresh(self.accessToken);
                                        } else {
                                            self.AuthorizeAutoRefresh(self.accessToken);
                                        }
                                    }
                                },
                                failure: function (x, data) {
                                    success = false;
                                    if (options.failure) {
                                        options.failure(null, data);
                                    } else {
                                        self.ConsumeFailure(null, data);
                                    }
                                }
                            });
                        } else {
                            success = false;
                            response = {
                                success: false,
                                error: {
                                    error: self.HTTP_UNAUTHORIZED,
                                    error_description: 'Refresh token is not defined'
                                }
                            };
                            if (options.failure) {
                                options.failure(xhr, response);
                            } else {
                                self.ConsumeFailure(xhr, response);
                            }
                        }

                    } else {
                        success = false;
                        response = {};
                        try {
                            response = JSON.parse(xhr.responseText);
                        } catch (e) {}
                        if (options.failure) {
                            options.failure(xhr, response);
                        } else {
                            self.ConsumeFailure(xhr, response);
                        }
                    }
                } catch (e) {
                    success = false;
                    response = {};
                    try {
                        response = JSON.parse(xhr.responseText);
                    } catch (ex) {}
                    if (options.failure) {
                        options.failure(xhr, response);
                    } else {
                        self.ConsumeFailure(xhr, response);
                    }
                }
            }
        }
    };

    xhr.setRequestHeader("Content-Type", contentType);
    //Insert Custom Headers
    _.each(this.headers, function (value, key) {
        xhr.setRequestHeader(key, value);
    });

    xhr.send(body);

    return success;
};

/**
 * Captures when the RestClient cannot create an XHR object
 * @param error
 * @param data
 * @event
 */
RestClient.prototype.XHRFailure = function (error, data) {
};

/**
 * Captures when the Authorize method returns a success response
 * @param xhr
 * @param response
 * @event
 */
RestClient.prototype.AuthorizeSuccess = function (xhr, response) {
};

/**
 * Captures when the Authorize method returns a failure response
 * @param xhr
 * @param response
 * @event
 */
RestClient.prototype.AuthorizeFailure = function (xhr, response) {
};

/**
 * Captures when the Authorize method change the state (XHR)
 * @param xhr
 * @event
 */
RestClient.prototype.AuthorizeReady = function (xhr) {
};

/**
 * Captures when the Authorize method fires the refresh token authorization successfuly
 * @param accessToken
 * @event
 */
RestClient.prototype.AuthorizeAutoRefresh = function (accessToken) {
};

/**
 * Captures when the Consume method returns a success response
 * @param xhr
 * @param response
 * @event
 */
RestClient.prototype.ConsumeSuccess = function (xhr, response) {
};

/**
 * Captures when the Consume method returns a failure response
 * @param xhr
 * @param response
 * @event
 */
RestClient.prototype.ConsumeFailure = function (xhr, response) {
};

/**
 * Captures when the Consume method change the state (XHR)
 * @param xhr
 * @event
 */
RestClient.prototype.ConsumeReady = function (xhr) {
};

//Define Module to be used in server side (Node.js)
if (typeof exports !== 'undefined') {
    module.exports = {
        RestClient: RestClient,
        RCBase64: RCBase64
    };
    var _ = require('underscore');
}
/**
 * @preserve jquery.layout 1.3.0 - Release Candidate 30.62
 * $Date: 2012-08-04 08:00:00 (Thu, 23 Aug 2012) $
 * $Rev: 303006 $
 *
 * Copyright (c) 2012 
 *   Fabrizio Balliano (http://www.fabrizioballiano.net)
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * Changelog: http://layout.jquery-dev.net/changelog.cfm#1.3.0.rc30.62
 * NOTE: This is a short-term release to patch a couple of bugs.
 * These bugs are listed as officially fixed in RC30.7, which will be released shortly.
 *
 * Docs: http://layout.jquery-dev.net/documentation.html
 * Tips: http://layout.jquery-dev.net/tips.html
 * Help: http://groups.google.com/group/jquery-ui-layout
 */

/* JavaDoc Info: http://code.google.com/closure/compiler/docs/js-for-compiler.html
 * {!Object}	non-nullable type (never NULL)
 * {?string}	nullable type (sometimes NULL) - default for {Object}
 * {number=}	optional parameter
 * {*}			ALL types
 */

// NOTE: For best readability, view with a fixed-width font and tabs equal to 4-chars

;(function ($) {

// alias Math methods - used a lot!
var	min		= Math.min
,	max		= Math.max
,	round	= Math.floor

,	isStr	=  function (v) { return $.type(v) === "string"; }

,	runPluginCallbacks = function (Instance, a_fn) {
		if ($.isArray(a_fn))
			for (var i=0, c=a_fn.length; i<c; i++) {
				var fn = a_fn[i];
				try {
					if (isStr(fn)) // 'name' of a function
						fn = eval(fn);
					if ($.isFunction(fn))
						fn( Instance );
				} catch (ex) {}
			}
	}

;


/*
 *	GENERIC $.layout METHODS - used by all layouts
 */
$.layout = {

	version:	"1.3.rc30.62"
,	revision:	0.033006 // 1.3.0 final = 1.0300 - major(n+).minor(nn)+patch(nn+)

	// can update code here if $.browser is phased out
,	browser: {
		mozilla:	!!$.browser.mozilla
	,	webkit:		!!$.browser.webkit || !!$.browser.safari // webkit = jQ 1.4
	,	msie:		!!$.browser.msie
	,	isIE6:		$.browser.msie && $.browser.version == 6
	,	boxModel:	$.support.boxModel !== false || !$.browser.msie // ONLY IE reverts to old box-model - update for older jQ onReady
	,	version:	$.browser.version // not used in Layout core, but may be used by plugins
	}

	// *PREDEFINED* EFFECTS & DEFAULTS 
	// MUST list effect here - OR MUST set an fxSettings option (can be an empty hash: {})
,	effects: {

	//	Pane Open/Close Animations
		slide: {
			all:	{ duration:  "fast"	} // eg: duration: 1000, easing: "easeOutBounce"
		,	north:	{ direction: "up"	}
		,	south:	{ direction: "down"	}
		,	east:	{ direction: "right"}
		,	west:	{ direction: "left"	}
		}
	,	drop: {
			all:	{ duration:  "slow"	}
		,	north:	{ direction: "up"	}
		,	south:	{ direction: "down"	}
		,	east:	{ direction: "right"}
		,	west:	{ direction: "left"	}
		}
	,	scale: {
			all:	{ duration:	"fast"	}
		}
	//	these are not recommended, but can be used
	,	blind:		{}
	,	clip:		{}
	,	explode:	{}
	,	fade:		{}
	,	fold:		{}
	,	puff:		{}

	//	Pane Resize Animations
	,	size: {
			all:	{ easing:	"swing"	}
		}
	}

	// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
,	config: {
		optionRootKeys:	"effects,panes,north,south,west,east,center".split(",")
	,	allPanes:		"north,south,west,east,center".split(",")
	,	borderPanes:	"north,south,west,east".split(",")
	,	oppositeEdge: {
			north:	"south"
		,	south:	"north"
		,	east: 	"west"
		,	west: 	"east"
		}
	//	offscreen data
	,	offscreenCSS:	{ left: "-99999px", right: "auto" } // used by hide/close if useOffscreenClose=true
	,	offscreenReset:	"offscreenReset" // key used for data
	//	CSS used in multiple places
	,	hidden:		{ visibility: "hidden" }
	,	visible:	{ visibility: "visible" }
	//	layout element settings
	,	resizers: {
			cssReq: {
				position: 	"absolute"
			,	padding: 	0
			,	margin: 	0
			,	fontSize:	"1px"
			,	textAlign:	"left"	// to counter-act "center" alignment!
			,	overflow: 	"hidden" // prevent toggler-button from overflowing
			//	SEE $.layout.defaults.zIndexes.resizer_normal
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				background: "#DDD"
			,	border:		"none"
			}
		}
	,	togglers: {
			cssReq: {
				position: 	"absolute"
			,	display: 	"block"
			,	padding: 	0
			,	margin: 	0
			,	overflow:	"hidden"
			,	textAlign:	"center"
			,	fontSize:	"1px"
			,	cursor: 	"pointer"
			,	zIndex: 	1
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				background: "#AAA"
			}
		}
	,	content: {
			cssReq: {
				position:	"relative" /* contain floated or positioned elements */
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				overflow:	"auto"
			,	padding:	"10px"
			}
		,	cssDemoPane: { // DEMO CSS - REMOVE scrolling from 'pane' when it has a content-div
				overflow:	"hidden"
			,	padding:	0
			}
		}
	,	panes: { // defaults for ALL panes - overridden by 'per-pane settings' below
			cssReq: {
				position: 	"absolute"
			,	margin:		0
			//	$.layout.defaults.zIndexes.pane_normal
			}
		,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
				padding:	"10px"
			,	background:	"#FFF"
			,	border:		"1px solid #BBB"
			,	overflow:	"auto"
			}
		}
	,	north: {
			side:			"Top"
		,	sizeType:		"Height"
		,	dir:			"horz"
		,	cssReq: {
				top: 		0
			,	bottom: 	"auto"
			,	left: 		0
			,	right: 		0
			,	width: 		"auto"
			//	height: 	DYNAMIC
			}
		}
	,	south: {
			side:			"Bottom"
		,	sizeType:		"Height"
		,	dir:			"horz"
		,	cssReq: {
				top: 		"auto"
			,	bottom: 	0
			,	left: 		0
			,	right: 		0
			,	width: 		"auto"
			//	height: 	DYNAMIC
			}
		}
	,	east: {
			side:			"Right"
		,	sizeType:		"Width"
		,	dir:			"vert"
		,	cssReq: {
				left: 		"auto"
			,	right: 		0
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			//	width: 		DYNAMIC
			}
		}
	,	west: {
			side:			"Left"
		,	sizeType:		"Width"
		,	dir:			"vert"
		,	cssReq: {
				left: 		0
			,	right: 		"auto"
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			//	width: 		DYNAMIC
			}
		}
	,	center: {
			dir:			"center"
		,	cssReq: {
				left: 		"auto" // DYNAMIC
			,	right: 		"auto" // DYNAMIC
			,	top: 		"auto" // DYNAMIC
			,	bottom: 	"auto" // DYNAMIC
			,	height: 	"auto"
			,	width: 		"auto"
			}
		}
	}

	// CALLBACK FUNCTION NAMESPACE - used to store reusable callback functions
,	callbacks: {}

,	getParentPaneElem: function (el) {
		// must pass either a container or pane element
		var $el = $(el)
		,	layout = $el.data("layout") || $el.data("parentLayout");
		if (layout) {
			var $cont = layout.container;
			// see if this container is directly-nested inside an outer-pane
			if ($cont.data("layoutPane")) return $cont;
			var $pane = $cont.closest("."+ $.layout.defaults.panes.paneClass);
			// if a pane was found, return it
			if ($pane.data("layoutPane")) return $pane;
		}
		return null;
	}

,	getParentPaneInstance: function (el) {
		// must pass either a container or pane element
		var $pane = $.layout.getParentPaneElem(el);
		return $pane ? $pane.data("layoutPane") : null;
	}

,	getParentLayoutInstance: function (el) {
		// must pass either a container or pane element
		var $pane = $.layout.getParentPaneElem(el);
		return $pane ? $pane.data("parentLayout") : null;
	}

,	getEventObject: function (evt) {
		return typeof evt === "object" && evt.stopPropagation ? evt : null;
	}
,	parsePaneName: function (evt_or_pane) {
		// getEventObject() automatically calls .stopPropagation(), WHICH MUST BE DONE!
		var evt = $.layout.getEventObject( evt_or_pane );
		if (evt) {
			// ALWAYS stop propagation of events triggered in Layout!
			evt.stopPropagation();
			return $(this).data("layoutEdge");
		}
		else
			return evt_or_pane;
	}


	// LAYOUT-PLUGIN REGISTRATION
	// more plugins can added beyond this default list
,	plugins: {
		draggable:		!!$.fn.draggable // resizing
	,	effects: {
			core:		!!$.effects		// animimations (specific effects tested by initOptions)
		,	slide:		$.effects && $.effects.slide // default effect
		}
	}

//	arrays of plugin or other methods to be triggered for events in *each layout* - will be passed 'Instance'
,	onCreate:	[]	// runs when layout is just starting to be created - right after options are set
,	onLoad:		[]	// runs after layout container and global events init, but before initPanes is called
,	onReady:	[]	// runs after initialization *completes* - ie, after initPanes completes successfully
,	onDestroy:	[]	// runs after layout is destroyed
,	onUnload:	[]	// runs after layout is destroyed OR when page unloads
,	afterOpen:	[]	// runs after setAsOpen() completes
,	afterClose:	[]	// runs after setAsClosed() completes

	/*
	*	GENERIC UTILITY METHODS
	*/

	// calculate and return the scrollbar width, as an integer
,	scrollbarWidth:		function () { return window.scrollbarWidth  || $.layout.getScrollbarSize('width'); }
,	scrollbarHeight:	function () { return window.scrollbarHeight || $.layout.getScrollbarSize('height'); }
,	getScrollbarSize:	function (dim) {
		var $c	= $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; overflow: scroll;"></div>').appendTo("body");
		var d	= { width: $c.width() - $c[0].clientWidth, height: $c.height() - $c[0].clientHeight };
		$c.remove();
		window.scrollbarWidth	= d.width;
		window.scrollbarHeight	= d.height;
		return dim.match(/^(width|height)$/) ? d[dim] : d;
	}


	/**
	* Returns hash container 'display' and 'visibility'
	*
	* @see	$.swap() - swaps CSS, runs callback, resets CSS
	*/
,	showInvisibly: function ($E, force) {
		if ($E && $E.length && (force || $E.css('display') === "none")) { // only if not *already hidden*
			var s = $E[0].style
				// save ONLY the 'style' props because that is what we must restore
			,	CSS = { display: s.display || '', visibility: s.visibility || '' };
			// show element 'invisibly' so can be measured
			$E.css({ display: "block", visibility: "hidden" });
			return CSS;
		}
		return {};
	}

	/**
	* Returns data for setting size of an element (container or a pane).
	*
	* @see  _create(), onWindowResize() for container, plus others for pane
	* @return JSON  Returns a hash of all dimensions: top, bottom, left, right, outerWidth, innerHeight, etc
	*/
,	getElementDimensions: function ($E) {
		var
			d	= {}			// dimensions hash
		,	x	= d.css = {}	// CSS hash
		,	i	= {}			// TEMP insets
		,	b, p				// TEMP border, padding
		,	N	= $.layout.cssNum
		,	off = $E.offset()
		;
		d.offsetLeft = off.left;
		d.offsetTop  = off.top;

		$.each("Left,Right,Top,Bottom".split(","), function (idx, e) { // e = edge
			b = x["border" + e] = $.layout.borderWidth($E, e);
			p = x["padding"+ e] = $.layout.cssNum($E, "padding"+e);
			i[e] = b + p; // total offset of content from outer side
			d["inset"+ e] = p;	// eg: insetLeft = paddingLeft
		});

		d.offsetWidth	= $E.innerWidth();	// offsetWidth is used in calc when doing manual resize
		d.offsetHeight	= $E.innerHeight();	// ditto
		d.outerWidth	= $E.outerWidth();
		d.outerHeight	= $E.outerHeight();
		d.innerWidth	= max(0, d.outerWidth  - i.Left - i.Right);
		d.innerHeight	= max(0, d.outerHeight - i.Top  - i.Bottom);

		x.width		= $E.width();
		x.height	= $E.height();
		x.top		= N($E,"top",true);
		x.bottom	= N($E,"bottom",true);
		x.left		= N($E,"left",true);
		x.right		= N($E,"right",true);

		//d.visible	= $E.is(":visible");// && x.width > 0 && x.height > 0;

		return d;
	}

,	getElementCSS: function ($E, list) {
		var
			CSS	= {}
		,	style	= $E[0].style
		,	props	= list.split(",")
		,	sides	= "Top,Bottom,Left,Right".split(",")
		,	attrs	= "Color,Style,Width".split(",")
		,	p, s, a, i, j, k
		;
		for (i=0; i < props.length; i++) {
			p = props[i];
			if (p.match(/(border|padding|margin)$/))
				for (j=0; j < 4; j++) {
					s = sides[j];
					if (p === "border")
						for (k=0; k < 3; k++) {
							a = attrs[k];
							CSS[p+s+a] = style[p+s+a];
						}
					else
						CSS[p+s] = style[p+s];
				}
			else
				CSS[p] = style[p];
		};
		return CSS
	}

	/**
	* Return the innerWidth for the current browser/doctype
	*
	* @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
	* @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
	* @param  {number=}			outerWidth (optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}			Returns the innerWidth of the elem by subtracting padding and borders
	*/
,	cssWidth: function ($E, outerWidth) {
		// a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
		if (outerWidth <= 0) return 0;

		if (!$.layout.browser.boxModel) return outerWidth;

		// strip border and padding from outerWidth to get CSS Width
		var b = $.layout.borderWidth
		,	n = $.layout.cssNum
		,	W = outerWidth
				- b($E, "Left")
				- b($E, "Right")
				- n($E, "paddingLeft")		
				- n($E, "paddingRight");

		return max(0,W);
	}

	/**
	* Return the innerHeight for the current browser/doctype
	*
	* @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
	* @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
	* @param  {number=}			outerHeight  (optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}			Returns the innerHeight of the elem by subtracting padding and borders
	*/
,	cssHeight: function ($E, outerHeight) {
		// a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
		if (outerHeight <= 0) return 0;

		if (!$.layout.browser.boxModel) return outerHeight;

		// strip border and padding from outerHeight to get CSS Height
		var b = $.layout.borderWidth
		,	n = $.layout.cssNum
		,	H = outerHeight
			- b($E, "Top")
			- b($E, "Bottom")
			- n($E, "paddingTop")
			- n($E, "paddingBottom");

		return max(0,H);
	}

	/**
	* Returns the 'current CSS numeric value' for a CSS property - 0 if property does not exist
	*
	* @see  Called by many methods
	* @param {Array.<Object>}	$E					Must pass a jQuery object - first element is processed
	* @param {string}			prop				The name of the CSS property, eg: top, width, etc.
	* @param {boolean=}			[allowAuto=false]	true = return 'auto' if that is value; false = return 0
	* @return {(string|number)}						Usually used to get an integer value for position (top, left) or size (height, width)
	*/
,	cssNum: function ($E, prop, allowAuto) {
		if (!$E.jquery) $E = $($E);
		var CSS = $.layout.showInvisibly($E)
		,	p	= $.css($E[0], prop, true)
		,	v	= allowAuto && p=="auto" ? p : (parseInt(p, 10) || 0);
		$E.css( CSS ); // RESET
		return v;
	}

,	borderWidth: function (el, side) {
		if (el.jquery) el = el[0];
		var b = "border"+ side.substr(0,1).toUpperCase() + side.substr(1); // left => Left
		return $.css(el, b+"Style", true) === "none" ? 0 : (parseInt($.css(el, b+"Width", true), 10) || 0);
	}

	/**
	* Mouse-tracking utility - FUTURE REFERENCE
	*
	* init: if (!window.mouse) {
	*			window.mouse = { x: 0, y: 0 };
	*			$(document).mousemove( $.layout.trackMouse );
	*		}
	*
	* @param {Object}		evt
	*
,	trackMouse: function (evt) {
		window.mouse = { x: evt.clientX, y: evt.clientY };
	}
	*/

	/**
	* SUBROUTINE for preventPrematureSlideClose option
	*
	* @param {Object}		evt
	* @param {Object=}		el
	*/
,	isMouseOverElem: function (evt, el) {
		var
			$E	= $(el || this)
		,	d	= $E.offset()
		,	T	= d.top
		,	L	= d.left
		,	R	= L + $E.outerWidth()
		,	B	= T + $E.outerHeight()
		,	x	= evt.pageX	// evt.clientX ?
		,	y	= evt.pageY	// evt.clientY ?
		;
		// if X & Y are < 0, probably means is over an open SELECT
		return ($.layout.browser.msie && x < 0 && y < 0) || ((x >= L && x <= R) && (y >= T && y <= B));
	}

	/**
	* Message/Logging Utility
	*
	* @example $.layout.msg("My message");				// log text
	* @example $.layout.msg("My message", true);		// alert text
	* @example $.layout.msg({ foo: "bar" }, "Title");	// log hash-data, with custom title
	* @example $.layout.msg({ foo: "bar" }, true, "Title", { sort: false }); -OR-
	* @example $.layout.msg({ foo: "bar" }, "Title", { sort: false, display: true }); // alert hash-data
	*
	* @param {(Object|string)}			info			String message OR Hash/Array
	* @param {(Boolean|string|Object)=}	[popup=false]	True means alert-box - can be skipped
	* @param {(Object|string)=}			[debugTitle=""]	Title for Hash data - can be skipped
	* @param {Object=}					[debugOpts]		Extra options for debug output
	*/
,	msg: function (info, popup, debugTitle, debugOpts) {
		if ($.isPlainObject(info) && window.debugData) {
			if (typeof popup === "string") {
				debugOpts	= debugTitle;
				debugTitle	= popup;
			}
			else if (typeof debugTitle === "object") {
				debugOpts	= debugTitle;
				debugTitle	= null;
			}
			var t = debugTitle || "log( <object> )"
			,	o = $.extend({ sort: false, returnHTML: false, display: false }, debugOpts);
			if (popup === true || o.display)
				debugData( info, t, o );
			else if (window.console)
				console.log(debugData( info, t, o ));
		}
		else if (popup)
			alert(info);
		else if (window.console)
			console.log(info);
		else {
			var id	= "#layoutLogger"
			,	$l = $(id);
			if (!$l.length)
				$l = createLog();
			$l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">'+ info.replace(/\</g,"&lt;").replace(/\>/g,"&gt;") +'</li>');
		}

		function createLog () {
			var pos = $.support.fixedPosition ? 'fixed' : 'absolute'
			,	$e = $('<div id="layoutLogger" style="position: '+ pos +'; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'
				+	'<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'
				+	'<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'
				+	'<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'
				+ '</div>'
				).appendTo("body");
			$e.css('left', $(window).width() - $e.outerWidth() - 5)
			if ($.ui.draggable) $e.draggable({ handle: ':first-child' });
			return $e;
		};
	}

};

// DEFAULT OPTIONS
$.layout.defaults = {
/*
 *	LAYOUT & LAYOUT-CONTAINER OPTIONS
 *	- none of these options are applicable to individual panes
 */
	name:						""			// Not required, but useful for buttons and used for the state-cookie
,	containerSelector:			""			// ONLY used when specifying a childOptions - to find container-element that is NOT directly-nested
,	containerClass:				"ui-layout-container" // layout-container element
,	scrollToBookmarkOnLoad:		true		// after creating a layout, scroll to bookmark in URL (.../page.htm#myBookmark)
,	resizeWithWindow:			true		// bind thisLayout.resizeAll() to the window.resize event
,	resizeWithWindowDelay:		200			// delay calling resizeAll because makes window resizing very jerky
,	resizeWithWindowMaxDelay:	0			// 0 = none - force resize every XX ms while window is being resized
,	onresizeall_start:			null		// CALLBACK when resizeAll() STARTS	- NOT pane-specific
,	onresizeall_end:			null		// CALLBACK when resizeAll() ENDS	- NOT pane-specific
,	onload_start:				null		// CALLBACK when Layout inits - after options initialized, but before elements
,	onload_end:					null		// CALLBACK when Layout inits - after EVERYTHING has been initialized
,	onunload_start:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
,	onunload_end:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
,	initPanes:					true		// false = DO NOT initialize the panes onLoad - will init later
,	showErrorMessages:			true		// enables fatal error messages to warn developers of common errors
,	showDebugMessages:			false		// display console-and-alert debug msgs - IF this Layout version _has_ debugging code!
//	Changing this zIndex value will cause other zIndex values to automatically change
,	zIndex:						null		// the PANE zIndex - resizers and masks will be +1
//	DO NOT CHANGE the zIndex values below unless you clearly understand their relationships
,	zIndexes: {								// set _default_ z-index values here...
		pane_normal:			0			// normal z-index for panes
	,	content_mask:			1			// applied to overlays used to mask content INSIDE panes during resizing
	,	resizer_normal:			2			// normal z-index for resizer-bars
	,	pane_sliding:			100			// applied to *BOTH* the pane and its resizer when a pane is 'slid open'
	,	pane_animate:			1000		// applied to the pane when being animated - not applied to the resizer
	,	resizer_drag:			10000		// applied to the CLONED resizer-bar when being 'dragged'
	}
,	errors: {
		pane:					"pane"		// description of "layout pane element" - used only in error messages
	,	selector:				"selector"	// description of "jQuery-selector" - used only in error messages
	,	addButtonError:			"Error Adding Button \n\nInvalid "
	,	containerMissing:		"UI Layout Initialization Error\n\nThe specified layout-container does not exist."
	,	centerPaneMissing:		"UI Layout Initialization Error\n\nThe center-pane element does not exist.\n\nThe center-pane is a required element."
	,	noContainerHeight:		"UI Layout Initialization Warning\n\nThe layout-container \"CONTAINER\" has no height.\n\nTherefore the layout is 0-height and hence 'invisible'!"
	,	callbackError:			"UI Layout Callback Error\n\nThe EVENT callback is not a valid function."
	}
/*
 *	PANE DEFAULT SETTINGS
 *	- settings under the 'panes' key become the default settings for *all panes*
 *	- ALL pane-options can also be set specifically for each panes, which will override these 'default values'
 */
,	panes: { // default options for 'all panes' - will be overridden by 'per-pane settings'
		applyDemoStyles: 		false		// NOTE: renamed from applyDefaultStyles for clarity
	,	closable:				true		// pane can open & close
	,	resizable:				true		// when open, pane can be resized 
	,	slidable:				true		// when closed, pane can 'slide open' over other panes - closes on mouse-out
	,	initClosed:				false		// true = init pane as 'closed'
	,	initHidden: 			false 		// true = init pane as 'hidden' - no resizer-bar/spacing
	//	SELECTORS
	//,	paneSelector:			""			// MUST be pane-specific - jQuery selector for pane
	,	contentSelector:		".ui-layout-content" // INNER div/element to auto-size so only it scrolls, not the entire pane!
	,	contentIgnoreSelector:	".ui-layout-ignore"	// element(s) to 'ignore' when measuring 'content'
	,	findNestedContent:		false		// true = $P.find(contentSelector), false = $P.children(contentSelector)
	//	GENERIC ROOT-CLASSES - for auto-generated classNames
	,	paneClass:				"ui-layout-pane"	// Layout Pane
	,	resizerClass:			"ui-layout-resizer"	// Resizer Bar
	,	togglerClass:			"ui-layout-toggler"	// Toggler Button
	,	buttonClass:			"ui-layout-button"	// CUSTOM Buttons	- eg: '[ui-layout-button]-toggle/-open/-close/-pin'
	//	ELEMENT SIZE & SPACING
	//,	size:					100			// MUST be pane-specific -initial size of pane
	,	minSize:				0			// when manually resizing a pane
	,	maxSize:				0			// ditto, 0 = no limit
	,	spacing_open:			6			// space between pane and adjacent panes - when pane is 'open'
	,	spacing_closed:			6			// ditto - when pane is 'closed'
	,	togglerLength_open:		50			// Length = WIDTH of toggler button on north/south sides - HEIGHT on east/west sides
	,	togglerLength_closed: 	50			// 100% OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
	,	togglerAlign_open:		"center"	// top/left, bottom/right, center, OR...
	,	togglerAlign_closed:	"center"	// 1 => nn = offset from top/left, -1 => -nn == offset from bottom/right
	,	togglerContent_open:	""			// text or HTML to put INSIDE the toggler
	,	togglerContent_closed:	""			// ditto
	//	RESIZING OPTIONS
	,	resizerDblClickToggle:	true		// 
	,	autoResize:				true		// IF size is 'auto' or a percentage, then recalc 'pixel size' whenever the layout resizes
	,	autoReopen:				true		// IF a pane was auto-closed due to noRoom, reopen it when there is room? False = leave it closed
	,	resizerDragOpacity:		1			// option for ui.draggable
	//,	resizerCursor:			""			// MUST be pane-specific - cursor when over resizer-bar
	,	maskContents:			false		// true = add DIV-mask over-or-inside this pane so can 'drag' over IFRAMES
	,	maskObjects:			false		// true = add IFRAME-mask over-or-inside this pane to cover objects/applets - content-mask will overlay this mask
	,	maskZindex:				null		// will override zIndexes.content_mask if specified - not applicable to iframe-panes
	,	resizingGrid:			false		// grid size that the resizers will snap-to during resizing, eg: [20,20]
	,	livePaneResizing:		false		// true = LIVE Resizing as resizer is dragged
	,	liveContentResizing:	false		// true = re-measure header/footer heights as resizer is dragged
	,	liveResizingTolerance:	1			// how many px change before pane resizes, to control performance
	//	SLIDING OPTIONS
	,	sliderCursor:			"pointer"	// cursor when resizer-bar will trigger 'sliding'
	,	slideTrigger_open:		"click"		// click, dblclick, mouseenter
	,	slideTrigger_close:		"mouseleave"// click, mouseleave
	,	slideDelay_open:		300			// applies only for mouseenter event - 0 = instant open
	,	slideDelay_close:		300			// applies only for mouseleave event (300ms is the minimum!)
	,	hideTogglerOnSlide:		false		// when pane is slid-open, should the toggler show?
	,	preventQuickSlideClose:	$.layout.browser.webkit // Chrome triggers slideClosed as it is opening
	,	preventPrematureSlideClose: false	// handle incorrect mouseleave trigger, like when over a SELECT-list in IE
	//	PANE-SPECIFIC TIPS & MESSAGES
	,	tips: {
			Open:				"Open"		// eg: "Open Pane"
		,	Close:				"Close"
		,	Resize:				"Resize"
		,	Slide:				"Slide Open"
		,	Pin:				"Pin"
		,	Unpin:				"Un-Pin"
		,	noRoomToOpen:		"Not enough room to show this panel."	// alert if user tries to open a pane that cannot
		,	minSizeWarning:		"Panel has reached its minimum size"	// displays in browser statusbar
		,	maxSizeWarning:		"Panel has reached its maximum size"	// ditto
		}
	//	HOT-KEYS & MISC
	,	showOverflowOnHover:	false		// will bind allowOverflow() utility to pane.onMouseOver
	,	enableCursorHotkey:		true		// enabled 'cursor' hotkeys
	//,	customHotkey:			""			// MUST be pane-specific - EITHER a charCode OR a character
	,	customHotkeyModifier:	"SHIFT"		// either 'SHIFT', 'CTRL' or 'CTRL+SHIFT' - NOT 'ALT'
	//	PANE ANIMATION
	//	NOTE: fxSss_open, fxSss_close & fxSss_size options (eg: fxName_open) are auto-generated if not passed
	,	fxName:					"slide" 	// ('none' or blank), slide, drop, scale -- only relevant to 'open' & 'close', NOT 'size'
	,	fxSpeed:				null		// slow, normal, fast, 200, nnn - if passed, will OVERRIDE fxSettings.duration
	,	fxSettings:				{}			// can be passed, eg: { easing: "easeOutBounce", duration: 1500 }
	,	fxOpacityFix:			true		// tries to fix opacity in IE to restore anti-aliasing after animation
	,	animatePaneSizing:		false		// true = animate resizing after dragging resizer-bar OR sizePane() is called
	/*  NOTE: Action-specific FX options are auto-generated from the options above if not specifically set:
		fxName_open:			"slide"		// 'Open' pane animation
		fnName_close:			"slide"		// 'Close' pane animation
		fxName_size:			"slide"		// 'Size' pane animation - when animatePaneSizing = true
		fxSpeed_open:			null
		fxSpeed_close:			null
		fxSpeed_size:			null
		fxSettings_open:		{}
		fxSettings_close:		{}
		fxSettings_size:		{}
	*/
	//	CHILD/NESTED LAYOUTS
	,	childOptions:			null		// Layout-options for nested/child layout - even {} is valid as options
	,	initChildLayout:		true		// true = child layout will be created as soon as _this_ layout completes initialization
	,	destroyChildLayout:		true		// true = destroy child-layout if this pane is destroyed
	,	resizeChildLayout:		true		// true = trigger child-layout.resizeAll() when this pane is resized
	//	EVENT TRIGGERING
	,	triggerEventsOnLoad:	false		// true = trigger onopen OR onclose callbacks when layout initializes
	,	triggerEventsDuringLiveResize: true	// true = trigger onresize callback REPEATEDLY if livePaneResizing==true
	//	PANE CALLBACKS
	,	onshow_start:			null		// CALLBACK when pane STARTS to Show	- BEFORE onopen/onhide_start
	,	onshow_end:				null		// CALLBACK when pane ENDS being Shown	- AFTER  onopen/onhide_end
	,	onhide_start:			null		// CALLBACK when pane STARTS to Close	- BEFORE onclose_start
	,	onhide_end:				null		// CALLBACK when pane ENDS being Closed	- AFTER  onclose_end
	,	onopen_start:			null		// CALLBACK when pane STARTS to Open
	,	onopen_end:				null		// CALLBACK when pane ENDS being Opened
	,	onclose_start:			null		// CALLBACK when pane STARTS to Close
	,	onclose_end:			null		// CALLBACK when pane ENDS being Closed
	,	onresize_start:			null		// CALLBACK when pane STARTS being Resized ***FOR ANY REASON***
	,	onresize_end:			null		// CALLBACK when pane ENDS being Resized ***FOR ANY REASON***
	,	onsizecontent_start:	null		// CALLBACK when sizing of content-element STARTS
	,	onsizecontent_end:		null		// CALLBACK when sizing of content-element ENDS
	,	onswap_start:			null		// CALLBACK when pane STARTS to Swap
	,	onswap_end:				null		// CALLBACK when pane ENDS being Swapped
	,	ondrag_start:			null		// CALLBACK when pane STARTS being ***MANUALLY*** Resized
	,	ondrag_end:				null		// CALLBACK when pane ENDS being ***MANUALLY*** Resized
	}
/*
 *	PANE-SPECIFIC SETTINGS
 *	- options listed below MUST be specified per-pane - they CANNOT be set under 'panes'
 *	- all options under the 'panes' key can also be set specifically for any pane
 *	- most options under the 'panes' key apply only to 'border-panes' - NOT the the center-pane
 */
,	north: {
		paneSelector:			".ui-layout-north"
	,	size:					"auto"		// eg: "auto", "30%", .30, 200
	,	resizerCursor:			"n-resize"	// custom = url(myCursor.cur)
	,	customHotkey:			""			// EITHER a charCode (43) OR a character ("o")
	}
,	south: {
		paneSelector:			".ui-layout-south"
	,	size:					"auto"
	,	resizerCursor:			"s-resize"
	,	customHotkey:			""
	}
,	east: {
		paneSelector:			".ui-layout-east"
	,	size:					200
	,	resizerCursor:			"e-resize"
	,	customHotkey:			""
	}
,	west: {
		paneSelector:			".ui-layout-west"
	,	size:					200
	,	resizerCursor:			"w-resize"
	,	customHotkey:			""
	}
,	center: {
		paneSelector:			".ui-layout-center"
	,	minWidth:				0
	,	minHeight:				0
	}
};

$.layout.optionsMap = {
	// layout/global options - NOT pane-options
	layout: ("stateManagement,effects,zIndexes,errors,"
	+	"name,zIndex,scrollToBookmarkOnLoad,showErrorMessages,"
	+	"resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"
	+	"onresizeall,onresizeall_start,onresizeall_end,onload,onunload").split(",")
//	borderPanes: [ ALL options that are NOT specified as 'layout' ]
	// default.panes options that apply to the center-pane (most options apply _only_ to border-panes)
,	center: ("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"
	+	"showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"
	+	"childOptions,initChildLayout,resizeChildLayout,destroyChildLayout,"
	+	"onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(",")
	// options that MUST be specifically set 'per-pane' - CANNOT set in the panes (defaults) key
,	noDefault: ("paneSelector,resizerCursor,customHotkey").split(",")
};

/**
 * Processes options passed in converts flat-format data into subkey (JSON) format
 * In flat-format, subkeys are _currently_ separated with 2 underscores, like north__optName
 * Plugins may also call this method so they can transform their own data
 *
 * @param  {!Object}	hash	Data/options passed by user - may be a single level or nested levels
 * @return {Object}				Returns hash of minWidth & minHeight
 */
$.layout.transformData = function (hash) {
	var	json = { panes: {}, center: {} } // init return object
	,	data, branch, optKey, keys, key, val, i, c;

	if (typeof hash !== "object") return json; // no options passed

	// convert all 'flat-keys' to 'sub-key' format
	for (optKey in hash) {
		branch	= json;
		data	= $.layout.optionsMap.layout;
		val		= hash[ optKey ];
		keys	= optKey.split("__"); // eg: west__size or north__fxSettings__duration
		c		= keys.length - 1;
		// convert underscore-delimited to subkeys
		for (i=0; i <= c; i++) {
			key = keys[i];
			if (i === c)
				branch[key] = val;
			else if (!branch[key])
				branch[key] = {}; // create the subkey
			// recurse to sub-key for next loop - if not done
			branch = branch[key];
		}
	}

	return json;
};

// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
$.layout.backwardCompatibility = {
	// data used by renameOldOptions()
	map: {
	//	OLD Option Name:			NEW Option Name
		applyDefaultStyles:			"applyDemoStyles"
	,	resizeNestedLayout:			"resizeChildLayout"
	,	resizeWhileDragging:		"livePaneResizing"
	,	resizeContentWhileDragging:	"liveContentResizing"
	,	triggerEventsWhileDragging:	"triggerEventsDuringLiveResize"
	,	maskIframesOnResize:		"maskContents"
	,	useStateCookie:				"stateManagement.enabled"
	,	"cookie.autoLoad":			"stateManagement.autoLoad"
	,	"cookie.autoSave":			"stateManagement.autoSave"
	,	"cookie.keys":				"stateManagement.stateKeys"
	,	"cookie.name":				"stateManagement.cookie.name"
	,	"cookie.domain":			"stateManagement.cookie.domain"
	,	"cookie.path":				"stateManagement.cookie.path"
	,	"cookie.expires":			"stateManagement.cookie.expires"
	,	"cookie.secure":			"stateManagement.cookie.secure"
	//	OLD Language options
	,	noRoomToOpenTip:			"tips.noRoomToOpen"
	,	togglerTip_open:			"tips.Close"	// open   = Close
	,	togglerTip_closed:			"tips.Open"		// closed = Open
	,	resizerTip:					"tips.Resize"
	,	sliderTip:					"tips.Slide"
	}

/**
* @param {Object}	opts
*/
,	renameOptions: function (opts) {
		var map = $.layout.backwardCompatibility.map
		,	oldData, newData, value
		;
		for (var itemPath in map) {
			oldData	= getBranch( itemPath );
			value	= oldData.branch[ oldData.key ];
			if (value !== undefined) {
				newData = getBranch( map[itemPath], true );
				newData.branch[ newData.key ] = value;
				delete oldData.branch[ oldData.key ];
			}
		}

		/**
		* @param {string}	path
		* @param {boolean=}	[create=false]	Create path if does not exist
		*/
		function getBranch (path, create) {
			var a = path.split(".") // split keys into array
			,	c = a.length - 1
			,	D = { branch: opts, key: a[c] } // init branch at top & set key (last item)
			,	i = 0, k, undef;
			for (; i<c; i++) { // skip the last key (data)
				k = a[i];
				if (D.branch[ k ] == undefined) { // child-key does not exist
					if (create) {
						D.branch = D.branch[ k ] = {}; // create child-branch
					}
					else // can't go any farther
						D.branch = {}; // branch is undefined
				}
				else
					D.branch = D.branch[ k ]; // get child-branch
			}
			return D;
		};
	}

/**
* @param {Object}	opts
*/
,	renameAllOptions: function (opts) {
		var ren = $.layout.backwardCompatibility.renameOptions;
		// rename root (layout) options
		ren( opts );
		// rename 'defaults' to 'panes'
		if (opts.defaults) {
			if (typeof opts.panes !== "object")
				opts.panes = {};
			$.extend(true, opts.panes, opts.defaults);
			delete opts.defaults;
		}
		// rename options in the the options.panes key
		if (opts.panes) ren( opts.panes );
		// rename options inside *each pane key*, eg: options.west
		$.each($.layout.config.allPanes, function (i, pane) {
			if (opts[pane]) ren( opts[pane] );
		});	
		return opts;
	}
};




/*	============================================================
 *	BEGIN WIDGET: $( selector ).layout( {options} );
 *	============================================================
 */
$.fn.layout = function (opts) {
	var

	// local aliases to global data
	browser	= $.layout.browser
,	_c		= $.layout.config

	// local aliases to utlity methods
,	cssW	= $.layout.cssWidth
,	cssH	= $.layout.cssHeight
,	elDims	= $.layout.getElementDimensions
,	elCSS	= $.layout.getElementCSS
,	evtObj	= $.layout.getEventObject
,	evtPane	= $.layout.parsePaneName

/**
 * options - populated by initOptions()
 */
,	options = $.extend(true, {}, $.layout.defaults)
,	effects	= options.effects = $.extend(true, {}, $.layout.effects)

/**
 * layout-state object
 */
,	state = {
		// generate unique ID to use for event.namespace so can unbind only events added by 'this layout'
		id:			"layout"+ $.now()	// code uses alias: sID
	,	initialized: false
	,	container:	{} // init all keys
	,	north:		{}
	,	south:		{}
	,	east:		{}
	,	west:		{}
	,	center:		{}
	}

/**
 * parent/child-layout pointers
 */
//,	hasParentLayout	= false	- exists ONLY inside Instance so can be set externally
,	children = {
		north:		null
	,	south:		null
	,	east:		null
	,	west:		null
	,	center:		null
	}

/*
 * ###########################
 *  INTERNAL HELPER FUNCTIONS
 * ###########################
 */

	/**
	* Manages all internal timers
	*/
,	timer = {
		data:	{}
	,	set:	function (s, fn, ms) { timer.clear(s); timer.data[s] = setTimeout(fn, ms); }
	,	clear:	function (s) { var t=timer.data; if (t[s]) {clearTimeout(t[s]); delete t[s];} }
	}

	/**
	* Alert or console.log a message - IF option is enabled.
	*
	* @param {(string|!Object)}	msg		Message (or debug-data) to display
	* @param {?boolean}			popup	True by default, means 'alert', false means use console.log
	* @param {?boolean}			debug	True means is a widget debugging message
	*/
,	_log = function (msg, popup, debug) {
		var o = options;
		if ((o.showErrorMessages && !debug) || (debug && o.showDebugMessages))
			$.layout.msg( o.name +' / '+ msg, (popup !== false) );
		return false;
	}

	/**
	* Executes a Callback function after a trigger event, like resize, open or close
	*
	* @param {string}			evtName			Name of the layout callback, eg "onresize_start"
	* @param {?string}			pane			This is passed only so we can pass the 'pane object' to the callback
	* @param {?string|?boolean}	skipBoundEvents	True = do not run events bound to the elements - only the callbacks set in options
	*/
,	_runCallbacks = function (evtName, pane, skipBoundEvents) {
		var	paneCB	= pane && isStr(pane)
		,	s		= paneCB ? state[pane] : state
		,	o		= paneCB ? options[pane] : options
		,	lName	= options.name
			// names like onopen and onopen_end separate are interchangeable in options...
		,	lng		= evtName + (evtName.match(/_/) ? "" : "_end")
		,	shrt	= lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : ""
		,	fn		= o[lng] || o[shrt]
		,	retVal	= "NC" // NC = No Callback
		,	args	= []
		,	$P
		;
		if ( !paneCB && $.type(skipBoundEvents) !== 'boolean' )
			skipBoundEvents = pane; // allow pane param to be skipped for Layout callback

		// first trigger the callback set in the options
		if (fn) {
			try {
				// convert function name (string) to function object
				if (isStr( fn )) {
					if (fn.match(/,/)) {
						// function name cannot contain a comma, 
						// so must be a function name AND a parameter to pass
						args = fn.split(",")
						,	fn = eval(args[0]);
					}
					else // just the name of an external function?
						fn = eval(fn);
				}
				// execute the callback, if exists
				if ($.isFunction( fn )) {
					if (args.length)
						retVal = fn(args[1]); // pass the argument parsed from 'list'
					else if ( paneCB )
						// pass data: pane-name, pane-element, pane-state, pane-options, and layout-name
						retVal = fn( pane, $Ps[pane], s, o, lName );
					else // must be a layout/container callback - pass suitable info
						retVal = fn( Instance, s, o, lName );
				}
			}
			catch (ex) {
				_log( options.errors.callbackError.replace(/EVENT/, $.trim(pane +" "+ lng)), false );
			}
		}

		// trigger additional events bound directly to the pane
		if (!skipBoundEvents && retVal !== false) {
			if ( paneCB ) { // PANE events can be bound to each pane-elements
				$P	= $Ps[pane];
				o	= options[pane];
				s	= state[pane];
				$P.triggerHandler('layoutpane'+ lng, [ pane, $P, s, o, lName ]);
				if (shrt)
					$P.triggerHandler('layoutpane'+ shrt, [ pane, $P, s, o, lName ]);
			}
			else { // LAYOUT events can be bound to the container-element
				$N.triggerHandler('layout'+ lng, [ Instance, s, o, lName ]);
				if (shrt)
					$N.triggerHandler('layout'+ shrt, [ Instance, s, o, lName ]);
			}
		}

		// ALWAYS resizeChildLayout after a resize event - even during initialization
		if (evtName === "onresize_end" || evtName === "onsizecontent_end")
			resizeChildLayout(pane); 

		return retVal;
	}


	/**
	* cure iframe display issues in IE & other browsers
	*/
,	_fixIframe = function (pane) {
		if (browser.mozilla) return; // skip FireFox - it auto-refreshes iframes onShow
		var $P = $Ps[pane];
		// if the 'pane' is an iframe, do it
		if (state[pane].tagName === "IFRAME")
			$P.css(_c.hidden).css(_c.visible); 
		else // ditto for any iframes INSIDE the pane
			$P.find('IFRAME').css(_c.hidden).css(_c.visible);
	}

	/**
	* @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
	* @param  {number=}		outerSize	(optional) Can pass a width, allowing calculations BEFORE element is resized
	* @return {number}		Returns the innerHeight/Width of el by subtracting padding and borders
	*/
,	cssSize = function (pane, outerSize) {
		var fn = _c[pane].dir=="horz" ? cssH : cssW;
		return fn($Ps[pane], outerSize);
	}

	/**
	* @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
	* @return {Object}		Returns hash of minWidth & minHeight
	*/
,	cssMinDims = function (pane) {
		// minWidth/Height means CSS width/height = 1px
		var	$P	= $Ps[pane]
		,	dir	= _c[pane].dir
		,	d	= {
				minWidth:	1001 - cssW($P, 1000)
			,	minHeight:	1001 - cssH($P, 1000)
			}
		;
		if (dir === "horz") d.minSize = d.minHeight;
		if (dir === "vert") d.minSize = d.minWidth;
		return d;
	}

	// TODO: see if these methods can be made more useful...
	// TODO: *maybe* return cssW/H from these so caller can use this info

	/**
	* @param {(string|!Object)}		el
	* @param {number=}				outerWidth
	* @param {boolean=}				[autoHide=false]
	*/
,	setOuterWidth = function (el, outerWidth, autoHide) {
		var $E = el, w;
		if (isStr(el)) $E = $Ps[el]; // west
		else if (!el.jquery) $E = $(el);
		w = cssW($E, outerWidth);
		$E.css({ width: w });
		if (w > 0) {
			if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
				$E.show().data('autoHidden', false);
				if (!browser.mozilla) // FireFox refreshes iframes - IE does not
					// make hidden, then visible to 'refresh' display after animation
					$E.css(_c.hidden).css(_c.visible);
			}
		}
		else if (autoHide && !$E.data('autoHidden'))
			$E.hide().data('autoHidden', true);
	}

	/**
	* @param {(string|!Object)}		el
	* @param {number=}				outerHeight
	* @param {boolean=}				[autoHide=false]
	*/
,	setOuterHeight = function (el, outerHeight, autoHide) {
		var $E = el, h;
		if (isStr(el)) $E = $Ps[el]; // west
		else if (!el.jquery) $E = $(el);
		h = cssH($E, outerHeight);
		$E.css({ height: h, visibility: "visible" }); // may have been 'hidden' by sizeContent
		if (h > 0 && $E.innerWidth() > 0) {
			if (autoHide && $E.data('autoHidden')) {
				$E.show().data('autoHidden', false);
				if (!browser.mozilla) // FireFox refreshes iframes - IE does not
					$E.css(_c.hidden).css(_c.visible);
			}
		}
		else if (autoHide && !$E.data('autoHidden'))
			$E.hide().data('autoHidden', true);
	}

	/**
	* @param {(string|!Object)}		el
	* @param {number=}				outerSize
	* @param {boolean=}				[autoHide=false]
	*/
,	setOuterSize = function (el, outerSize, autoHide) {
		if (_c[pane].dir=="horz") // pane = north or south
			setOuterHeight(el, outerSize, autoHide);
		else // pane = east or west
			setOuterWidth(el, outerSize, autoHide);
	}


	/**
	* Converts any 'size' params to a pixel/integer size, if not already
	* If 'auto' or a decimal/percentage is passed as 'size', a pixel-size is calculated
	*
	/**
	* @param  {string}				pane
	* @param  {(string|number)=}	size
	* @param  {string=}				[dir]
	* @return {number}
	*/
,	_parseSize = function (pane, size, dir) {
		if (!dir) dir = _c[pane].dir;

		if (isStr(size) && size.match(/%/))
			size = (size === '100%') ? -1 : parseInt(size, 10) / 100; // convert % to decimal

		if (size === 0)
			return 0;
		else if (size >= 1)
			return parseInt(size, 10);

		var o = options, avail = 0;
		if (dir=="horz") // north or south or center.minHeight
			avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
		else if (dir=="vert") // east or west or center.minWidth
			avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);

		if (size === -1) // -1 == 100%
			return avail;
		else if (size > 0) // percentage, eg: .25
			return round(avail * size);
		else if (pane=="center")
			return 0;
		else { // size < 0 || size=='auto' || size==Missing || size==Invalid
			// auto-size the pane
			var	dim	= (dir === "horz" ? "height" : "width")
			,	$P	= $Ps[pane]
			,	$C	= dim === 'height' ? $Cs[pane] : false
			,	vis	= $.layout.showInvisibly($P) // show pane invisibly if hidden
			,	szP	= $P.css(dim) // SAVE current pane size
			,	szC	= $C ? $C.css(dim) : 0 // SAVE current content size
			;
			$P.css(dim, "auto");
			if ($C) $C.css(dim, "auto");
			size = (dim === "height") ? $P.outerHeight() : $P.outerWidth(); // MEASURE
			$P.css(dim, szP).css(vis); // RESET size & visibility
			if ($C) $C.css(dim, szC);
			return size;
		}
	}

	/**
	* Calculates current 'size' (outer-width or outer-height) of a border-pane - optionally with 'pane-spacing' added
	*
	* @param  {(string|!Object)}	pane
	* @param  {boolean=}			[inclSpace=false]
	* @return {number}				Returns EITHER Width for east/west panes OR Height for north/south panes
	*/
,	getPaneSize = function (pane, inclSpace) {
		var 
			$P	= $Ps[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	oSp	= (inclSpace ? o.spacing_open : 0)
		,	cSp	= (inclSpace ? o.spacing_closed : 0)
		;
		if (!$P || s.isHidden)
			return 0;
		else if (s.isClosed || (s.isSliding && inclSpace))
			return cSp;
		else if (_c[pane].dir === "horz")
			return $P.outerHeight() + oSp;
		else // dir === "vert"
			return $P.outerWidth() + oSp;
	}

	/**
	* Calculate min/max pane dimensions and limits for resizing
	*
	* @param  {string}		pane
	* @param  {boolean=}	[slide=false]
	*/
,	setSizeLimits = function (pane, slide) {
		if (!isInitialized()) return;
		var 
			o				= options[pane]
		,	s				= state[pane]
		,	c				= _c[pane]
		,	dir				= c.dir
		,	side			= c.side.toLowerCase()
		,	type			= c.sizeType.toLowerCase()
		,	isSliding		= (slide != undefined ? slide : s.isSliding) // only open() passes 'slide' param
		,	$P				= $Ps[pane]
		,	paneSpacing		= o.spacing_open
		//	measure the pane on the *opposite side* from this pane
		,	altPane			= _c.oppositeEdge[pane]
		,	altS			= state[altPane]
		,	$altP			= $Ps[altPane]
		,	altPaneSize		= (!$altP || altS.isVisible===false || altS.isSliding ? 0 : (dir=="horz" ? $altP.outerHeight() : $altP.outerWidth()))
		,	altPaneSpacing	= ((!$altP || altS.isHidden ? 0 : options[altPane][ altS.isClosed !== false ? "spacing_closed" : "spacing_open" ]) || 0)
		//	limitSize prevents this pane from 'overlapping' opposite pane
		,	containerSize	= (dir=="horz" ? sC.innerHeight : sC.innerWidth)
		,	minCenterDims	= cssMinDims("center")
		,	minCenterSize	= dir=="horz" ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth)
		//	if pane is 'sliding', then ignore center and alt-pane sizes - because 'overlays' them
		,	limitSize		= (containerSize - paneSpacing - (isSliding ? 0 : (_parseSize("center", minCenterSize, dir) + altPaneSize + altPaneSpacing)))
		,	minSize			= s.minSize = max( _parseSize(pane, o.minSize), cssMinDims(pane).minSize )
		,	maxSize			= s.maxSize = min( (o.maxSize ? _parseSize(pane, o.maxSize) : 100000), limitSize )
		,	r				= s.resizerPosition = {} // used to set resizing limits
		,	top				= sC.insetTop
		,	left			= sC.insetLeft
		,	W				= sC.innerWidth
		,	H				= sC.innerHeight
		,	rW				= o.spacing_open // subtract resizer-width to get top/left position for south/east
		;
		switch (pane) {
			case "north":	r.min = top + minSize;
							r.max = top + maxSize;
							break;
			case "west":	r.min = left + minSize;
							r.max = left + maxSize;
							break;
			case "south":	r.min = top + H - maxSize - rW;
							r.max = top + H - minSize - rW;
							break;
			case "east":	r.min = left + W - maxSize - rW;
							r.max = left + W - minSize - rW;
							break;
		};
	}

	/**
	* Returns data for setting the size/position of center pane. Also used to set Height for east/west panes
	*
	* @return JSON  Returns a hash of all dimensions: top, bottom, left, right, (outer) width and (outer) height
	*/
,	calcNewCenterPaneDims = function () {
		var d = {
			top:	getPaneSize("north", true) // true = include 'spacing' value for pane
		,	bottom:	getPaneSize("south", true)
		,	left:	getPaneSize("west", true)
		,	right:	getPaneSize("east", true)
		,	width:	0
		,	height:	0
		};

		// NOTE: sC = state.container
		// calc center-pane outer dimensions
		d.width		= sC.innerWidth - d.left - d.right;  // outerWidth
		d.height	= sC.innerHeight - d.bottom - d.top; // outerHeight
		// add the 'container border/padding' to get final positions relative to the container
		d.top		+= sC.insetTop;
		d.bottom	+= sC.insetBottom;
		d.left		+= sC.insetLeft;
		d.right		+= sC.insetRight;

		return d;
	}


	/**
	* @param {!Object}		el
	* @param {boolean=}		[allStates=false]
	*/
,	getHoverClasses = function (el, allStates) {
		var
			$El		= $(el)
		,	type	= $El.data("layoutRole")
		,	pane	= $El.data("layoutEdge")
		,	o		= options[pane]
		,	root	= o[type +"Class"]
		,	_pane	= "-"+ pane // eg: "-west"
		,	_open	= "-open"
		,	_closed	= "-closed"
		,	_slide	= "-sliding"
		,	_hover	= "-hover " // NOTE the trailing space
		,	_state	= $El.hasClass(root+_closed) ? _closed : _open
		,	_alt	= _state === _closed ? _open : _closed
		,	classes = (root+_hover) + (root+_pane+_hover) + (root+_state+_hover) + (root+_pane+_state+_hover)
		;
		if (allStates) // when 'removing' classes, also remove alternate-state classes
			classes += (root+_alt+_hover) + (root+_pane+_alt+_hover);

		if (type=="resizer" && $El.hasClass(root+_slide))
			classes += (root+_slide+_hover) + (root+_pane+_slide+_hover);

		return $.trim(classes);
	}
,	addHover	= function (evt, el) {
		var $E = $(el || this);
		if (evt && $E.data("layoutRole") === "toggler")
			evt.stopPropagation(); // prevent triggering 'slide' on Resizer-bar
		$E.addClass( getHoverClasses($E) );
	}
,	removeHover	= function (evt, el) {
		var $E = $(el || this);
		$E.removeClass( getHoverClasses($E, true) );
	}

,	onResizerEnter	= function (evt) { // ALSO called by toggler.mouseenter
		if ($.fn.disableSelection)
			$("body").disableSelection();
	}
,	onResizerLeave	= function (evt, el) {
		var
			e = el || this // el is only passed when called by the timer
		,	pane = $(e).data("layoutEdge")
		,	name = pane +"ResizerLeave"
		;
		timer.clear(pane+"_openSlider"); // cancel slideOpen timer, if set
		timer.clear(name); // cancel enableSelection timer - may re/set below
		// this method calls itself on a timer because it needs to allow
		// enough time for dragging to kick-in and set the isResizing flag
		// dragging has a 100ms delay set, so this delay must be >100
		if (!el) // 1st call - mouseleave event
			timer.set(name, function(){ onResizerLeave(evt, e); }, 200);
		// if user is resizing, then dragStop will enableSelection(), so can skip it here
		else if (!state[pane].isResizing && $.fn.enableSelection) // 2nd call - by timer
			$("body").enableSelection();
	}

/*
 * ###########################
 *   INITIALIZATION METHODS
 * ###########################
 */

	/**
	* Initialize the layout - called automatically whenever an instance of layout is created
	*
	* @see  none - triggered onInit
	* @return  mixed	true = fully initialized | false = panes not initialized (yet) | 'cancel' = abort
	*/
,	_create = function () {
		// initialize config/options
		initOptions();
		var o = options;

		// TEMP state so isInitialized returns true during init process
		state.creatingLayout = true;

		// init plugins for this layout, if there are any (eg: stateManagement)
		runPluginCallbacks( Instance, $.layout.onCreate );

		// options & state have been initialized, so now run beforeLoad callback
		// onload will CANCEL layout creation if it returns false
		if (false === _runCallbacks("onload_start"))
			return 'cancel';

		// initialize the container element
		_initContainer();

		// bind hotkey function - keyDown - if required
		initHotkeys();

		// bind window.onunload
		$(window).bind("unload."+ sID, unload);

		// init plugins for this layout, if there are any (eg: customButtons)
		runPluginCallbacks( Instance, $.layout.onLoad );

		// if layout elements are hidden, then layout WILL NOT complete initialization!
		// initLayoutElements will set initialized=true and run the onload callback IF successful
		if (o.initPanes) _initLayoutElements();

		delete state.creatingLayout;

		return state.initialized;
	}

	/**
	* Initialize the layout IF not already
	*
	* @see  All methods in Instance run this test
	* @return  boolean	true = layoutElements have been initialized | false = panes are not initialized (yet)
	*/
,	isInitialized = function () {
		if (state.initialized || state.creatingLayout) return true;	// already initialized
		else return _initLayoutElements();	// try to init panes NOW
	}

	/**
	* Initialize the layout - called automatically whenever an instance of layout is created
	*
	* @see  _create() & isInitialized
	* @return  An object pointer to the instance created
	*/
,	_initLayoutElements = function (retry) {
		// initialize config/options
		var o = options;

		// CANNOT init panes inside a hidden container!
		if (!$N.is(":visible")) {
			// handle Chrome bug where popup window 'has no height'
			// if layout is BODY element, try again in 50ms
			// SEE: http://layout.jquery-dev.net/samples/test_popup_window.html
			if ( !retry && browser.webkit && $N[0].tagName === "BODY" )
				setTimeout(function(){ _initLayoutElements(true); }, 50);
			return false;
		}

		// a center pane is required, so make sure it exists
		if (!getPane("center").length) {
			return _log( o.errors.centerPaneMissing );
		}

		// TEMP state so isInitialized returns true during init process
		state.creatingLayout = true;

		// update Container dims
		$.extend(sC, elDims( $N ));

		// initialize all layout elements
		initPanes();	// size & position panes - calls initHandles() - which calls initResizable()

		if (o.scrollToBookmarkOnLoad) {
			var l = self.location;
			if (l.hash) l.replace( l.hash ); // scrollTo Bookmark
		}

		// check to see if this layout 'nested' inside a pane
		if (Instance.hasParentLayout)
			o.resizeWithWindow = false;
		// bind resizeAll() for 'this layout instance' to window.resize event
		else if (o.resizeWithWindow)
			$(window).bind("resize."+ sID, windowResize);

		delete state.creatingLayout;
		state.initialized = true;

		// init plugins for this layout, if there are any
		runPluginCallbacks( Instance, $.layout.onReady );

		// now run the onload callback, if exists
		_runCallbacks("onload_end");

		return true; // elements initialized successfully
	}

	/**
	* Initialize nested layouts - called when _initLayoutElements completes
	*
	* NOT CURRENTLY USED
	*
	* @see _initLayoutElements
	* @return  An object pointer to the instance created
	*/
,	_initChildLayouts = function () {
		$.each(_c.allPanes, function (idx, pane) {
			if (options[pane].initChildLayout)
				createChildLayout( pane );
		});
	}

	/**
	* Initialize nested layouts for a specific pane - can optionally pass layout-options
	*
	* @see _initChildLayouts
	* @param {string|Object}	evt_or_pane	The pane being opened, ie: north, south, east, or west
	* @param {Object=}			[opts]		Layout-options - if passed, will OVERRRIDE options[pane].childOptions
	* @return  An object pointer to the layout instance created - or null
	*/
,	createChildLayout = function (evt_or_pane, opts) {
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		,	C	= children
		;
		if ($P) {
			var	$C	= $Cs[pane]
			,	o	= opts || options[pane].childOptions
			,	d	= "layout"
			//	determine which element is supposed to be the 'child container'
			//	if pane has a 'containerSelector' OR a 'content-div', use those instead of the pane
			,	$Cont = o.containerSelector ? $P.find( o.containerSelector ) : ($C || $P)
			,	containerFound = $Cont.length
			//	see if a child-layout ALREADY exists on this element
			,	child = containerFound ? (C[pane] = $Cont.data(d) || null) : null
			;
			// if no layout exists, but childOptions are set, try to create the layout now
			if (!child && containerFound && o)
				child = C[pane] = $Cont.eq(0).layout(o) || null;
			if (child)
				child.hasParentLayout = true;	// set parent-flag in child
		}
		Instance[pane].child = C[pane]; // ALWAYS set pane-object pointer, even if null
	}

,	windowResize = function () {
		var delay = Number(options.resizeWithWindowDelay);
		if (delay < 10) delay = 100; // MUST have a delay!
		// resizing uses a delay-loop because the resize event fires repeatly - except in FF, but delay anyway
		timer.clear("winResize"); // if already running
		timer.set("winResize", function(){
			timer.clear("winResize");
			timer.clear("winResizeRepeater");
			var dims = elDims( $N );
			// only trigger resizeAll() if container has changed size
			if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
				resizeAll();
		}, delay);
		// ALSO set fixed-delay timer, if not already running
		if (!timer.data["winResizeRepeater"]) setWindowResizeRepeater();
	}

,	setWindowResizeRepeater = function () {
		var delay = Number(options.resizeWithWindowMaxDelay);
		if (delay > 0)
			timer.set("winResizeRepeater", function(){ setWindowResizeRepeater(); resizeAll(); }, delay);
	}

,	unload = function () {
		var o = options;

		_runCallbacks("onunload_start");

		// trigger plugin callabacks for this layout (eg: stateManagement)
		runPluginCallbacks( Instance, $.layout.onUnload );

		_runCallbacks("onunload_end");
	}

	/**
	* Validate and initialize container CSS and events
	*
	* @see  _create()
	*/
,	_initContainer = function () {
		var
			N		= $N[0]
		,	tag		= sC.tagName = N.tagName
		,	id		= sC.id = N.id
		,	cls		= sC.className = N.className
		,	o		= options
		,	name	= o.name
		,	fullPage= (tag === "BODY")
		,	props	= "overflow,position,margin,padding,border"
		,	css		= "layoutCSS"
		,	CSS		= {}
		,	hid		= "hidden" // used A LOT!
		//	see if this container is a 'pane' inside an outer-layout
		,	parent	= $N.data("parentLayout")	// parent-layout Instance
		,	pane	= $N.data("layoutEdge")		// pane-name in parent-layout
		,	isChild	= parent && pane
		;
		// sC -> state.container
		sC.selector = $N.selector.split(".slice")[0];
		sC.ref		= (o.name ? o.name +' layout / ' : '') + tag + (id ? "#"+id : cls ? '.['+cls+']' : ''); // used in messages

		$N	.data({
				layout: Instance
			,	layoutContainer: sID // FLAG to indicate this is a layout-container - contains unique internal ID
			})
			.addClass(o.containerClass)
		;
		var layoutMethods = {
			destroy:	''
		,	initPanes:	''
		,	resizeAll:	'resizeAll'
		,	resize:		'resizeAll'
		};
		// loop hash and bind all methods - include layoutID namespacing
		for (name in layoutMethods) {
			$N.bind("layout"+ name.toLowerCase() +"."+ sID, Instance[ layoutMethods[name] || name ]);
		}

		// if this container is another layout's 'pane', then set child/parent pointers
		if (isChild) {
			// update parent flag
			Instance.hasParentLayout = true;
			// set pointers to THIS child-layout (Instance) in parent-layout
			// NOTE: parent.PANE.child is an ALIAS to parent.children.PANE
			parent[pane].child = parent.children[pane] = $N.data("layout");
		}

		// SAVE original container CSS for use in destroy()
		if (!$N.data(css)) {
			// handle props like overflow different for BODY & HTML - has 'system default' values
			if (fullPage) {
				CSS = $.extend( elCSS($N, props), {
					height:		$N.css("height")
				,	overflow:	$N.css("overflow")
				,	overflowX:	$N.css("overflowX")
				,	overflowY:	$N.css("overflowY")
				});
				// ALSO SAVE <HTML> CSS
				var $H = $("html");
				$H.data(css, {
					height:		"auto" // FF would return a fixed px-size!
				,	overflow:	$H.css("overflow")
				,	overflowX:	$H.css("overflowX")
				,	overflowY:	$H.css("overflowY")
				});
			}
			else // handle props normally for non-body elements
				CSS = elCSS($N, props+",top,bottom,left,right,width,height,overflow,overflowX,overflowY");

			$N.data(css, CSS);
		}

		try { // format html/body if this is a full page layout
			if (fullPage) {
				$("html").css({
					height:		"100%"
				,	overflow:	hid
				,	overflowX:	hid
				,	overflowY:	hid
				});
				$("body").css({
					position:	"relative"
				,	height:		"100%"
				,	overflow:	hid
				,	overflowX:	hid
				,	overflowY:	hid
				,	margin:		0
				,	padding:	0		// TODO: test whether body-padding could be handled?
				,	border:		"none"	// a body-border creates problems because it cannot be measured!
				});

				// set current layout-container dimensions
				$.extend(sC, elDims( $N ));
			}
			else { // set required CSS for overflow and position
				// ENSURE container will not 'scroll'
				CSS = { overflow: hid, overflowX: hid, overflowY: hid }
				var
					p = $N.css("position")
				,	h = $N.css("height")
				;
				// if this is a NESTED layout, then container/outer-pane ALREADY has position and height
				if (!isChild) {
					if (!p || !p.match(/fixed|absolute|relative/))
						CSS.position = "relative"; // container MUST have a 'position'
					/*
					if (!h || h=="auto")
						CSS.height = "100%"; // container MUST have a 'height'
					*/
				}
				$N.css( CSS );

				// set current layout-container dimensions
				if ( $N.is(":visible") ) {
					$.extend(sC, elDims( $N ));
					if (sC.innerHeight < 1)
						_log( o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref) );
				}
			}
		} catch (ex) {}
	}

	/**
	* Bind layout hotkeys - if options enabled
	*
	* @see  _create() and addPane()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initHotkeys = function (panes) {
		panes = panes ? panes.split(",") : _c.borderPanes;
		// bind keyDown to capture hotkeys, if option enabled for ANY pane
		$.each(panes, function (i, pane) {
			var o = options[pane];
			if (o.enableCursorHotkey || o.customHotkey) {
				$(document).bind("keydown."+ sID, keyDown); // only need to bind this ONCE
				return false; // BREAK - binding was done
			}
		});
	}

	/**
	* Build final OPTIONS data
	*
	* @see  _create()
	*/
,	initOptions = function () {
		var data, d, pane, key, val, i, c, o;

		// reprocess user's layout-options to have correct options sub-key structure
		opts = $.layout.transformData( opts ); // panes = default subkey

		// auto-rename old options for backward compatibility
		opts = $.layout.backwardCompatibility.renameAllOptions( opts );

		// if user-options has 'panes' key (pane-defaults), clean it...
		if (!$.isEmptyObject(opts.panes)) {
			// REMOVE any pane-defaults that MUST be set per-pane
			data = $.layout.optionsMap.noDefault;
			for (i=0, c=data.length; i<c; i++) {
				key = data[i];
				delete opts.panes[key]; // OK if does not exist
			}
			// REMOVE any layout-options specified under opts.panes
			data = $.layout.optionsMap.layout;
			for (i=0, c=data.length; i<c; i++) {
				key = data[i];
				delete opts.panes[key]; // OK if does not exist
			}
		}

		// MOVE any NON-layout-options from opts-root to opts.panes
		data = $.layout.optionsMap.layout;
		var rootKeys = $.layout.config.optionRootKeys;
		for (key in opts) {
			val = opts[key];
			if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
				if (!opts.panes[key])
					opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
				delete opts[key]
			}
		}

		// START by updating ALL options from opts
		$.extend(true, options, opts);

		// CREATE final options (and config) for EACH pane
		$.each(_c.allPanes, function (i, pane) {

			// apply 'pane-defaults' to CONFIG.[PANE]
			_c[pane] = $.extend(true, {}, _c.panes, _c[pane]);

			d = options.panes;
			o = options[pane];

			// center-pane uses SOME keys in defaults.panes branch
			if (pane === 'center') {
				// ONLY copy keys from opts.panes listed in: $.layout.optionsMap.center
				data = $.layout.optionsMap.center;		// list of 'center-pane keys'
				for (i=0, c=data.length; i<c; i++) {	// loop the list...
					key = data[i];
					// only need to use pane-default if pane-specific value not set
					if (!opts.center[key] && (opts.panes[key] || !o[key]))
						o[key] = d[key]; // pane-default
				}
			}
			else {
				// border-panes use ALL keys in defaults.panes branch
				o = options[pane] = $.extend(true, {}, d, o); // re-apply pane-specific opts AFTER pane-defaults
				createFxOptions( pane );
				// ensure all border-pane-specific base-classes exist
				if (!o.resizerClass)	o.resizerClass	= "ui-layout-resizer";
				if (!o.togglerClass)	o.togglerClass	= "ui-layout-toggler";
			}
			// ensure we have base pane-class (ALL panes)
			if (!o.paneClass) o.paneClass = "ui-layout-pane";
		});

		// update options.zIndexes if a zIndex-option specified
		var zo	= opts.zIndex
		,	z	= options.zIndexes;
		if (zo > 0) {
			z.pane_normal		= zo;
			z.content_mask		= max(zo+1, z.content_mask);	// MIN = +1
			z.resizer_normal	= max(zo+2, z.resizer_normal);	// MIN = +2
		}

		// DELETE 'panes' key now that we are done - values were copied to EACH pane
		delete options.panes;


		function createFxOptions ( pane ) {
			var	o = options[pane]
			,	d = options.panes;
			// ensure fxSettings key to avoid errors
			if (!o.fxSettings) o.fxSettings = {};
			if (!d.fxSettings) d.fxSettings = {};

			$.each(["_open","_close","_size"], function (i,n) { 
				var
					sName		= "fxName"+ n
				,	sSpeed		= "fxSpeed"+ n
				,	sSettings	= "fxSettings"+ n
					// recalculate fxName according to specificity rules
				,	fxName = o[sName] =
						o[sName]	// options.west.fxName_open
					||	d[sName]	// options.panes.fxName_open
					||	o.fxName	// options.west.fxName
					||	d.fxName	// options.panes.fxName
					||	"none"		// MEANS $.layout.defaults.panes.fxName == "" || false || null || 0
				;
				// validate fxName to ensure is valid effect - MUST have effect-config data in options.effects
				if (fxName === "none" || !$.effects || !$.effects[fxName] || !options.effects[fxName])
					fxName = o[sName] = "none"; // effect not loaded OR unrecognized fxName

				// set vars for effects subkeys to simplify logic
				var	fx		= options.effects[fxName] || {}	// effects.slide
				,	fx_all	= fx.all	|| null				// effects.slide.all
				,	fx_pane	= fx[pane]	|| null				// effects.slide.west
				;
				// create fxSpeed[_open|_close|_size]
				o[sSpeed] =
					o[sSpeed]				// options.west.fxSpeed_open
				||	d[sSpeed]				// options.west.fxSpeed_open
				||	o.fxSpeed				// options.west.fxSpeed
				||	d.fxSpeed				// options.panes.fxSpeed
				||	null					// DEFAULT - let fxSetting.duration control speed
				;
				// create fxSettings[_open|_close|_size]
				o[sSettings] = $.extend(
					true
				,	{}
				,	fx_all					// effects.slide.all
				,	fx_pane					// effects.slide.west
				,	d.fxSettings			// options.panes.fxSettings
				,	o.fxSettings			// options.west.fxSettings
				,	d[sSettings]			// options.panes.fxSettings_open
				,	o[sSettings]			// options.west.fxSettings_open
				);
			});

			// DONE creating action-specific-settings for this pane,
			// so DELETE generic options - are no longer meaningful
			delete o.fxName;
			delete o.fxSpeed;
			delete o.fxSettings;
		}
	}

	/**
	* Initialize module objects, styling, size and position for all panes
	*
	* @see  _initElements()
	* @param {string}	pane		The pane to process
	*/
,	getPane = function (pane) {
		var sel = options[pane].paneSelector
		if (sel.substr(0,1)==="#") // ID selector
			// NOTE: elements selected 'by ID' DO NOT have to be 'children'
			return $N.find(sel).eq(0);
		else { // class or other selector
			var $P = $N.children(sel).eq(0);
			// look for the pane nested inside a 'form' element
			return $P.length ? $P : $N.children("form:first").children(sel).eq(0);
		}
	}

,	initPanes = function (evt) {
		// stopPropagation if called by trigger("layoutinitpanes") - use evtPane utility 
		evtPane(evt);

		// NOTE: do north & south FIRST so we can measure their height - do center LAST
		$.each(_c.allPanes, function (idx, pane) {
			addPane( pane, true );
		});

		// init the pane-handles NOW in case we have to hide or close the pane below
		initHandles();

		// now that all panes have been initialized and initially-sized,
		// make sure there is really enough space available for each pane
		$.each(_c.borderPanes, function (i, pane) {
			if ($Ps[pane] && state[pane].isVisible) { // pane is OPEN
				setSizeLimits(pane);
				makePaneFit(pane); // pane may be Closed, Hidden or Resized by makePaneFit()
			}
		});
		// size center-pane AGAIN in case we 'closed' a border-pane in loop above
		sizeMidPanes("center");

		//	Chrome/Webkit sometimes fires callbacks BEFORE it completes resizing!
		//	Before RC30.3, there was a 10ms delay here, but that caused layout 
		//	to load asynchrously, which is BAD, so try skipping delay for now

		// process pane contents and callbacks, and init/resize child-layout if exists
		$.each(_c.allPanes, function (i, pane) {
			var o = options[pane];
			if ($Ps[pane]) {
				if (state[pane].isVisible) { // pane is OPEN
					sizeContent(pane);
					// trigger pane.onResize if triggerEventsOnLoad = true
					if (o.triggerEventsOnLoad)
						_runCallbacks("onresize_end", pane);
				else // automatic if onresize called, otherwise call it specifically
					// resize child - IF inner-layout already exists (created before this layout)
					resizeChildLayout(pane);
				}
				// init childLayout - even if pane is not visible
				if (o.initChildLayout && o.childOptions)
					createChildLayout(pane);
			}
		});
	}

	/**
	* Add a pane to the layout - subroutine of initPanes()
	*
	* @see  initPanes()
	* @param {string}	pane			The pane to process
	* @param {boolean=}	[force=false]	Size content after init
	*/
,	addPane = function (pane, force) {
		if (!force && !isInitialized()) return;
		var
			o		= options[pane]
		,	s		= state[pane]
		,	c		= _c[pane]
		,	fx		= s.fx
		,	dir		= c.dir
		,	spacing	= o.spacing_open || 0
		,	isCenter = (pane === "center")
		,	CSS		= {}
		,	$P		= $Ps[pane]
		,	size, minSize, maxSize
		;
		// if pane-pointer already exists, remove the old one first
		if ($P)
			removePane( pane, false, true, false );
		else
			$Cs[pane] = false; // init

		$P = $Ps[pane] = getPane(pane);
		if (!$P.length) {
			$Ps[pane] = false; // logic
			return;
		}

		// SAVE original Pane CSS
		if (!$P.data("layoutCSS")) {
			var props = "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";
			$P.data("layoutCSS", elCSS($P, props));
		}

		// create alias for pane data in Instance - initHandles will add more
		Instance[pane] = { name: pane, pane: $Ps[pane], content: $Cs[pane], options: options[pane], state: state[pane], child: children[pane] };

		// add classes, attributes & events
		$P	.data({
				parentLayout:	Instance		// pointer to Layout Instance
			,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
			,	layoutEdge:		pane
			,	layoutRole:		"pane"
			})
			.css(c.cssReq).css("zIndex", options.zIndexes.pane_normal)
			.css(o.applyDemoStyles ? c.cssDemo : {}) // demo styles
			.addClass( o.paneClass +" "+ o.paneClass+"-"+pane ) // default = "ui-layout-pane ui-layout-pane-west" - may be a dupe of 'paneSelector'
			.bind("mouseenter."+ sID, addHover )
			.bind("mouseleave."+ sID, removeHover )
			;
		var paneMethods = {
				hide:				''
			,	show:				''
			,	toggle:				''
			,	close:				''
			,	open:				''
			,	slideOpen:			''
			,	slideClose:			''
			,	slideToggle:		''
			,	size:				'sizePane'
			,	sizePane:			'sizePane'
			,	sizeContent:		''
			,	sizeHandles:		''
			,	enableClosable:		''
			,	disableClosable:	''
			,	enableSlideable:	''
			,	disableSlideable:	''
			,	enableResizable:	''
			,	disableResizable:	''
			,	swapPanes:			'swapPanes'
			,	swap:				'swapPanes'
			,	move:				'swapPanes'
			,	removePane:			'removePane'
			,	remove:				'removePane'
			,	createChildLayout:	''
			,	resizeChildLayout:	''
			,	resizeAll:			'resizeAll'
			,	resizeLayout:		'resizeAll'
			}
		,	name;
		// loop hash and bind all methods - include layoutID namespacing
		for (name in paneMethods) {
			$P.bind("layoutpane"+ name.toLowerCase() +"."+ sID, Instance[ paneMethods[name] || name ]);
		}

		// see if this pane has a 'scrolling-content element'
		initContent(pane, false); // false = do NOT sizeContent() - called later

		if (!isCenter) {
			// call _parseSize AFTER applying pane classes & styles - but before making visible (if hidden)
			// if o.size is auto or not valid, then MEASURE the pane and use that as its 'size'
			size	= s.size = _parseSize(pane, o.size);
			minSize	= _parseSize(pane,o.minSize) || 1;
			maxSize	= _parseSize(pane,o.maxSize) || 100000;
			if (size > 0) size = max(min(size, maxSize), minSize);

			// state for border-panes
			s.isClosed  = false; // true = pane is closed
			s.isSliding = false; // true = pane is currently open by 'sliding' over adjacent panes
			s.isResizing= false; // true = pane is in process of being resized
			s.isHidden	= false; // true = pane is hidden - no spacing, resizer or toggler is visible!

			// array for 'pin buttons' whose classNames are auto-updated on pane-open/-close
			if (!s.pins) s.pins = [];
		}
		//	states common to ALL panes
		s.tagName	= $P[0].tagName;
		s.edge		= pane;		// useful if pane is (or about to be) 'swapped' - easy find out where it is (or is going)
		s.noRoom	= false;	// true = pane 'automatically' hidden due to insufficient room - will unhide automatically
		s.isVisible	= true;		// false = pane is invisible - closed OR hidden - simplify logic

		// set css-position to account for container borders & padding
		switch (pane) {
			case "north": 	CSS.top 	= sC.insetTop;
							CSS.left 	= sC.insetLeft;
							CSS.right	= sC.insetRight;
							break;
			case "south": 	CSS.bottom	= sC.insetBottom;
							CSS.left 	= sC.insetLeft;
							CSS.right 	= sC.insetRight;
							break;
			case "west": 	CSS.left 	= sC.insetLeft; // top, bottom & height set by sizeMidPanes()
							break;
			case "east": 	CSS.right 	= sC.insetRight; // ditto
							break;
			case "center":	// top, left, width & height set by sizeMidPanes()
		}

		if (dir === "horz") // north or south pane
			CSS.height = cssH($P, size);
		else if (dir === "vert") // east or west pane
			CSS.width = cssW($P, size);
		//else if (isCenter) {}

		$P.css(CSS); // apply size -- top, bottom & height will be set by sizeMidPanes
		if (dir != "horz") sizeMidPanes(pane, true); // true = skipCallback

		// close or hide the pane if specified in settings
		if (o.initClosed && o.closable && !o.initHidden)
			close(pane, true, true); // true, true = force, noAnimation
		else if (o.initHidden || o.initClosed)
			hide(pane); // will be completely invisible - no resizer or spacing
		else if (!s.noRoom)
			// make the pane visible - in case was initially hidden
			$P.css("display","block");
		// ELSE setAsOpen() - called later by initHandles()

		// RESET visibility now - pane will appear IF display:block
		$P.css("visibility","visible");

		// check option for auto-handling of pop-ups & drop-downs
		if (o.showOverflowOnHover)
			$P.hover( allowOverflow, resetOverflow );

		// if manually adding a pane AFTER layout initialization, then...
		if (state.initialized) {
			initHandles( pane );
			initHotkeys( pane );
			resizeAll(); // will sizeContent if pane is visible
			if (s.isVisible) { // pane is OPEN
				if (o.triggerEventsOnLoad)
					_runCallbacks("onresize_end", pane);
				else // automatic if onresize called, otherwise call it specifically
					// resize child - IF inner-layout already exists (created before this layout)
					resizeChildLayout(pane); // a previously existing childLayout
			}
			if (o.initChildLayout && o.childOptions)
				createChildLayout(pane);
		}
	}

	/**
	* Initialize module objects, styling, size and position for all resize bars and toggler buttons
	*
	* @see  _create()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initHandles = function (panes) {
		panes = panes ? panes.split(",") : _c.borderPanes;

		// create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
		$.each(panes, function (i, pane) {
			var $P		= $Ps[pane];
			$Rs[pane]	= false; // INIT
			$Ts[pane]	= false;
			if (!$P) return; // pane does not exist - skip

			var 
				o		= options[pane]
			,	s		= state[pane]
			,	c		= _c[pane]
			,	paneId	= o.paneSelector.substr(0,1) === "#" ? o.paneSelector.substr(1) : ""
			,	rClass	= o.resizerClass
			,	tClass	= o.togglerClass
			,	side	= c.side.toLowerCase()
			,	spacing	= (s.isVisible ? o.spacing_open : o.spacing_closed)
			,	_pane	= "-"+ pane // used for classNames
			,	_state	= (s.isVisible ? "-open" : "-closed") // used for classNames
			,	I		= Instance[pane]
				// INIT RESIZER BAR
			,	$R		= I.resizer = $Rs[pane] = $("<div></div>")
				// INIT TOGGLER BUTTON
			,	$T		= I.toggler = (o.closable ? $Ts[pane] = $("<div></div>") : false)
			;

			//if (s.isVisible && o.resizable) ... handled by initResizable
			if (!s.isVisible && o.slidable)
				$R.attr("title", o.tips.Slide).css("cursor", o.sliderCursor);

			$R	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "paneLeft-resizer"
				.attr("id", paneId ? paneId +"-resizer" : "" )
				.data({
					parentLayout:	Instance
				,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
				,	layoutEdge:		pane
				,	layoutRole:		"resizer"
				})
				.css(_c.resizers.cssReq).css("zIndex", options.zIndexes.resizer_normal)
				.css(o.applyDemoStyles ? _c.resizers.cssDemo : {}) // add demo styles
				.addClass(rClass +" "+ rClass+_pane)
				.hover(addHover, removeHover) // ALWAYS add hover-classes, even if resizing is not enabled - handle with CSS instead
				.hover(onResizerEnter, onResizerLeave) // ALWAYS NEED resizer.mouseleave to balance toggler.mouseenter
				.appendTo($N) // append DIV to container
			;

			if ($T) {
				$T	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "#paneLeft-toggler"
					.attr("id", paneId ? paneId +"-toggler" : "" )
					.data({
						parentLayout:	Instance
					,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
					,	layoutEdge:		pane
					,	layoutRole:		"toggler"
					})
					.css(_c.togglers.cssReq) // add base/required styles
					.css(o.applyDemoStyles ? _c.togglers.cssDemo : {}) // add demo styles
					.addClass(tClass +" "+ tClass+_pane)
					.hover(addHover, removeHover) // ALWAYS add hover-classes, even if toggling is not enabled - handle with CSS instead
					.bind("mouseenter", onResizerEnter) // NEED toggler.mouseenter because mouseenter MAY NOT fire on resizer
					.appendTo($R) // append SPAN to resizer DIV
				;
				// ADD INNER-SPANS TO TOGGLER
				if (o.togglerContent_open) // ui-layout-open
					$("<span>"+ o.togglerContent_open +"</span>")
						.data({
							layoutEdge:		pane
						,	layoutRole:		"togglerContent"
						})
						.data("layoutRole", "togglerContent")
						.data("layoutEdge", pane)
						.addClass("content content-open")
						.css("display","none")
						.appendTo( $T )
						//.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-open instead!
					;
				if (o.togglerContent_closed) // ui-layout-closed
					$("<span>"+ o.togglerContent_closed +"</span>")
						.data({
							layoutEdge:		pane
						,	layoutRole:		"togglerContent"
						})
						.addClass("content content-closed")
						.css("display","none")
						.appendTo( $T )
						//.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-closed instead!
					;
				// ADD TOGGLER.click/.hover
				enableClosable(pane);
			}

			// add Draggable events
			initResizable(pane);

			// ADD CLASSNAMES & SLIDE-BINDINGS - eg: class="resizer resizer-west resizer-open"
			if (s.isVisible)
				setAsOpen(pane);	// onOpen will be called, but NOT onResize
			else {
				setAsClosed(pane);	// onClose will be called
				bindStartSlidingEvent(pane, true); // will enable events IF option is set
			}

		});

		// SET ALL HANDLE DIMENSIONS
		sizeHandles();
	}


	/**
	* Initialize scrolling ui-layout-content div - if exists
	*
	* @see  initPane() - or externally after an Ajax injection
	* @param {string}	[pane]			The pane to process
	* @param {boolean=}	[resize=true]	Size content after init
	*/
,	initContent = function (pane, resize) {
		if (!isInitialized()) return;
		var 
			o	= options[pane]
		,	sel	= o.contentSelector
		,	I	= Instance[pane]
		,	$P	= $Ps[pane]
		,	$C
		;
		if (sel) $C = I.content = $Cs[pane] = (o.findNestedContent)
			? $P.find(sel).eq(0) // match 1-element only
			: $P.children(sel).eq(0)
		;
		if ($C && $C.length) {
			$C.data("layoutRole", "content");
			// SAVE original Pane CSS
			if (!$C.data("layoutCSS"))
				$C.data("layoutCSS", elCSS($C, "height"));
			$C.css( _c.content.cssReq );
			if (o.applyDemoStyles) {
				$C.css( _c.content.cssDemo ); // add padding & overflow: auto to content-div
				$P.css( _c.content.cssDemoPane ); // REMOVE padding/scrolling from pane
			}
			state[pane].content = {}; // init content state
			if (resize !== false) sizeContent(pane);
			// sizeContent() is called AFTER init of all elements
		}
		else
			I.content = $Cs[pane] = false;
	}


	/**
	* Add resize-bars to all panes that specify it in options
	* -dependancy: $.fn.resizable - will skip if not found
	*
	* @see  _create()
	* @param {string=}	[panes=""]	The edge(s) to process
	*/
,	initResizable = function (panes) {
		var	draggingAvailable = $.layout.plugins.draggable
		,	side // set in start()
		;
		panes = panes ? panes.split(",") : _c.borderPanes;

		$.each(panes, function (idx, pane) {
			var o = options[pane];
			if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
				o.resizable = false;
				return true; // skip to next
			}

			var s		= state[pane]
			,	z		= options.zIndexes
			,	c		= _c[pane]
			,	side	= c.dir=="horz" ? "top" : "left"
			,	opEdge	= _c.oppositeEdge[pane]
			,	masks	=  pane +",center,"+ opEdge + (c.dir=="horz" ? ",west,east" : "")
			,	$P 		= $Ps[pane]
			,	$R		= $Rs[pane]
			,	base	= o.resizerClass
			,	lastPos	= 0 // used when live-resizing
			,	r, live // set in start because may change
			//	'drag' classes are applied to the ORIGINAL resizer-bar while dragging is in process
			,	resizerClass		= base+"-drag"				// resizer-drag
			,	resizerPaneClass	= base+"-"+pane+"-drag"		// resizer-north-drag
			//	'helper' class is applied to the CLONED resizer-bar while it is being dragged
			,	helperClass			= base+"-dragging"			// resizer-dragging
			,	helperPaneClass		= base+"-"+pane+"-dragging" // resizer-north-dragging
			,	helperLimitClass	= base+"-dragging-limit"	// resizer-drag
			,	helperPaneLimitClass = base+"-"+pane+"-dragging-limit"	// resizer-north-drag
			,	helperClassesSet	= false 					// logic var
			;

			if (!s.isClosed)
				$R.attr("title", o.tips.Resize)
				  .css("cursor", o.resizerCursor); // n-resize, s-resize, etc

			$R.draggable({
				containment:	$N[0] // limit resizing to layout container
			,	axis:			(c.dir=="horz" ? "y" : "x") // limit resizing to horz or vert axis
			,	delay:			0
			,	distance:		1
			,	grid:			o.resizingGrid
			//	basic format for helper - style it using class: .ui-draggable-dragging
			,	helper:			"clone"
			,	opacity:		o.resizerDragOpacity
			,	addClasses:		false // avoid ui-state-disabled class when disabled
			//,	iframeFix:		o.draggableIframeFix // TODO: consider using when bug is fixed
			,	zIndex:			z.resizer_drag

			,	start: function (e, ui) {
					// REFRESH options & state pointers in case we used swapPanes
					o = options[pane];
					s = state[pane];
					// re-read options
					live = o.livePaneResizing;

					// ondrag_start callback - will CANCEL hide if returns false
					// TODO: dragging CANNOT be cancelled like this, so see if there is a way?
					if (false === _runCallbacks("ondrag_start", pane)) return false;

					s.isResizing	= true; // prevent pane from closing while resizing
					timer.clear(pane+"_closeSlider"); // just in case already triggered

					// SET RESIZER LIMITS - used in drag()
					setSizeLimits(pane); // update pane/resizer state
					r = s.resizerPosition;
					lastPos = ui.position[ side ]

					$R.addClass( resizerClass +" "+ resizerPaneClass ); // add drag classes
					helperClassesSet = false; // reset logic var - see drag()

					// DISABLE TEXT SELECTION (probably already done by resizer.mouseOver)
					$('body').disableSelection(); 

					// MASK PANES CONTAINING IFRAMES, APPLETS OR OTHER TROUBLESOME ELEMENTS
					showMasks( masks );
				}

			,	drag: function (e, ui) {
					if (!helperClassesSet) { // can only add classes after clone has been added to the DOM
						//$(".ui-draggable-dragging")
						ui.helper
							.addClass( helperClass +" "+ helperPaneClass ) // add helper classes
							.css({ right: "auto", bottom: "auto" })	// fix dir="rtl" issue
							.children().css("visibility","hidden")	// hide toggler inside dragged resizer-bar
						;
						helperClassesSet = true;
						// draggable bug!? RE-SET zIndex to prevent E/W resize-bar showing through N/S pane!
						if (s.isSliding) $Ps[pane].css("zIndex", z.pane_sliding);
					}
					// CONTAIN RESIZER-BAR TO RESIZING LIMITS
					var limit = 0;
					if (ui.position[side] < r.min) {
						ui.position[side] = r.min;
						limit = -1;
					}
					else if (ui.position[side] > r.max) {
						ui.position[side] = r.max;
						limit = 1;
					}
					// ADD/REMOVE dragging-limit CLASS
					if (limit) {
						ui.helper.addClass( helperLimitClass +" "+ helperPaneLimitClass ); // at dragging-limit
						window.defaultStatus = (limit>0 && pane.match(/(north|west)/)) || (limit<0 && pane.match(/(south|east)/)) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
					}
					else {
						ui.helper.removeClass( helperLimitClass +" "+ helperPaneLimitClass ); // not at dragging-limit
						window.defaultStatus = "";
					}
					// DYNAMICALLY RESIZE PANES IF OPTION ENABLED
					// won't trigger unless resizer has actually moved!
					if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
						lastPos = ui.position[side];
						resizePanes(e, ui, pane)
					}
				}

			,	stop: function (e, ui) {
					$('body').enableSelection(); // RE-ENABLE TEXT SELECTION
					window.defaultStatus = ""; // clear 'resizing limit' message from statusbar
					$R.removeClass( resizerClass +" "+ resizerPaneClass ); // remove drag classes from Resizer
					s.isResizing = false;
					resizePanes(e, ui, pane, true, masks); // true = resizingDone
				}

			});
		});

		/**
		* resizePanes
		*
		* Sub-routine called from stop() - and drag() if livePaneResizing
		*
		* @param {!Object}		evt
		* @param {!Object}		ui
		* @param {string}		pane
		* @param {boolean=}		[resizingDone=false]
		*/
		var resizePanes = function (evt, ui, pane, resizingDone, masks) {
			var	dragPos	= ui.position
			,	c		= _c[pane]
			,	o		= options[pane]
			,	s		= state[pane]
			,	resizerPos
			;
			switch (pane) {
				case "north":	resizerPos = dragPos.top; break;
				case "west":	resizerPos = dragPos.left; break;
				case "south":	resizerPos = sC.offsetHeight - dragPos.top  - o.spacing_open; break;
				case "east":	resizerPos = sC.offsetWidth  - dragPos.left - o.spacing_open; break;
			};
			// remove container margin from resizer position to get the pane size
			var newSize = resizerPos - sC["inset"+ c.side];

			// Disable OR Resize Mask(s) created in drag.start
			if (!resizingDone) {
				// ensure we meet liveResizingTolerance criteria
				if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
					return; // SKIP resize this time
				// resize the pane
				manualSizePane(pane, newSize, false, true); // true = noAnimation
				sizeMasks(); // resize all visible masks
			}
			else { // resizingDone
				// ondrag_end callback
				if (false !== _runCallbacks("ondrag_end", pane))
					manualSizePane(pane, newSize, false, true); // true = noAnimation
				hideMasks(); // hide all masks, which include panes with 'content/iframe-masks'
				if (s.isSliding && masks) // RE-SHOW only 'object-masks' so objects won't show through sliding pane
					showMasks( masks, true ); // true = onlyForObjects
			}
		};
	}

	/**
	 *	sizeMask
	 *
	 *	Needed to overlay a DIV over an IFRAME-pane because mask CANNOT be *inside* the pane
	 *	Called when mask created, and during livePaneResizing
	 */
,	sizeMask = function () {
		var $M		= $(this)
		,	pane	= $M.data("layoutMask") // eg: "west"
		,	s		= state[pane]
		;
		// only masks over an IFRAME-pane need manual resizing
		if (s.tagName == "IFRAME" && s.isVisible) // no need to mask closed/hidden panes
			$M.css({
				top:	s.offsetTop
			,	left:	s.offsetLeft
			,	width:	s.outerWidth
			,	height:	s.outerHeight
			});
		/* ALT Method...
		var $P = $Ps[pane];
		$M.css( $P.position() ).css({ width: $P[0].offsetWidth, height: $P[0].offsetHeight });
		*/
	}
,	sizeMasks = function () {
		$Ms.each( sizeMask ); // resize all 'visible' masks
	}

,	showMasks = function (panes, onlyForObjects) {
		var a	= panes ? panes.split(",") : $.layout.config.allPanes
		,	z	= options.zIndexes
		,	o, s;
		$.each(a, function(i,p){
			s = state[p];
			o = options[p];
			if (s.isVisible && ( (!onlyForObjects && o.maskContents) || o.maskObjects )) {
				getMasks(p).each(function(){
					sizeMask.call(this);
					this.style.zIndex = s.isSliding ? z.pane_sliding+1 : z.pane_normal+1
					this.style.display = "block";
				});
			}
		});
	}

,	hideMasks = function () {
		// ensure no pane is resizing - could be a timing issue
		var skip;
		$.each( $.layout.config.borderPanes, function(i,p){
			if (state[p].isResizing) {
				skip = true;
				return false; // BREAK
			}
		});
		if (!skip)
			$Ms.hide(); // hide ALL masks
	}

,	getMasks = function (pane) {
		var $Masks	= $([])
		,	$M, i = 0, c = $Ms.length
		;
		for (; i<c; i++) {
			$M = $Ms.eq(i);
			if ($M.data("layoutMask") === pane)
				$Masks = $Masks.add( $M );
		}
		if ($Masks.length)
			return $Masks;
		else
			return createMasks(pane);
	}

	/**
	 *	createMasks
	 *
	 *	Generates both DIV (ALWAYS used) and IFRAME (optional) elements as masks
	 *	An IFRAME mask is created *under* the DIV when maskObjects=true, because a DIV cannot mask an applet
	 */
,	createMasks = function (pane) {
		var
			$P		= $Ps[pane]
		,	s		= state[pane]
		,	o		= options[pane]
		,	z		= options.zIndexes
		//,	objMask	= o.maskObjects && s.tagName != "IFRAME" // check for option
		,	$Masks	= $([])
		,	isIframe, el, $M, css, i
		;
		if (!o.maskContents && !o.maskObjects) return $Masks;
		// if o.maskObjects=true, then loop TWICE to create BOTH kinds of mask, else only create a DIV
		for (i=0; i < (o.maskObjects ? 2 : 1); i++) {
			isIframe = o.maskObjects && i==0;
			el = document.createElement( isIframe ? "iframe" : "div" );
			$M = $(el).data("layoutMask", pane); // add data to relate mask to pane
			el.className = "ui-layout-mask ui-layout-mask-"+ pane; // for user styling
			css = el.style;
			// styles common to both DIVs and IFRAMES
			css.display		= "block";
			css.position	= "absolute";
			if (isIframe) { // IFRAME-only props
				el.frameborder = 0;
				el.src		= "about:blank";
				css.opacity	= 0;
				css.filter	= "Alpha(Opacity='0')";
				css.border	= 0;
			}
			// if pane is an IFRAME, then must mask the pane itself
			if (s.tagName == "IFRAME") {
				// NOTE sizing done by a subroutine so can be called during live-resizing
				css.zIndex	= z.pane_normal+1; // 1-higher than pane
				$N.append( el ); // append to LAYOUT CONTAINER
			}
			// otherwise put masks *inside the pane* to mask its contents
			else {
				$M.addClass("ui-layout-mask-inside-pane");
				css.zIndex	= o.maskZindex || z.content_mask; // usually 1, but customizable
				css.top		= 0;
				css.left	= 0;
				css.width	= "100%";
				css.height	= "100%";
				$P.append( el ); // append INSIDE pane element
			}
			// add to return object
			$Masks = $Masks.add( el );
			// add Mask to cached array so can be resized & reused
			$Ms = $Ms.add( el );
		}
		return $Masks;
	}


	/**
	* Destroy this layout and reset all elements
	*
	* @param {boolean=}	[destroyChildren=false]		Destory Child-Layouts first?
	*/
,	destroy = function (evt_or_destroyChildren, destroyChildren) {
		// UNBIND layout events and remove global object
		$(window).unbind("."+ sID);		// resize & unload
		$(document).unbind("."+ sID);	// keyDown (hotkeys)

		if (typeof evt_or_destroyChildren === "object")
			// stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
			evtPane(evt_or_destroyChildren);
		else // no event, so transfer 1st param to destroyChildren param
			destroyChildren = evt_or_destroyChildren;

		// need to look for parent layout BEFORE we remove the container data, else skips a level
		//var parentPane = Instance.hasParentLayout ? $.layout.getParentPaneInstance( $N ) : null;

		// reset layout-container
		$N	.clearQueue()
			.removeData("layout")
			.removeData("layoutContainer")
			.removeClass(options.containerClass)
			.unbind("."+ sID) // remove ALL Layout events
		;

		// remove all mask elements that have been created
		$Ms.remove();

		// loop all panes to remove layout classes, attributes and bindings
		$.each(_c.allPanes, function (i, pane) {
			removePane( pane, false, true, destroyChildren ); // true = skipResize
		});

		// do NOT reset container CSS if is a 'pane' (or 'content') in an outer-layout - ie, THIS layout is 'nested'
		var css = "layoutCSS";
		if ($N.data(css) && !$N.data("layoutRole")) // RESET CSS
			$N.css( $N.data(css) ).removeData(css);

		// for full-page layouts, also reset the <HTML> CSS
		if (sC.tagName === "BODY" && ($N = $("html")).data(css)) // RESET <HTML> CSS
			$N.css( $N.data(css) ).removeData(css);

		// trigger plugins for this layout, if there are any
		runPluginCallbacks( Instance, $.layout.onDestroy );

		// trigger state-management and onunload callback
		unload();

		// clear the Instance of everything except for container & options (so could recreate)
		// RE-CREATE: myLayout = myLayout.container.layout( myLayout.options );
		for (n in Instance)
			if (!n.match(/^(container|options)$/)) delete Instance[ n ];
		// add a 'destroyed' flag to make it easy to check
		Instance.destroyed = true;

		// if this is a child layout, CLEAR the child-pointer in the parent
		/* for now the pointer REMAINS, but with only container, options and destroyed keys
		if (parentPane) {
			var layout = parentPane.pane.data("parentLayout");
			parentPane.child = layout.children[ parentPane.name ] = null;
		}
		*/

		return Instance; // for coding convenience
	}

	/**
	* Remove a pane from the layout - subroutine of destroy()
	*
	* @see  destroy()
	* @param {string|Object}	evt_or_pane			The pane to process
	* @param {boolean=}			[remove=false]		Remove the DOM element?
	* @param {boolean=}			[skipResize=false]	Skip calling resizeAll()?
	* @param {boolean=}			[destroyChild=true]	Destroy Child-layouts? If not passed, obeys options setting
	*/
,	removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		,	$C	= $Cs[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		;
		// NOTE: elements can still exist even after remove()
		//		so check for missing data(), which is cleared by removed()
		if ($P && $.isEmptyObject( $P.data() )) $P = false;
		if ($C && $.isEmptyObject( $C.data() )) $C = false;
		if ($R && $.isEmptyObject( $R.data() )) $R = false;
		if ($T && $.isEmptyObject( $T.data() )) $T = false;

		if ($P) $P.stop(true, true);

		//	check for a child layout
		var	o	= options[pane]
		,	s	= state[pane]
		,	d	= "layout"
		,	css	= "layoutCSS"
		,	child	= children[pane] || ($P ? $P.data(d) : 0) || ($C ? $C.data(d) : 0) || null
		,	destroy	= destroyChild !== undefined ? destroyChild : o.destroyChildLayout
		;

		// FIRST destroy the child-layout(s)
		if (destroy && child && !child.destroyed) {
			child.destroy(true);	// tell child-layout to destroy ALL its child-layouts too
			if (child.destroyed)	// destroy was successful
				child = null;		// clear pointer for logic below 
		}

		if ($P && remove && !child)
			$P.remove();
		else if ($P && $P[0]) {
			//	create list of ALL pane-classes that need to be removed
			var	root	= o.paneClass // default="ui-layout-pane"
			,	pRoot	= root +"-"+ pane // eg: "ui-layout-pane-west"
			,	_open	= "-open"
			,	_sliding= "-sliding"
			,	_closed	= "-closed"
			,	classes	= [	root, root+_open, root+_closed, root+_sliding,		// generic classes
							pRoot, pRoot+_open, pRoot+_closed, pRoot+_sliding ]	// pane-specific classes
			;
			$.merge(classes, getHoverClasses($P, true)); // ADD hover-classes
			// remove all Layout classes from pane-element
			$P	.removeClass( classes.join(" ") ) // remove ALL pane-classes
				.removeData("parentLayout")
				.removeData("layoutPane")
				.removeData("layoutRole")
				.removeData("layoutEdge")
				.removeData("autoHidden")	// in case set
				.unbind("."+ sID) // remove ALL Layout events
				// TODO: remove these extra unbind commands when jQuery is fixed
				//.unbind("mouseenter"+ sID)
				//.unbind("mouseleave"+ sID)
			;
			// do NOT reset CSS if this pane/content is STILL the container of a nested layout!
			// the nested layout will reset its 'container' CSS when/if it is destroyed
			if ($C && $C.data(d)) {
				// a content-div may not have a specific width, so give it one to contain the Layout
				$C.width( $C.width() );
				child.resizeAll(); // now resize the Layout
			}
			else if ($C)
				$C.css( $C.data(css) ).removeData(css).removeData("layoutRole");
			// remove pane AFTER content in case there was a nested layout
			if (!$P.data(d))
				$P.css( $P.data(css) ).removeData(css);
		}

		// REMOVE pane resizer and toggler elements
		if ($T) $T.remove();
		if ($R) $R.remove();

		// CLEAR all pointers and state data
		Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = children[pane] = false;
		s = { removed: true };

		if (!skipResize)
			resizeAll();
	}


/*
 * ###########################
 *	   ACTION METHODS
 * ###########################
 */

,	_hidePane = function (pane) {
		var $P	= $Ps[pane]
		,	o	= options[pane]
		,	s	= $P[0].style
		;
		if (o.useOffscreenClose) {
			if (!$P.data(_c.offscreenReset))
				$P.data(_c.offscreenReset, { left: s.left, right: s.right });
			$P.css( _c.offscreenCSS );
		}
		else
			$P.hide().removeData(_c.offscreenReset);
	}

,	_showPane = function (pane) {
		var $P	= $Ps[pane]
		,	o	= options[pane]
		,	off	= _c.offscreenCSS
		,	old	= $P.data(_c.offscreenReset)
		,	s	= $P[0].style
		;
		$P	.show() // ALWAYS show, just in case
			.removeData(_c.offscreenReset);
		if (o.useOffscreenClose && old) {
			if (s.left == off.left)
				s.left = old.left;
			if (s.right == off.right)
				s.right = old.right;
		}
	}


	/**
	* Completely 'hides' a pane, including its spacing - as if it does not exist
	* The pane is not actually 'removed' from the source, so can use 'show' to un-hide it
	*
	* @param {string|Object}	evt_or_pane			The pane being hidden, ie: north, south, east, or west
	* @param {boolean=}			[noAnimation=false]	
	*/
,	hide = function (evt_or_pane, noAnimation) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		;
		if (!$P || s.isHidden) return; // pane does not exist OR is already hidden

		// onhide_start callback - will CANCEL hide if returns false
		if (state.initialized && false === _runCallbacks("onhide_start", pane)) return;

		s.isSliding = false; // just in case

		// now hide the elements
		if ($R) $R.hide(); // hide resizer-bar
		if (!state.initialized || s.isClosed) {
			s.isClosed = true; // to trigger open-animation on show()
			s.isHidden  = true;
			s.isVisible = false;
			if (!state.initialized)
				_hidePane(pane); // no animation when loading page
			sizeMidPanes(_c[pane].dir === "horz" ? "" : "center");
			if (state.initialized || o.triggerEventsOnLoad)
				_runCallbacks("onhide_end", pane);
		}
		else {
			s.isHiding = true; // used by onclose
			close(pane, false, noAnimation); // adjust all panes to fit
		}
	}

	/**
	* Show a hidden pane - show as 'closed' by default unless openPane = true
	*
	* @param {string|Object}	evt_or_pane			The pane being opened, ie: north, south, east, or west
	* @param {boolean=}			[openPane=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[noAlert=false]
	*/
,	show = function (evt_or_pane, openPane, noAnimation, noAlert) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		;
		if (!$P || !s.isHidden) return; // pane does not exist OR is not hidden

		// onshow_start callback - will CANCEL show if returns false
		if (false === _runCallbacks("onshow_start", pane)) return;

		s.isSliding = false; // just in case
		s.isShowing = true; // used by onopen/onclose
		//s.isHidden  = false; - will be set by open/close - if not cancelled

		// now show the elements
		//if ($R) $R.show(); - will be shown by open/close
		if (openPane === false)
			close(pane, true); // true = force
		else
			open(pane, false, noAnimation, noAlert); // adjust all panes to fit
	}


	/**
	* Toggles a pane open/closed by calling either open or close
	*
	* @param {string|Object}	evt_or_pane		The pane being toggled, ie: north, south, east, or west
	* @param {boolean=}			[slide=false]
	*/
,	toggle = function (evt_or_pane, slide) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	s		= state[pane]
		;
		if (evt) // called from to $R.dblclick OR triggerPaneEvent
			evt.stopImmediatePropagation();
		if (s.isHidden)
			show(pane); // will call 'open' after unhiding it
		else if (s.isClosed)
			open(pane, !!slide);
		else
			close(pane);
	}


	/**
	* Utility method used during init or other auto-processes
	*
	* @param {string}	pane   The pane being closed
	* @param {boolean=}	[setHandles=false]
	*/
,	_closePane = function (pane, setHandles) {
		var
			$P	= $Ps[pane]
		,	s	= state[pane]
		;
		_hidePane(pane);
		s.isClosed = true;
		s.isVisible = false;
		// UNUSED: if (setHandles) setAsClosed(pane, true); // true = force
	}

	/**
	* Close the specified pane (animation optional), and resize all other panes as needed
	*
	* @param {string|Object}	evt_or_pane			The pane being closed, ie: north, south, east, or west
	* @param {boolean=}			[force=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[skipCallback=false]
	*/
,	close = function (evt_or_pane, force, noAnimation, skipCallback) {
		var	pane = evtPane.call(this, evt_or_pane);
		// if pane has been initialized, but NOT the complete layout, close pane instantly
		if (!state.initialized && $Ps[pane]) {
			_closePane(pane); // INIT pane as closed
			return;
		}
		if (!isInitialized()) return;

		var
			$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	doFX, isShowing, isHiding, wasSliding;

		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){
	
			if ( !$P
			||	(!o.closable && !s.isShowing && !s.isHiding)	// invalid request // (!o.resizable && !o.closable) ???
			||	(!force && s.isClosed && !s.isShowing)			// already closed
			) return queueNext();

			// onclose_start callback - will CANCEL hide if returns false
			// SKIP if just 'showing' a hidden pane as 'closed'
			var abort = !s.isShowing && false === _runCallbacks("onclose_start", pane);

			// transfer logic vars to temp vars
			isShowing	= s.isShowing;
			isHiding	= s.isHiding;
			wasSliding	= s.isSliding;
			// now clear the logic vars (REQUIRED before aborting)
			delete s.isShowing;
			delete s.isHiding;

			if (abort) return queueNext();

			doFX		= !noAnimation && !s.isClosed && (o.fxName_close != "none");
			s.isMoving	= true;
			s.isClosed	= true;
			s.isVisible	= false;
			// update isHidden BEFORE sizing panes
			if (isHiding) s.isHidden = true;
			else if (isShowing) s.isHidden = false;

			if (s.isSliding) // pane is being closed, so UNBIND trigger events
				bindStopSlidingEvents(pane, false); // will set isSliding=false
			else // resize panes adjacent to this one
				sizeMidPanes(_c[pane].dir === "horz" ? "" : "center", false); // false = NOT skipCallback

			// if this pane has a resizer bar, move it NOW - before animation
			setAsClosed(pane);

			// CLOSE THE PANE
			if (doFX) { // animate the close
				// mask panes with objects
				var masks = "center"+ (c.dir=="horz" ? ",west,east" : "");
				showMasks( masks, true );	// true = ONLY mask panes with maskObjects=true
				lockPaneForFX(pane, true);	// need to set left/top so animation will work
				$P.hide( o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
					lockPaneForFX(pane, false); // undo
					if (s.isClosed) close_2();
					queueNext();
				});
			}
			else { // hide the pane without animation
				_hidePane(pane);
				close_2();
				queueNext();
			};
		});

		// SUBROUTINE
		function close_2 () {
			s.isMoving	= false;
			bindStartSlidingEvent(pane, true); // will enable if o.slidable = true

			// if opposite-pane was autoClosed, see if it can be autoOpened now
			var altPane = _c.oppositeEdge[pane];
			if (state[ altPane ].noRoom) {
				setSizeLimits( altPane );
				makePaneFit( altPane );
			}

			// hide any masks shown while closing
			hideMasks();

			if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
				// onclose callback - UNLESS just 'showing' a hidden pane as 'closed'
				if (!isShowing)	_runCallbacks("onclose_end", pane);
				// onhide OR onshow callback
				if (isShowing)	_runCallbacks("onshow_end", pane);
				if (isHiding)	_runCallbacks("onhide_end", pane);
			}
		}
	}

	/**
	* @param {string}	pane	The pane just closed, ie: north, south, east, or west
	*/
,	setAsClosed = function (pane) {
		var
			$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	$T		= $Ts[pane]
		,	o		= options[pane]
		,	s		= state[pane]
		,	side	= _c[pane].side.toLowerCase()
		,	inset	= "inset"+ _c[pane].side
		,	rClass	= o.resizerClass
		,	tClass	= o.togglerClass
		,	_pane	= "-"+ pane // used for classNames
		,	_open	= "-open"
		,	_sliding= "-sliding"
		,	_closed	= "-closed"
		;
		$R
			.css(side, sC[inset]) // move the resizer
			.removeClass( rClass+_open +" "+ rClass+_pane+_open )
			.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
			.addClass( rClass+_closed +" "+ rClass+_pane+_closed )
			.unbind("dblclick."+ sID)
		;
		// DISABLE 'resizing' when closed - do this BEFORE bindStartSlidingEvent?
		if (o.resizable && $.layout.plugins.draggable)
			$R
				.draggable("disable")
				.removeClass("ui-state-disabled") // do NOT apply disabled styling - not suitable here
				.css("cursor", "default")
				.attr("title","")
			;

		// if pane has a toggler button, adjust that too
		if ($T) {
			$T
				.removeClass( tClass+_open +" "+ tClass+_pane+_open )
				.addClass( tClass+_closed +" "+ tClass+_pane+_closed )
				.attr("title", o.tips.Open) // may be blank
			;
			// toggler-content - if exists
			$T.children(".content-open").hide();
			$T.children(".content-closed").css("display","block");
		}

		// sync any 'pin buttons'
		syncPinBtns(pane, false);

		if (state.initialized) {
			// resize 'length' and position togglers for adjacent panes
			sizeHandles();
		}
	}

	/**
	* Open the specified pane (animation optional), and resize all other panes as needed
	*
	* @param {string|Object}	evt_or_pane			The pane being opened, ie: north, south, east, or west
	* @param {boolean=}			[slide=false]
	* @param {boolean=}			[noAnimation=false]
	* @param {boolean=}			[noAlert=false]
	*/
,	open = function (evt_or_pane, slide, noAnimation, noAlert) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	doFX, isShowing
		;
		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){

			if ( !$P
			||	(!o.resizable && !o.closable && !s.isShowing)	// invalid request
			||	(s.isVisible && !s.isSliding)					// already open
			) return queueNext();

			// pane can ALSO be unhidden by just calling show(), so handle this scenario
			if (s.isHidden && !s.isShowing) {
				queueNext(); // call before show() because it needs the queue free
				show(pane, true);
				return;
			}

			if (o.autoResize && s.size != o.size) // resize pane to original size set in options
				sizePane(pane, o.size, true, true, true); // true=skipCallback/forceResize/noAnimation
			else
				// make sure there is enough space available to open the pane
				setSizeLimits(pane, slide);

			// onopen_start callback - will CANCEL open if returns false
			var cbReturn = _runCallbacks("onopen_start", pane);

			if (cbReturn === "abort")
				return queueNext();

			// update pane-state again in case options were changed in onopen_start
			if (cbReturn !== "NC") // NC = "No Callback"
				setSizeLimits(pane, slide);

			if (s.minSize > s.maxSize) { // INSUFFICIENT ROOM FOR PANE TO OPEN!
				syncPinBtns(pane, false); // make sure pin-buttons are reset
				if (!noAlert && o.tips.noRoomToOpen)
					alert(o.tips.noRoomToOpen);
				return queueNext(); // ABORT
			}

			if (slide) // START Sliding - will set isSliding=true
				bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
			else if (s.isSliding) // PIN PANE (stop sliding) - open pane 'normally' instead
				bindStopSlidingEvents(pane, false); // UNBIND trigger events - will set isSliding=false
			else if (o.slidable)
				bindStartSlidingEvent(pane, false); // UNBIND trigger events

			s.noRoom = false; // will be reset by makePaneFit if 'noRoom'
			makePaneFit(pane);

			// transfer logic var to temp var
			isShowing = s.isShowing;
			// now clear the logic var
			delete s.isShowing;

			doFX		= !noAnimation && s.isClosed && (o.fxName_open != "none");
			s.isMoving	= true;
			s.isVisible	= true;
			s.isClosed	= false;
			// update isHidden BEFORE sizing panes - WHY??? Old?
			if (isShowing) s.isHidden = false;

			if (doFX) { // ANIMATE
				// mask panes with objects
				var masks = "center"+ (c.dir=="horz" ? ",west,east" : "");
				if (s.isSliding) masks += ","+ _c.oppositeEdge[pane];
				showMasks( masks, true );	// true = ONLY mask panes with maskObjects=true
				lockPaneForFX(pane, true);	// need to set left/top so animation will work
				$P.show( o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function() {
					lockPaneForFX(pane, false); // undo
					if (s.isVisible) open_2(); // continue
					queueNext();
				});
			}
			else { // no animation
				_showPane(pane);// just show pane and...
				open_2();		// continue
				queueNext();
			};
		});

		// SUBROUTINE
		function open_2 () {
			s.isMoving	= false;

			// cure iframe display issues
			_fixIframe(pane);

			// NOTE: if isSliding, then other panes are NOT 'resized'
			if (!s.isSliding) { // resize all panes adjacent to this one
				hideMasks(); // remove any masks shown while opening
				sizeMidPanes(_c[pane].dir=="vert" ? "center" : "", false); // false = NOT skipCallback
			}

			// set classes, position handles and execute callbacks...
			setAsOpen(pane);
		};
	
	}

	/**
	* @param {string}	pane		The pane just opened, ie: north, south, east, or west
	* @param {boolean=}	[skipCallback=false]
	*/
,	setAsOpen = function (pane, skipCallback) {
		var 
			$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	$T		= $Ts[pane]
		,	o		= options[pane]
		,	s		= state[pane]
		,	side	= _c[pane].side.toLowerCase()
		,	inset	= "inset"+ _c[pane].side
		,	rClass	= o.resizerClass
		,	tClass	= o.togglerClass
		,	_pane	= "-"+ pane // used for classNames
		,	_open	= "-open"
		,	_closed	= "-closed"
		,	_sliding= "-sliding"
		;
		$R
			.css(side, sC[inset] + getPaneSize(pane)) // move the resizer
			.removeClass( rClass+_closed +" "+ rClass+_pane+_closed )
			.addClass( rClass+_open +" "+ rClass+_pane+_open )
		;
		if (s.isSliding)
			$R.addClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
		else // in case 'was sliding'
			$R.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )

		if (o.resizerDblClickToggle)
			$R.bind("dblclick", toggle );
		removeHover( 0, $R ); // remove hover classes
		if (o.resizable && $.layout.plugins.draggable)
			$R	.draggable("enable")
				.css("cursor", o.resizerCursor)
				.attr("title", o.tips.Resize);
		else if (!s.isSliding)
			$R.css("cursor", "default"); // n-resize, s-resize, etc

		// if pane also has a toggler button, adjust that too
		if ($T) {
			$T	.removeClass( tClass+_closed +" "+ tClass+_pane+_closed )
				.addClass( tClass+_open +" "+ tClass+_pane+_open )
				.attr("title", o.tips.Close); // may be blank
			removeHover( 0, $T ); // remove hover classes
			// toggler-content - if exists
			$T.children(".content-closed").hide();
			$T.children(".content-open").css("display","block");
		}

		// sync any 'pin buttons'
		syncPinBtns(pane, !s.isSliding);

		// update pane-state dimensions - BEFORE resizing content
		$.extend(s, elDims($P));

		if (state.initialized) {
			// resize resizer & toggler sizes for all panes
			sizeHandles();
			// resize content every time pane opens - to be sure
			sizeContent(pane, true); // true = remeasure headers/footers, even if 'pane.isMoving'
		}

		if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(":visible")) {
			// onopen callback
			_runCallbacks("onopen_end", pane);
			// onshow callback - TODO: should this be here?
			if (s.isShowing) _runCallbacks("onshow_end", pane);

			// ALSO call onresize because layout-size *may* have changed while pane was closed
			if (state.initialized)
				_runCallbacks("onresize_end", pane);
		}

		// TODO: Somehow sizePane("north") is being called after this point???
	}


	/**
	* slideOpen / slideClose / slideToggle
	*
	* Pass-though methods for sliding
	*/
,	slideOpen = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	s		= state[pane]
		,	delay	= options[pane].slideDelay_open
		;
		// prevent event from triggering on NEW resizer binding created below
		if (evt) evt.stopImmediatePropagation();

		if (s.isClosed && evt && evt.type === "mouseenter" && delay > 0)
			// trigger = mouseenter - use a delay
			timer.set(pane+"_openSlider", open_NOW, delay);
		else
			open_NOW(); // will unbind events if is already open

		/**
		* SUBROUTINE for timed open
		*/
		function open_NOW () {
			if (!s.isClosed) // skip if no longer closed!
				bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
			else if (!s.isMoving)
				open(pane, true); // true = slide - open() will handle binding
		};
	}

,	slideClose = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	evt		= evtObj(evt_or_pane)
		,	pane	= evtPane.call(this, evt_or_pane)
		,	o		= options[pane]
		,	s		= state[pane]
		,	delay	= s.isMoving ? 1000 : 300 // MINIMUM delay - option may override
		;
		if (s.isClosed || s.isResizing)
			return; // skip if already closed OR in process of resizing
		else if (o.slideTrigger_close === "click")
			close_NOW(); // close immediately onClick
		else if (o.preventQuickSlideClose && s.isMoving)
			return; // handle Chrome quick-close on slide-open
		else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
			return; // handle incorrect mouseleave trigger, like when over a SELECT-list in IE
		else if (evt) // trigger = mouseleave - use a delay
			// 1 sec delay if 'opening', else .3 sec
			timer.set(pane+"_closeSlider", close_NOW, max(o.slideDelay_close, delay));
		else // called programically
			close_NOW();

		/**
		* SUBROUTINE for timed close
		*/
		function close_NOW () {
			if (s.isClosed) // skip 'close' if already closed!
				bindStopSlidingEvents(pane, false); // UNBIND trigger events - TODO: is this needed here?
			else if (!s.isMoving)
				close(pane); // close will handle unbinding
		};
	}

	/**
	* @param {string|Object}	evt_or_pane		The pane being opened, ie: north, south, east, or west
	*/
,	slideToggle = function (evt_or_pane) {
		var pane = evtPane.call(this, evt_or_pane);
		toggle(pane, true);
	}


	/**
	* Must set left/top on East/South panes so animation will work properly
	*
	* @param {string}	pane	The pane to lock, 'east' or 'south' - any other is ignored!
	* @param {boolean}	doLock  true = set left/top, false = remove
	*/
,	lockPaneForFX = function (pane, doLock) {
		var $P	= $Ps[pane]
		,	s	= state[pane]
		,	o	= options[pane]
		,	z	= options.zIndexes
		;
		if (doLock) {
			$P.css({ zIndex: z.pane_animate }); // overlay all elements during animation
			if (pane=="south")
				$P.css({ top: sC.insetTop + sC.innerHeight - $P.outerHeight() });
			else if (pane=="east")
				$P.css({ left: sC.insetLeft + sC.innerWidth - $P.outerWidth() });
		}
		else { // animation DONE - RESET CSS
			// TODO: see if this can be deleted. It causes a quick-close when sliding in Chrome
			$P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
			if (pane=="south")
				$P.css({ top: "auto" });
			// if pane is positioned 'off-screen', then DO NOT screw with it!
			else if (pane=="east" && !$P.css("left").match(/\-99999/))
				$P.css({ left: "auto" });
			// fix anti-aliasing in IE - only needed for animations that change opacity
			if (browser.msie && o.fxOpacityFix && o.fxName_open != "slide" && $P.css("filter") && $P.css("opacity") == 1)
				$P[0].style.removeAttribute('filter');
		}
	}


	/**
	* Toggle sliding functionality of a specific pane on/off by adding removing 'slide open' trigger
	*
	* @see  open(), close()
	* @param {string}	pane	The pane to enable/disable, 'north', 'south', etc.
	* @param {boolean}	enable	Enable or Disable sliding?
	*/
,	bindStartSlidingEvent = function (pane, enable) {
		var o		= options[pane]
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	evtName	= o.slideTrigger_open.toLowerCase()
		;
		if (!$R || (enable && !o.slidable)) return;

		// make sure we have a valid event
		if (evtName.match(/mouseover/))
			evtName = o.slideTrigger_open = "mouseenter";
		else if (!evtName.match(/(click|dblclick|mouseenter)/)) 
			evtName = o.slideTrigger_open = "click";

		$R
			// add or remove event
			[enable ? "bind" : "unbind"](evtName +'.'+ sID, slideOpen)
			// set the appropriate cursor & title/tip
			.css("cursor", enable ? o.sliderCursor : "default")
			.attr("title", enable ? o.tips.Slide : "")
		;
	}

	/**
	* Add or remove 'mouseleave' events to 'slide close' when pane is 'sliding' open or closed
	* Also increases zIndex when pane is sliding open
	* See bindStartSlidingEvent for code to control 'slide open'
	*
	* @see  slideOpen(), slideClose()
	* @param {string}	pane	The pane to process, 'north', 'south', etc.
	* @param {boolean}	enable	Enable or Disable events?
	*/
,	bindStopSlidingEvents = function (pane, enable) {
		var	o		= options[pane]
		,	s		= state[pane]
		,	c		= _c[pane]
		,	z		= options.zIndexes
		,	evtName	= o.slideTrigger_close.toLowerCase()
		,	action	= (enable ? "bind" : "unbind")
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		;
		s.isSliding = enable; // logic
		timer.clear(pane+"_closeSlider"); // just in case

		// remove 'slideOpen' event from resizer
		// ALSO will raise the zIndex of the pane & resizer
		if (enable) bindStartSlidingEvent(pane, false);

		// RE/SET zIndex - increases when pane is sliding-open, resets to normal when not
		$P.css("zIndex", enable ? z.pane_sliding : z.pane_normal);
		$R.css("zIndex", enable ? z.pane_sliding+2 : z.resizer_normal); // NOTE: mask = pane_sliding+1

		// make sure we have a valid event
		if (!evtName.match(/(click|mouseleave)/))
			evtName = o.slideTrigger_close = "mouseleave"; // also catches 'mouseout'

		// add/remove slide triggers
		$R[action](evtName, slideClose); // base event on resize
		// need extra events for mouseleave
		if (evtName === "mouseleave") {
			// also close on pane.mouseleave
			$P[action]("mouseleave."+ sID, slideClose);
			// cancel timer when mouse moves between 'pane' and 'resizer'
			$R[action]("mouseenter."+ sID, cancelMouseOut);
			$P[action]("mouseenter."+ sID, cancelMouseOut);
		}

		if (!enable)
			timer.clear(pane+"_closeSlider");
		else if (evtName === "click" && !o.resizable) {
			// IF pane is not resizable (which already has a cursor and tip) 
			// then set the a cursor & title/tip on resizer when sliding
			$R.css("cursor", enable ? o.sliderCursor : "default");
			$R.attr("title", enable ? o.tips.Close : ""); // use Toggler-tip, eg: "Close Pane"
		}

		// SUBROUTINE for mouseleave timer clearing
		function cancelMouseOut (evt) {
			timer.clear(pane+"_closeSlider");
			evt.stopPropagation();
		}
	}


	/**
	* Hides/closes a pane if there is insufficient room - reverses this when there is room again
	* MUST have already called setSizeLimits() before calling this method
	*
	* @param {string}	pane					The pane being resized
	* @param {boolean=}	[isOpening=false]		Called from onOpen?
	* @param {boolean=}	[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}	[force=false]
	*/
,	makePaneFit = function (pane, isOpening, skipCallback, force) {
		var
			o	= options[pane]
		,	s	= state[pane]
		,	c	= _c[pane]
		,	$P	= $Ps[pane]
		,	$R	= $Rs[pane]
		,	isSidePane 	= c.dir==="vert"
		,	hasRoom		= false
		;
		// special handling for center & east/west panes
		if (pane === "center" || (isSidePane && s.noVerticalRoom)) {
			// see if there is enough room to display the pane
			// ERROR: hasRoom = s.minHeight <= s.maxHeight && (isSidePane || s.minWidth <= s.maxWidth);
			hasRoom = (s.maxHeight >= 0);
			if (hasRoom && s.noRoom) { // previously hidden due to noRoom, so show now
				_showPane(pane);
				if ($R) $R.show();
				s.isVisible = true;
				s.noRoom = false;
				if (isSidePane) s.noVerticalRoom = false;
				_fixIframe(pane);
			}
			else if (!hasRoom && !s.noRoom) { // not currently hidden, so hide now
				_hidePane(pane);
				if ($R) $R.hide();
				s.isVisible = false;
				s.noRoom = true;
			}
		}

		// see if there is enough room to fit the border-pane
		if (pane === "center") {
			// ignore center in this block
		}
		else if (s.minSize <= s.maxSize) { // pane CAN fit
			hasRoom = true;
			if (s.size > s.maxSize) // pane is too big - shrink it
				sizePane(pane, s.maxSize, skipCallback, force, true); // true = noAnimation
			else if (s.size < s.minSize) // pane is too small - enlarge it
				sizePane(pane, s.minSize, skipCallback, force, true);
			// need s.isVisible because new pseudoClose method keeps pane visible, but off-screen
			else if ($R && s.isVisible && $P.is(":visible")) {
				// make sure resizer-bar is positioned correctly
				// handles situation where nested layout was 'hidden' when initialized
				var	side = c.side.toLowerCase()
				,	pos  = s.size + sC["inset"+ c.side]
				;
				if ($.layout.cssNum($R, side) != pos) $R.css( side, pos );
			}

			// if was previously hidden due to noRoom, then RESET because NOW there is room
			if (s.noRoom) {
				// s.noRoom state will be set by open or show
				if (s.wasOpen && o.closable) {
					if (o.autoReopen)
						open(pane, false, true, true); // true = noAnimation, true = noAlert
					else // leave the pane closed, so just update state
						s.noRoom = false;
				}
				else
					show(pane, s.wasOpen, true, true); // true = noAnimation, true = noAlert
			}
		}
		else { // !hasRoom - pane CANNOT fit
			if (!s.noRoom) { // pane not set as noRoom yet, so hide or close it now...
				s.noRoom = true; // update state
				s.wasOpen = !s.isClosed && !s.isSliding;
				if (s.isClosed){} // SKIP
				else if (o.closable) // 'close' if possible
					close(pane, true, true); // true = force, true = noAnimation
				else // 'hide' pane if cannot just be closed
					hide(pane, true); // true = noAnimation
			}
		}
	}


	/**
	* sizePane / manualSizePane
	* sizePane is called only by internal methods whenever a pane needs to be resized
	* manualSizePane is an exposed flow-through method allowing extra code when pane is 'manually resized'
	*
	* @param {string|Object}	evt_or_pane				The pane being resized
	* @param {number}			size					The *desired* new size for this pane - will be validated
	* @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}			[noAnimation=false]
	*/
,	manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	o	= options[pane]
		,	s	= state[pane]
		//	if resizing callbacks have been delayed and resizing is now DONE, force resizing to complete...
		,	forceResize = o.livePaneResizing && !s.isResizing
		;
		// ANY call to manualSizePane disables autoResize - ie, percentage sizing
		o.autoResize = false;
		// flow-through...
		sizePane(pane, size, skipCallback, forceResize, noAnimation); // will animate resize if option enabled
	}

	/**
	* @param {string|Object}	evt_or_pane				The pane being resized
	* @param {number}			size					The *desired* new size for this pane - will be validated
	* @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
	* @param {boolean=}			[noAnimation=false]
	*/
,	sizePane = function (evt_or_pane, size, skipCallback, force, noAnimation) {
		if (!isInitialized()) return;
		var	pane	= evtPane.call(this, evt_or_pane) // probably NEVER called from event?
		,	o		= options[pane]
		,	s		= state[pane]
		,	$P		= $Ps[pane]
		,	$R		= $Rs[pane]
		,	side	= _c[pane].side.toLowerCase()
		,	dimName	= _c[pane].sizeType.toLowerCase()
		,	inset	= "inset"+ _c[pane].side
		,	skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize
		,	doFX	= noAnimation !== true && o.animatePaneSizing
		,	oldSize, newSize
		;
		// QUEUE in case another action/animation is in progress
		$N.queue(function( queueNext ){
			// calculate 'current' min/max sizes
			setSizeLimits(pane); // update pane-state
			oldSize = s.size;
			size = _parseSize(pane, size); // handle percentages & auto
			size = max(size, _parseSize(pane, o.minSize));
			size = min(size, s.maxSize);
			if (size < s.minSize) { // not enough room for pane!
				queueNext(); // call before makePaneFit() because it needs the queue free
				makePaneFit(pane, false, skipCallback);	// will hide or close pane
				return;
			}

			// IF newSize is same as oldSize, then nothing to do - abort
			if (!force && size === oldSize)
				return queueNext();

			// onresize_start callback CANNOT cancel resizing because this would break the layout!
			if (!skipCallback && state.initialized && s.isVisible)
				_runCallbacks("onresize_start", pane);

			// resize the pane, and make sure its visible
			newSize = cssSize(pane, size);

			if (doFX && $P.is(":visible")) { // ANIMATE
				var fx		= $.layout.effects.size[pane] || $.layout.effects.size.all
				,	easing	= o.fxSettings_size.easing || fx.easing
				,	z		= options.zIndexes
				,	props	= {};
				props[ dimName ] = newSize +'px';
				s.isMoving = true;
				// overlay all elements during animation
				$P.css({ zIndex: z.pane_animate })
				  .show().animate( props, o.fxSpeed_size, easing, function(){
					// reset zIndex after animation
					$P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
					s.isMoving = false;
					sizePane_2(); // continue
					queueNext();
				});
			}
			else { // no animation
				$P.css( dimName, newSize );	// resize pane
				// if pane is visible, then 
				if ($P.is(":visible"))
					sizePane_2(); // continue
				else {
					// pane is NOT VISIBLE, so just update state data...
					// when pane is *next opened*, it will have the new size
					s.size = size;				// update state.size
					$.extend(s, elDims($P));	// update state dimensions
				}
				queueNext();
			};

		});

		// SUBROUTINE
		function sizePane_2 () {
			/*	Panes are sometimes not sized precisely in some browsers!?
			 *	This code will resize the pane up to 3 times to nudge the pane to the correct size
			 */
			var	actual	= dimName==='width' ? $P.outerWidth() : $P.outerHeight()
			,	tries	= [{
						   	pane:		pane
						,	count:		1
						,	target:		size
						,	actual:		actual
						,	correct:	(size === actual)
						,	attempt:	size
						,	cssSize:	newSize
						}]
			,	lastTry = tries[0]
			,	thisTry	= {}
			,	msg		= 'Inaccurate size after resizing the '+ pane +'-pane.'
			;
			while ( !lastTry.correct ) {
				thisTry = { pane: pane, count: lastTry.count+1, target: size };

				if (lastTry.actual > size)
					thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
				else // lastTry.actual < size
					thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));

				thisTry.cssSize = cssSize(pane, thisTry.attempt);
				$P.css( dimName, thisTry.cssSize );

				thisTry.actual	= dimName=='width' ? $P.outerWidth() : $P.outerHeight();
				thisTry.correct	= (size === thisTry.actual);

				// log attempts and alert the user of this *non-fatal error* (if showDebugMessages)
				if ( tries.length === 1) {
					_log(msg, false, true);
					_log(lastTry, false, true);
				}
				_log(thisTry, false, true);
				// after 4 tries, is as close as its gonna get!
				if (tries.length > 3) break;

				tries.push( thisTry );
				lastTry = tries[ tries.length - 1 ];
			}
			// END TESTING CODE

			// update pane-state dimensions
			s.size	= size;
			$.extend(s, elDims($P));

			if (s.isVisible && $P.is(":visible")) {
				// reposition the resizer-bar
				if ($R) $R.css( side, size + sC[inset] );
				// resize the content-div
				sizeContent(pane);
			}

			if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
				_runCallbacks("onresize_end", pane);

			// resize all the adjacent panes, and adjust their toggler buttons
			// when skipCallback passed, it means the controlling method will handle 'other panes'
			if (!skipCallback) {
				// also no callback if live-resize is in progress and NOT triggerEventsDuringLiveResize
				if (!s.isSliding) sizeMidPanes(_c[pane].dir=="horz" ? "" : "center", skipResizeWhileDragging, force);
				sizeHandles();
			}

			// if opposite-pane was autoClosed, see if it can be autoOpened now
			var altPane = _c.oppositeEdge[pane];
			if (size < oldSize && state[ altPane ].noRoom) {
				setSizeLimits( altPane );
				makePaneFit( altPane, false, skipCallback );
			}

			// DEBUG - ALERT user/developer so they know there was a sizing problem
			if (tries.length > 1)
				_log(msg +'\nSee the Error Console for details.', true, true);
		}
	}

	/**
	* @see  initPanes(), sizePane(), resizeAll(), open(), close(), hide()
	* @param {Array.<string>|string} panes					The pane(s) being resized, comma-delmited string
	* @param {boolean=}				[skipCallback=false]	Should the onresize callback be run?
	* @param {boolean=}				[force=false]
	*/
,	sizeMidPanes = function (panes, skipCallback, force) {
		panes = (panes ? panes : "east,west,center").split(",");

		$.each(panes, function (i, pane) {
			if (!$Ps[pane]) return; // NO PANE - skip
			var 
				o		= options[pane]
			,	s		= state[pane]
			,	$P		= $Ps[pane]
			,	$R		= $Rs[pane]
			,	isCenter= (pane=="center")
			,	hasRoom	= true
			,	CSS		= {}
			,	newCenter	= calcNewCenterPaneDims()
			;
			// update pane-state dimensions
			$.extend(s, elDims($P));

			if (pane === "center") {
				if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight)
					return true; // SKIP - pane already the correct size
				// set state for makePaneFit() logic
				$.extend(s, cssMinDims(pane), {
					maxWidth:	newCenter.width
				,	maxHeight:	newCenter.height
				});
				CSS = newCenter;
				// convert OUTER width/height to CSS width/height 
				CSS.width	= cssW($P, CSS.width);
				// NEW - allow pane to extend 'below' visible area rather than hide it
				CSS.height	= cssH($P, CSS.height);
				hasRoom		= CSS.width >= 0 && CSS.height >= 0; // height >= 0 = ALWAYS TRUE NOW
				// during layout init, try to shrink east/west panes to make room for center
				if (!state.initialized && o.minWidth > s.outerWidth) {
					var
						reqPx	= o.minWidth - s.outerWidth
					,	minE	= options.east.minSize || 0
					,	minW	= options.west.minSize || 0
					,	sizeE	= state.east.size
					,	sizeW	= state.west.size
					,	newE	= sizeE
					,	newW	= sizeW
					;
					if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
						newE = max( sizeE-minE, sizeE-reqPx );
						reqPx -= sizeE-newE;
					}
					if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
						newW = max( sizeW-minW, sizeW-reqPx );
						reqPx -= sizeW-newW;
					}
					// IF we found enough extra space, then resize the border panes as calculated
					if (reqPx === 0) {
						if (sizeE && sizeE != minE)
							sizePane('east', newE, true, force, true); // true = skipCallback/noAnimation - initPanes will handle when done
						if (sizeW && sizeW != minW)
							sizePane('west', newW, true, force, true);
						// now start over!
						sizeMidPanes('center', skipCallback, force);
						return; // abort this loop
					}
				}
			}
			else { // for east and west, set only the height, which is same as center height
				// set state.min/maxWidth/Height for makePaneFit() logic
				if (s.isVisible && !s.noVerticalRoom)
					$.extend(s, elDims($P), cssMinDims(pane))
				if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight)
					return true; // SKIP - pane already the correct size
				// east/west have same top, bottom & height as center
				CSS.top		= newCenter.top;
				CSS.bottom	= newCenter.bottom;
				// NEW - allow pane to extend 'below' visible area rather than hide it
				CSS.height	= cssH($P, newCenter.height);
				s.maxHeight	= CSS.height;
				hasRoom		= (s.maxHeight >= 0); // ALWAYS TRUE NOW
				if (!hasRoom) s.noVerticalRoom = true; // makePaneFit() logic
			}

			if (hasRoom) {
				// resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
				if (!skipCallback && state.initialized)
					_runCallbacks("onresize_start", pane);

				$P.css(CSS); // apply the CSS to pane
				if (pane !== "center")
					sizeHandles(pane); // also update resizer length
				if (s.noRoom && !s.isClosed && !s.isHidden)
					makePaneFit(pane); // will re-open/show auto-closed/hidden pane
				if (s.isVisible) {
					$.extend(s, elDims($P)); // update pane dimensions
					if (state.initialized) sizeContent(pane); // also resize the contents, if exists
				}
			}
			else if (!s.noRoom && s.isVisible) // no room for pane
				makePaneFit(pane); // will hide or close pane

			if (!s.isVisible)
				return true; // DONE - next pane

			/*
			* Extra CSS for IE6 or IE7 in Quirks-mode - add 'width' to NORTH/SOUTH panes
			* Normally these panes have only 'left' & 'right' positions so pane auto-sizes
			* ALSO required when pane is an IFRAME because will NOT default to 'full width'
			*	TODO: Can I use width:100% for a north/south iframe?
			*	TODO: Sounds like a job for $P.outerWidth( sC.innerWidth ) SETTER METHOD
			*/
			if (pane === "center") { // finished processing midPanes
				var fix = browser.isIE6 || !browser.boxModel;
				if ($Ps.north && (fix || state.north.tagName=="IFRAME")) 
					$Ps.north.css("width", cssW($Ps.north, sC.innerWidth));
				if ($Ps.south && (fix || state.south.tagName=="IFRAME"))
					$Ps.south.css("width", cssW($Ps.south, sC.innerWidth));
			}

			// resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
			if (!skipCallback && state.initialized)
				_runCallbacks("onresize_end", pane);
		});
	}


	/**
	* @see  window.onresize(), callbacks or custom code
	*/
,	resizeAll = function (evt) {
		// stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
		evtPane(evt);

		if (!state.initialized) {
			_initLayoutElements();
			return; // no need to resize since we just initialized!
		}
		var	oldW	= sC.innerWidth
		,	oldH	= sC.innerHeight
		;
		// cannot size layout when 'container' is hidden or collapsed
		if (!$N.is(":visible") ) return;
		$.extend(state.container, elDims( $N )); // UPDATE container dimensions
		if (!sC.outerHeight) return;

		// onresizeall_start will CANCEL resizing if returns false
		// state.container has already been set, so user can access this info for calcuations
		if (false === _runCallbacks("onresizeall_start")) return false;

		var	// see if container is now 'smaller' than before
			shrunkH	= (sC.innerHeight < oldH)
		,	shrunkW	= (sC.innerWidth < oldW)
		,	$P, o, s, dir
		;
		// NOTE special order for sizing: S-N-E-W
		$.each(["south","north","east","west"], function (i, pane) {
			if (!$Ps[pane]) return; // no pane - SKIP
			s	= state[pane];
			o	= options[pane];
			dir	= _c[pane].dir;

			if (o.autoResize && s.size != o.size) // resize pane to original size set in options
				sizePane(pane, o.size, true, true, true); // true=skipCallback/forceResize/noAnimation
			else {
				setSizeLimits(pane);
				makePaneFit(pane, false, true, true); // true=skipCallback/forceResize
			}
		});

		sizeMidPanes("", true, true); // true=skipCallback, true=forceResize
		sizeHandles(); // reposition the toggler elements

		// trigger all individual pane callbacks AFTER layout has finished resizing
		o = options; // reuse alias
		$.each(_c.allPanes, function (i, pane) {
			$P = $Ps[pane];
			if (!$P) return; // SKIP
			if (state[pane].isVisible) // undefined for non-existent panes
				_runCallbacks("onresize_end", pane); // callback - if exists
		});

		_runCallbacks("onresizeall_end");
		//_triggerLayoutEvent(pane, 'resizeall');
	}

	/**
	* Whenever a pane resizes or opens that has a nested layout, trigger resizeAll
	*
	* @param {string|Object}	evt_or_pane		The pane just resized or opened
	*/
,	resizeChildLayout = function (evt_or_pane) {
		var	pane = evtPane.call(this, evt_or_pane);
		if (!options[pane].resizeChildLayout) return;
		var	$P	= $Ps[pane]
		,	$C	= $Cs[pane]
		,	d	= "layout"
		,	P	= Instance[pane]
		,	L	= children[pane]
		;
		// user may have manually set EITHER instance pointer, so handle that
		if (P.child && !L) {
			// have to reverse the pointers!
			var el = P.child.container;
			L = children[pane] = (el ? el.data(d) : 0) || null; // set pointer _directly_ to layout instance
		}

		// if a layout-pointer exists, see if child has been destroyed
		if (L && L.destroyed)
			L = children[pane] = null; // clear child pointers
		// no child layout pointer is set - see if there is a child layout NOW
		if (!L)	L = children[pane] = $P.data(d) || ($C ? $C.data(d) : 0) || null; // set/update child pointers

		// ALWAYS refresh the pane.child alias
		P.child = children[pane];

		if (L) L.resizeAll();
	}


	/**
	* IF pane has a content-div, then resize all elements inside pane to fit pane-height
	*
	* @param {string|Object}	evt_or_panes		The pane(s) being resized
	* @param {boolean=}			[remeasure=false]	Should the content (header/footer) be remeasured?
	*/
,	sizeContent = function (evt_or_panes, remeasure) {
		if (!isInitialized()) return;

		var panes = evtPane.call(this, evt_or_panes);
		panes = panes ? panes.split(",") : _c.allPanes;

		$.each(panes, function (idx, pane) {
			var
				$P	= $Ps[pane]
			,	$C	= $Cs[pane]
			,	o	= options[pane]
			,	s	= state[pane]
			,	m	= s.content // m = measurements
			;
			if (!$P || !$C || !$P.is(":visible")) return true; // NOT VISIBLE - skip

			// if content-element was REMOVED, update OR remove the pointer
			if (!$C.length) {
				initContent(pane, false);	// false = do NOT sizeContent() - already there!
				if (!$C) return;			// no replacement element found - pointer have been removed
			}

			// onsizecontent_start will CANCEL resizing if returns false
			if (false === _runCallbacks("onsizecontent_start", pane)) return;

			// skip re-measuring offsets if live-resizing
			if ((!s.isMoving && !s.isResizing) || o.liveContentResizing || remeasure || m.top == undefined) {
				_measure();
				// if any footers are below pane-bottom, they may not measure correctly,
				// so allow pane overflow and re-measure
				if (m.hiddenFooters > 0 && $P.css("overflow") === "hidden") {
					$P.css("overflow", "visible");
					_measure(); // remeasure while overflowing
					$P.css("overflow", "hidden");
				}
			}
			// NOTE: spaceAbove/Below *includes* the pane paddingTop/Bottom, but not pane.borders
			var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);

			if (!$C.is(":visible") || m.height != newH) {
				// size the Content element to fit new pane-size - will autoHide if not enough room
				setOuterHeight($C, newH, true); // true=autoHide
				m.height = newH; // save new height
			};

			if (state.initialized)
				_runCallbacks("onsizecontent_end", pane);

			function _below ($E) {
				return max(s.css.paddingBottom, (parseInt($E.css("marginBottom"), 10) || 0));
			};

			function _measure () {
				var
					ignore	= options[pane].contentIgnoreSelector
				,	$Fs		= $C.nextAll().not(ignore || ':lt(0)') // not :lt(0) = ALL
				,	$Fs_vis	= $Fs.filter(':visible')
				,	$F		= $Fs_vis.filter(':last')
				;
				m = {
					top:			$C[0].offsetTop
				,	height:			$C.outerHeight()
				,	numFooters:		$Fs.length
				,	hiddenFooters:	$Fs.length - $Fs_vis.length
				,	spaceBelow:		0 // correct if no content footer ($E)
				}
					m.spaceAbove	= m.top; // just for state - not used in calc
					m.bottom		= m.top + m.height;
				if ($F.length)
					//spaceBelow = (LastFooter.top + LastFooter.height) [footerBottom] - Content.bottom + max(LastFooter.marginBottom, pane.paddingBotom)
					m.spaceBelow = ($F[0].offsetTop + $F.outerHeight()) - m.bottom + _below($F);
				else // no footer - check marginBottom on Content element itself
					m.spaceBelow = _below($C);
			};
		});
	}


	/**
	* Called every time a pane is opened, closed, or resized to slide the togglers to 'center' and adjust their length if necessary
	*
	* @see  initHandles(), open(), close(), resizeAll()
	* @param {string|Object}	evt_or_panes		The pane(s) being resized
	*/
,	sizeHandles = function (evt_or_panes) {
		var panes = evtPane.call(this, evt_or_panes)
		panes = panes ? panes.split(",") : _c.borderPanes;

		$.each(panes, function (i, pane) {
			var 
				o	= options[pane]
			,	s	= state[pane]
			,	$P	= $Ps[pane]
			,	$R	= $Rs[pane]
			,	$T	= $Ts[pane]
			,	$TC
			;
			if (!$P || !$R) return;

			var
				dir			= _c[pane].dir
			,	_state		= (s.isClosed ? "_closed" : "_open")
			,	spacing		= o["spacing"+ _state]
			,	togAlign	= o["togglerAlign"+ _state]
			,	togLen		= o["togglerLength"+ _state]
			,	paneLen
			,	left
			,	offset
			,	CSS = {}
			;

			if (spacing === 0) {
				$R.hide();
				return;
			}
			else if (!s.noRoom && !s.isHidden) // skip if resizer was hidden for any reason
				$R.show(); // in case was previously hidden

			// Resizer Bar is ALWAYS same width/height of pane it is attached to
			if (dir === "horz") { // north/south
				//paneLen = $P.outerWidth(); // s.outerWidth || 
				paneLen = sC.innerWidth; // handle offscreen-panes
				s.resizerLength = paneLen;
				left = $.layout.cssNum($P, "left")
				$R.css({
					width:	cssW($R, paneLen) // account for borders & padding
				,	height:	cssH($R, spacing) // ditto
				,	left:	left > -9999 ? left : sC.insetLeft // handle offscreen-panes
				});
			}
			else { // east/west
				paneLen = $P.outerHeight(); // s.outerHeight || 
				s.resizerLength = paneLen;
				$R.css({
					height:	cssH($R, paneLen) // account for borders & padding
				,	width:	cssW($R, spacing) // ditto
				,	top:	sC.insetTop + getPaneSize("north", true) // TODO: what if no North pane?
				//,	top:	$.layout.cssNum($Ps["center"], "top")
				});
			}

			// remove hover classes
			removeHover( o, $R );

			if ($T) {
				if (togLen === 0 || (s.isSliding && o.hideTogglerOnSlide)) {
					$T.hide(); // always HIDE the toggler when 'sliding'
					return;
				}
				else
					$T.show(); // in case was previously hidden

				if (!(togLen > 0) || togLen === "100%" || togLen > paneLen) {
					togLen = paneLen;
					offset = 0;
				}
				else { // calculate 'offset' based on options.PANE.togglerAlign_open/closed
					if (isStr(togAlign)) {
						switch (togAlign) {
							case "top":
							case "left":	offset = 0;
											break;
							case "bottom":
							case "right":	offset = paneLen - togLen;
											break;
							case "middle":
							case "center":
							default:		offset = round((paneLen - togLen) / 2); // 'default' catches typos
						}
					}
					else { // togAlign = number
						var x = parseInt(togAlign, 10); //
						if (togAlign >= 0) offset = x;
						else offset = paneLen - togLen + x; // NOTE: x is negative!
					}
				}

				if (dir === "horz") { // north/south
					var width = cssW($T, togLen);
					$T.css({
						width:	width  // account for borders & padding
					,	height:	cssH($T, spacing) // ditto
					,	left:	offset // TODO: VERIFY that toggler  positions correctly for ALL values
					,	top:	0
					});
					// CENTER the toggler content SPAN
					$T.children(".content").each(function(){
						$TC = $(this);
						$TC.css("marginLeft", round((width-$TC.outerWidth())/2)); // could be negative
					});
				}
				else { // east/west
					var height = cssH($T, togLen);
					$T.css({
						height:	height // account for borders & padding
					,	width:	cssW($T, spacing) // ditto
					,	top:	offset // POSITION the toggler
					,	left:	0
					});
					// CENTER the toggler content SPAN
					$T.children(".content").each(function(){
						$TC = $(this);
						$TC.css("marginTop", round((height-$TC.outerHeight())/2)); // could be negative
					});
				}

				// remove ALL hover classes
				removeHover( 0, $T );
			}

			// DONE measuring and sizing this resizer/toggler, so can be 'hidden' now
			if (!state.initialized && (o.initHidden || s.noRoom)) {
				$R.hide();
				if ($T) $T.hide();
			}
		});
	}


	/**
	* @param {string|Object}	evt_or_pane
	*/
,	enableClosable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$T	= $Ts[pane]
		,	o	= options[pane]
		;
		if (!$T) return;
		o.closable = true;
		$T	.bind("click."+ sID, function(evt){ evt.stopPropagation(); toggle(pane); })
			.css("visibility", "visible")
			.css("cursor", "pointer")
			.attr("title", state[pane].isClosed ? o.tips.Open : o.tips.Close) // may be blank
			.show();
	}
	/**
	* @param {string|Object}	evt_or_pane
	* @param {boolean=}			[hide=false]
	*/
,	disableClosable = function (evt_or_pane, hide) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$T	= $Ts[pane]
		;
		if (!$T) return;
		options[pane].closable = false;
		// is closable is disable, then pane MUST be open!
		if (state[pane].isClosed) open(pane, false, true);
		$T	.unbind("."+ sID)
			.css("visibility", hide ? "hidden" : "visible") // instead of hide(), which creates logic issues
			.css("cursor", "default")
			.attr("title", "");
	}


	/**
	* @param {string|Object}	evt_or_pane
	*/
,	enableSlidable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		options[pane].slidable = true; 
		if (state[pane].isClosed)
			bindStartSlidingEvent(pane, true);
	}
	/**
	* @param {string|Object}	evt_or_pane
	*/
,	disableSlidable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R) return;
		options[pane].slidable = false; 
		if (state[pane].isSliding)
			close(pane, false, true);
		else {
			bindStartSlidingEvent(pane, false);
			$R	.css("cursor", "default")
				.attr("title", "");
			removeHover(null, $R[0]); // in case currently hovered
		}
	}


	/**
	* @param {string|Object}	evt_or_pane
	*/
,	enableResizable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		,	o	= options[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		o.resizable = true; 
		$R.draggable("enable");
		if (!state[pane].isClosed)
			$R	.css("cursor", o.resizerCursor)
			 	.attr("title", o.tips.Resize);
	}
	/**
	* @param {string|Object}	evt_or_pane
	*/
,	disableResizable = function (evt_or_pane) {
		if (!isInitialized()) return;
		var	pane = evtPane.call(this, evt_or_pane)
		,	$R	= $Rs[pane]
		;
		if (!$R || !$R.data('draggable')) return;
		options[pane].resizable = false; 
		$R	.draggable("disable")
			.css("cursor", "default")
			.attr("title", "");
		removeHover(null, $R[0]); // in case currently hovered
	}


	/**
	* Move a pane from source-side (eg, west) to target-side (eg, east)
	* If pane exists on target-side, move that to source-side, ie, 'swap' the panes
	*
	* @param {string|Object}	evt_or_pane1	The pane/edge being swapped
	* @param {string}			pane2			ditto
	*/
,	swapPanes = function (evt_or_pane1, pane2) {
		if (!isInitialized()) return;
		var pane1 = evtPane.call(this, evt_or_pane1);
		// change state.edge NOW so callbacks can know where pane is headed...
		state[pane1].edge = pane2;
		state[pane2].edge = pane1;
		// run these even if NOT state.initialized
		if (false === _runCallbacks("onswap_start", pane1)
		 ||	false === _runCallbacks("onswap_start", pane2)
		) {
			state[pane1].edge = pane1; // reset
			state[pane2].edge = pane2;
			return;
		}

		var
			oPane1	= copy( pane1 )
		,	oPane2	= copy( pane2 )
		,	sizes	= {}
		;
		sizes[pane1] = oPane1 ? oPane1.state.size : 0;
		sizes[pane2] = oPane2 ? oPane2.state.size : 0;

		// clear pointers & state
		$Ps[pane1] = false; 
		$Ps[pane2] = false;
		state[pane1] = {};
		state[pane2] = {};
		
		// ALWAYS remove the resizer & toggler elements
		if ($Ts[pane1]) $Ts[pane1].remove();
		if ($Ts[pane2]) $Ts[pane2].remove();
		if ($Rs[pane1]) $Rs[pane1].remove();
		if ($Rs[pane2]) $Rs[pane2].remove();
		$Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;

		// transfer element pointers and data to NEW Layout keys
		move( oPane1, pane2 );
		move( oPane2, pane1 );

		// cleanup objects
		oPane1 = oPane2 = sizes = null;

		// make panes 'visible' again
		if ($Ps[pane1]) $Ps[pane1].css(_c.visible);
		if ($Ps[pane2]) $Ps[pane2].css(_c.visible);

		// fix any size discrepancies caused by swap
		resizeAll();

		// run these even if NOT state.initialized
		_runCallbacks("onswap_end", pane1);
		_runCallbacks("onswap_end", pane2);

		return;

		function copy (n) { // n = pane
			var
				$P	= $Ps[n]
			,	$C	= $Cs[n]
			;
			return !$P ? false : {
				pane:		n
			,	P:			$P ? $P[0] : false
			,	C:			$C ? $C[0] : false
			,	state:		$.extend(true, {}, state[n])
			,	options:	$.extend(true, {}, options[n])
			}
		};

		function move (oPane, pane) {
			if (!oPane) return;
			var
				P		= oPane.P
			,	C		= oPane.C
			,	oldPane = oPane.pane
			,	c		= _c[pane]
			,	side	= c.side.toLowerCase()
			,	inset	= "inset"+ c.side
			//	save pane-options that should be retained
			,	s		= $.extend(true, {}, state[pane])
			,	o		= options[pane]
			//	RETAIN side-specific FX Settings - more below
			,	fx		= { resizerCursor: o.resizerCursor }
			,	re, size, pos
			;
			$.each("fxName,fxSpeed,fxSettings".split(","), function (i, k) {
				fx[k +"_open"]  = o[k +"_open"];
				fx[k +"_close"] = o[k +"_close"];
				fx[k +"_size"]  = o[k +"_size"];
			});

			// update object pointers and attributes
			$Ps[pane] = $(P)
				.data({
					layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
				,	layoutEdge:		pane
				})
				.css(_c.hidden)
				.css(c.cssReq)
			;
			$Cs[pane] = C ? $(C) : false;

			// set options and state
			options[pane]	= $.extend(true, {}, oPane.options, fx);
			state[pane]		= $.extend(true, {}, oPane.state);

			// change classNames on the pane, eg: ui-layout-pane-east ==> ui-layout-pane-west
			re = new RegExp(o.paneClass +"-"+ oldPane, "g");
			P.className = P.className.replace(re, o.paneClass +"-"+ pane);

			// ALWAYS regenerate the resizer & toggler elements
			initHandles(pane); // create the required resizer & toggler

			// if moving to different orientation, then keep 'target' pane size
			if (c.dir != _c[oldPane].dir) {
				size = sizes[pane] || 0;
				setSizeLimits(pane); // update pane-state
				size = max(size, state[pane].minSize);
				// use manualSizePane to disable autoResize - not useful after panes are swapped
				manualSizePane(pane, size, true, true); // true/true = skipCallback/noAnimation
			}
			else // move the resizer here
				$Rs[pane].css(side, sC[inset] + (state[pane].isVisible ? getPaneSize(pane) : 0));


			// ADD CLASSNAMES & SLIDE-BINDINGS
			if (oPane.state.isVisible && !s.isVisible)
				setAsOpen(pane, true); // true = skipCallback
			else {
				setAsClosed(pane);
				bindStartSlidingEvent(pane, true); // will enable events IF option is set
			}

			// DESTROY the object
			oPane = null;
		};
	}


	/**
	* INTERNAL method to sync pin-buttons when pane is opened or closed
	* Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
	*
	* @see  open(), setAsOpen(), setAsClosed()
	* @param {string}	pane   These are the params returned to callbacks by layout()
	* @param {boolean}	doPin  True means set the pin 'down', False means 'up'
	*/
,	syncPinBtns = function (pane, doPin) {
		if ($.layout.plugins.buttons)
			$.each(state[pane].pins, function (i, selector) {
				$.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
			});
	}

;	// END var DECLARATIONS

	/**
	* Capture keys when enableCursorHotkey - toggle pane if hotkey pressed
	*
	* @see  document.keydown()
	*/
	function keyDown (evt) {
		if (!evt) return true;
		var code = evt.keyCode;
		if (code < 33) return true; // ignore special keys: ENTER, TAB, etc

		var
			PANE = {
				38: "north" // Up Cursor	- $.ui.keyCode.UP
			,	40: "south" // Down Cursor	- $.ui.keyCode.DOWN
			,	37: "west"  // Left Cursor	- $.ui.keyCode.LEFT
			,	39: "east"  // Right Cursor	- $.ui.keyCode.RIGHT
			}
		,	ALT		= evt.altKey // no worky!
		,	SHIFT	= evt.shiftKey
		,	CTRL	= evt.ctrlKey
		,	CURSOR	= (CTRL && code >= 37 && code <= 40)
		,	o, k, m, pane
		;

		if (CURSOR && options[PANE[code]].enableCursorHotkey) // valid cursor-hotkey
			pane = PANE[code];
		else if (CTRL || SHIFT) // check to see if this matches a custom-hotkey
			$.each(_c.borderPanes, function (i, p) { // loop each pane to check its hotkey
				o = options[p];
				k = o.customHotkey;
				m = o.customHotkeyModifier; // if missing or invalid, treated as "CTRL+SHIFT"
				if ((SHIFT && m=="SHIFT") || (CTRL && m=="CTRL") || (CTRL && SHIFT)) { // Modifier matches
					if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) { // Key matches
						pane = p;
						return false; // BREAK
					}
				}
			});

		// validate pane
		if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
			return true;

		toggle(pane);

		evt.stopPropagation();
		evt.returnValue = false; // CANCEL key
		return false;
	};


/*
 * ######################################
 *	UTILITY METHODS
 *	called externally or by initButtons
 * ######################################
 */

	/**
	* Change/reset a pane overflow setting & zIndex to allow popups/drop-downs to work
	*
	* @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
	*/
	function allowOverflow (el) {
		if (!isInitialized()) return;
		if (this && this.tagName) el = this; // BOUND to element
		var $P;
		if (isStr(el))
			$P = $Ps[el];
		else if ($(el).data("layoutRole"))
			$P = $(el);
		else
			$(el).parents().each(function(){
				if ($(this).data("layoutRole")) {
					$P = $(this);
					return false; // BREAK
				}
			});
		if (!$P || !$P.length) return; // INVALID

		var
			pane	= $P.data("layoutEdge")
		,	s		= state[pane]
		;

		// if pane is already raised, then reset it before doing it again!
		// this would happen if allowOverflow is attached to BOTH the pane and an element 
		if (s.cssSaved)
			resetOverflow(pane); // reset previous CSS before continuing

		// if pane is raised by sliding or resizing, or its closed, then abort
		if (s.isSliding || s.isResizing || s.isClosed) {
			s.cssSaved = false;
			return;
		}

		var
			newCSS	= { zIndex: (options.zIndexes.resizer_normal + 1) }
		,	curCSS	= {}
		,	of		= $P.css("overflow")
		,	ofX		= $P.css("overflowX")
		,	ofY		= $P.css("overflowY")
		;
		// determine which, if any, overflow settings need to be changed
		if (of != "visible") {
			curCSS.overflow = of;
			newCSS.overflow = "visible";
		}
		if (ofX && !ofX.match(/(visible|auto)/)) {
			curCSS.overflowX = ofX;
			newCSS.overflowX = "visible";
		}
		if (ofY && !ofY.match(/(visible|auto)/)) {
			curCSS.overflowY = ofX;
			newCSS.overflowY = "visible";
		}

		// save the current overflow settings - even if blank!
		s.cssSaved = curCSS;

		// apply new CSS to raise zIndex and, if necessary, make overflow 'visible'
		$P.css( newCSS );

		// make sure the zIndex of all other panes is normal
		$.each(_c.allPanes, function(i, p) {
			if (p != pane) resetOverflow(p);
		});

	};
	/**
	* @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
	*/
	function resetOverflow (el) {
		if (!isInitialized()) return;
		if (this && this.tagName) el = this; // BOUND to element
		var $P;
		if (isStr(el))
			$P = $Ps[el];
		else if ($(el).data("layoutRole"))
			$P = $(el);
		else
			$(el).parents().each(function(){
				if ($(this).data("layoutRole")) {
					$P = $(this);
					return false; // BREAK
				}
			});
		if (!$P || !$P.length) return; // INVALID

		var
			pane	= $P.data("layoutEdge")
		,	s		= state[pane]
		,	CSS		= s.cssSaved || {}
		;
		// reset the zIndex
		if (!s.isSliding && !s.isResizing)
			$P.css("zIndex", options.zIndexes.pane_normal);

		// reset Overflow - if necessary
		$P.css( CSS );

		// clear var
		s.cssSaved = false;
	};

/*
 * #####################
 * CREATE/RETURN LAYOUT
 * #####################
 */

	// validate that container exists
	var $N = $(this).eq(0); // FIRST matching Container element
	if (!$N.length) {
		return _log( options.errors.containerMissing );
	};

	// Users retrieve Instance of a layout with: $N.layout() OR $N.data("layout")
	// return the Instance-pointer if layout has already been initialized
	if ($N.data("layoutContainer") && $N.data("layout"))
		return $N.data("layout"); // cached pointer

	// init global vars
	var 
		$Ps	= {}	// Panes x5		- set in initPanes()
	,	$Cs	= {}	// Content x5	- set in initPanes()
	,	$Rs	= {}	// Resizers x4	- set in initHandles()
	,	$Ts	= {}	// Togglers x4	- set in initHandles()
	,	$Ms	= $([])	// Masks - up to 2 masks per pane (IFRAME + DIV)
	//	aliases for code brevity
	,	sC	= state.container // alias for easy access to 'container dimensions'
	,	sID	= state.id // alias for unique layout ID/namespace - eg: "layout435"
	;

	// create Instance object to expose data & option Properties, and primary action Methods
	var Instance = {
	//	layout data
		options:			options			// property - options hash
	,	state:				state			// property - dimensions hash
	//	object pointers
	,	container:			$N				// property - object pointers for layout container
	,	panes:				$Ps				// property - object pointers for ALL Panes: panes.north, panes.center
	,	contents:			$Cs				// property - object pointers for ALL Content: contents.north, contents.center
	,	resizers:			$Rs				// property - object pointers for ALL Resizers, eg: resizers.north
	,	togglers:			$Ts				// property - object pointers for ALL Togglers, eg: togglers.north
	//	border-pane open/close
	,	hide:				hide			// method - ditto
	,	show:				show			// method - ditto
	,	toggle:				toggle			// method - pass a 'pane' ("north", "west", etc)
	,	open:				open			// method - ditto
	,	close:				close			// method - ditto
	,	slideOpen:			slideOpen		// method - ditto
	,	slideClose:			slideClose		// method - ditto
	,	slideToggle:		slideToggle		// method - ditto
	//	pane actions
	,	setSizeLimits:		setSizeLimits	// method - pass a 'pane' - update state min/max data
	,	_sizePane:			sizePane		// method -intended for user by plugins only!
	,	sizePane:			manualSizePane	// method - pass a 'pane' AND an 'outer-size' in pixels or percent, or 'auto'
	,	sizeContent:		sizeContent		// method - pass a 'pane'
	,	swapPanes:			swapPanes		// method - pass TWO 'panes' - will swap them
	,	showMasks:			showMasks		// method - pass a 'pane' OR list of panes - default = all panes with mask option set
	,	hideMasks:			hideMasks		// method - ditto'
	//	pane element methods
	,	initContent:		initContent		// method - ditto
	,	addPane:			addPane			// method - pass a 'pane'
	,	removePane:			removePane		// method - pass a 'pane' to remove from layout, add 'true' to delete the pane-elem
	,	createChildLayout:	createChildLayout// method - pass a 'pane' and (optional) layout-options (OVERRIDES options[pane].childOptions
	//	special pane option setting
	,	enableClosable:		enableClosable	// method - pass a 'pane'
	,	disableClosable:	disableClosable	// method - ditto
	,	enableSlidable:		enableSlidable	// method - ditto
	,	disableSlidable:	disableSlidable	// method - ditto
	,	enableResizable:	enableResizable	// method - ditto
	,	disableResizable:	disableResizable// method - ditto
	//	utility methods for panes
	,	allowOverflow:		allowOverflow	// utility - pass calling element (this)
	,	resetOverflow:		resetOverflow	// utility - ditto
	//	layout control
	,	destroy:			destroy			// method - no parameters
	,	initPanes:			isInitialized	// method - no parameters
	,	resizeAll:			resizeAll		// method - no parameters
	//	callback triggering
	,	runCallbacks:		_runCallbacks	// method - pass evtName & pane (if a pane-event), eg: trigger("onopen", "west")
	//	alias collections of options, state and children - created in addPane and extended elsewhere
	,	hasParentLayout:	false			// set by initContainer()
	,	children:			children		// pointers to child-layouts, eg: Instance.children["west"]
	,	north:				false			// alias group: { name: pane, pane: $Ps[pane], options: options[pane], state: state[pane], child: children[pane] }
	,	south:				false			// ditto
	,	west:				false			// ditto
	,	east:				false			// ditto
	,	center:				false			// ditto
	};

	// create the border layout NOW
	if (_create() === 'cancel') // onload_start callback returned false to CANCEL layout creation
		return null;
	else // true OR false -- if layout-elements did NOT init (hidden or do not exist), can auto-init later
		return Instance; // return the Instance object

}


/*	OLD versions of jQuery only set $.support.boxModel after page is loaded
 *	so if this is IE, use support.boxModel to test for quirks-mode (ONLY IE changes boxModel).
 */
$(function(){
	var b = $.layout.browser;
	if (b.msie) b.boxModel = $.support.boxModel;
});


/**
 * jquery.layout.state 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2010 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @dependancies: UI Layout 1.3.0.rc30.1 or higher
 * @dependancies: $.ui.cookie (above)
 *
 * @support: http://groups.google.com/group/jquery-ui-layout
 */
/*
 *	State-management options stored in options.stateManagement, which includes a .cookie hash
 *	Default options saves ALL KEYS for ALL PANES, ie: pane.size, pane.isClosed, pane.isHidden
 *
 *	// STATE/COOKIE OPTIONS
 *	@example $(el).layout({
				stateManagement: {
					enabled:	true
				,	stateKeys:	"east.size,west.size,east.isClosed,west.isClosed"
				,	cookie:		{ name: "appLayout", path: "/" }
				}
			})
 *	@example $(el).layout({ stateManagement__enabled: true }) // enable auto-state-management using cookies
 *	@example $(el).layout({ stateManagement__cookie: { name: "appLayout", path: "/" } })
 *	@example $(el).layout({ stateManagement__cookie__name: "appLayout", stateManagement__cookie__path: "/" })
 *
 *	// STATE/COOKIE METHODS
 *	@example myLayout.saveCookie( "west.isClosed,north.size,south.isHidden", {expires: 7} );
 *	@example myLayout.loadCookie();
 *	@example myLayout.deleteCookie();
 *	@example var JSON = myLayout.readState();	// CURRENT Layout State
 *	@example var JSON = myLayout.readCookie();	// SAVED Layout State (from cookie)
 *	@example var JSON = myLayout.state.stateData;	// LAST LOADED Layout State (cookie saved in layout.state hash)
 *
 *	CUSTOM STATE-MANAGEMENT (eg, saved in a database)
 *	@example var JSON = myLayout.readState( "west.isClosed,north.size,south.isHidden" );
 *	@example myLayout.loadState( JSON );
 */

/**
 *	UI COOKIE UTILITY
 *
 *	A $.cookie OR $.ui.cookie namespace *should be standard*, but until then...
 *	This creates $.ui.cookie so Layout does not need the cookie.jquery.js plugin
 *	NOTE: This utility is REQUIRED by the layout.state plugin
 *
 *	Cookie methods in Layout are created as part of State Management 
 */
if (!$.ui) $.ui = {};
$.ui.cookie = {

	// cookieEnabled is not in DOM specs, but DOES works in all browsers,including IE6
	acceptsCookies: !!navigator.cookieEnabled

,	read: function (name) {
		var
			c		= document.cookie
		,	cs		= c ? c.split(';') : []
		,	pair	// loop var
		;
		for (var i=0, n=cs.length; i < n; i++) {
			pair = $.trim(cs[i]).split('='); // name=value pair
			if (pair[0] == name) // found the layout cookie
				return decodeURIComponent(pair[1]);

		}
		return null;
	}

,	write: function (name, val, cookieOpts) {
		var
			params	= ''
		,	date	= ''
		,	clear	= false
		,	o		= cookieOpts || {}
		,	x		= o.expires
		;
		if (x && x.toUTCString)
			date = x;
		else if (x === null || typeof x === 'number') {
			date = new Date();
			if (x > 0)
				date.setDate(date.getDate() + x);
			else {
				date.setFullYear(1970);
				clear = true;
			}
		}
		if (date)		params += ';expires='+ date.toUTCString();
		if (o.path)		params += ';path='+ o.path;
		if (o.domain)	params += ';domain='+ o.domain;
		if (o.secure)	params += ';secure';
		document.cookie = name +'='+ (clear ? "" : encodeURIComponent( val )) + params; // write or clear cookie
	}

,	clear: function (name) {
		$.ui.cookie.write(name, '', {expires: -1});
	}

};
// if cookie.jquery.js is not loaded, create an alias to replicate it
// this may be useful to other plugins or code dependent on that plugin
if (!$.cookie) $.cookie = function (k, v, o) {
	var C = $.ui.cookie;
	if (v === null)
		C.clear(k);
	else if (v === undefined)
		return C.read(k);
	else
		C.write(k, v, o);
};


// tell Layout that the state plugin is available
$.layout.plugins.stateManagement = true;

//	Add State-Management options to layout.defaults
$.layout.config.optionRootKeys.push("stateManagement");
$.layout.defaults.stateManagement = {
	enabled:	false	// true = enable state-management, even if not using cookies
,	autoSave:	true	// Save a state-cookie when page exits?
,	autoLoad:	true	// Load the state-cookie when Layout inits?
	// List state-data to save - must be pane-specific
,	stateKeys:	"north.size,south.size,east.size,west.size,"+
				"north.isClosed,south.isClosed,east.isClosed,west.isClosed,"+
				"north.isHidden,south.isHidden,east.isHidden,west.isHidden"
,	cookie: {
		name:	""	// If not specified, will use Layout.name, else just "Layout"
	,	domain:	""	// blank = current domain
	,	path:	""	// blank = current page, '/' = entire website
	,	expires: ""	// 'days' to keep cookie - leave blank for 'session cookie'
	,	secure:	false
	}
};
// Set stateManagement as a layout-option, NOT a pane-option
$.layout.optionsMap.layout.push("stateManagement");

/*
 *	State Management methods
 */
$.layout.state = {

	/**
	 * Get the current layout state and save it to a cookie
	 *
	 * myLayout.saveCookie( keys, cookieOpts )
	 *
	 * @param {Object}			inst
	 * @param {(string|Array)=}	keys
	 * @param {Object=}			cookieOpts
	 */
	saveCookie: function (inst, keys, cookieOpts) {
		var o	= inst.options
		,	oS	= o.stateManagement
		,	oC	= $.extend(true, {}, oS.cookie, cookieOpts || null)
		,	data = inst.state.stateData = inst.readState( keys || oS.stateKeys ) // read current panes-state
		;
		$.ui.cookie.write( oC.name || o.name || "Layout", $.layout.state.encodeJSON(data), oC );
		return $.extend(true, {}, data); // return COPY of state.stateData data
	}

	/**
	 * Remove the state cookie
	 *
	 * @param {Object}	inst
	 */
,	deleteCookie: function (inst) {
		var o = inst.options;
		$.ui.cookie.clear( o.stateManagement.cookie.name || o.name || "Layout" );
	}

	/**
	 * Read & return data from the cookie - as JSON
	 *
	 * @param {Object}	inst
	 */
,	readCookie: function (inst) {
		var o = inst.options;
		var c = $.ui.cookie.read( o.stateManagement.cookie.name || o.name || "Layout" );
		// convert cookie string back to a hash and return it
		return c ? $.layout.state.decodeJSON(c) : {};
	}

	/**
	 * Get data from the cookie and USE IT to loadState
	 *
	 * @param {Object}	inst
	 */
,	loadCookie: function (inst) {
		var c = $.layout.state.readCookie(inst); // READ the cookie
		if (c) {
			inst.state.stateData = $.extend(true, {}, c); // SET state.stateData
			inst.loadState(c); // LOAD the retrieved state
		}
		return c;
	}
	
	/**
	 * Update layout options from the cookie, if one exists
	 *
	 * @param {Object}		inst
	 * @param {Object=}		stateData
	 * @param {boolean=}	animate
	 */
,	loadState: function (inst, stateData, animate) {
		stateData = $.layout.transformData( stateData ); // panes = default subkey
		if ($.isEmptyObject( stateData )) return;
		$.extend(true, inst.options, stateData); // update layout options
		// if layout has already been initialized, then UPDATE layout state
		if (inst.state.initialized) {
			var pane, vis, o, s, h, c
			,	noAnimate = (animate===false)
			;
			$.each($.layout.config.borderPanes, function (idx, pane) {
				state = inst.state[pane];
				o = stateData[ pane ];
				if (typeof o != 'object') return; // no key, continue
				s	= o.size;
				c	= o.initClosed;
				h	= o.initHidden;
				vis	= state.isVisible;
				// resize BEFORE opening
				if (!vis)
					inst.sizePane(pane, s, false, false);
				if (h === true)			inst.hide(pane, noAnimate);
				else if (c === false)	inst.open (pane, false, noAnimate);
				else if (c === true)	inst.close(pane, false, noAnimate);
				else if (h === false)	inst.show (pane, false, noAnimate);
				// resize AFTER any other actions
				if (vis)
					inst.sizePane(pane, s, false, noAnimate); // animate resize if option passed
			});
		};
	}

	/**
	 * Get the *current layout state* and return it as a hash
	 *
	 * @param {Object=}			inst
	 * @param {(string|Array)=}	keys
	 */
,	readState: function (inst, keys) {
		var
			data	= {}
		,	alt		= { isClosed: 'initClosed', isHidden: 'initHidden' }
		,	state	= inst.state
		,	panes	= $.layout.config.allPanes
		,	pair, pane, key, val
		;
		if (!keys) keys = inst.options.stateManagement.stateKeys; // if called by user
		if ($.isArray(keys)) keys = keys.join(",");
		// convert keys to an array and change delimiters from '__' to '.'
		keys = keys.replace(/__/g, ".").split(',');
		// loop keys and create a data hash
		for (var i=0, n=keys.length; i < n; i++) {
			pair = keys[i].split(".");
			pane = pair[0];
			key  = pair[1];
			if ($.inArray(pane, panes) < 0) continue; // bad pane!
			val = state[ pane ][ key ];
			if (val == undefined) continue;
			if (key=="isClosed" && state[pane]["isSliding"])
				val = true; // if sliding, then *really* isClosed
			( data[pane] || (data[pane]={}) )[ alt[key] ? alt[key] : key ] = val;
		}
		return data;
	}

	/**
	 *	Stringify a JSON hash so can save in a cookie or db-field
	 */
,	encodeJSON: function (JSON) {
		return parse(JSON);
		function parse (h) {
			var D=[], i=0, k, v, t; // k = key, v = value
			for (k in h) {
				v = h[k];
				t = typeof v;
				if (t == 'string')		// STRING - add quotes
					v = '"'+ v +'"';
				else if (t == 'object')	// SUB-KEY - recurse into it
					v = parse(v);
				D[i++] = '"'+ k +'":'+ v;
			}
			return '{'+ D.join(',') +'}';
		};
	}

	/**
	 *	Convert stringified JSON back to a hash object
	 *	@see		$.parseJSON(), adding in jQuery 1.4.1
	 */
,	decodeJSON: function (str) {
		try { return $.parseJSON ? $.parseJSON(str) : window["eval"]("("+ str +")") || {}; }
		catch (e) { return {}; }
	}


,	_create: function (inst) {
		var _	= $.layout.state;
		//	ADD State-Management plugin methods to inst
		 $.extend( inst, {
		//	readCookie - update options from cookie - returns hash of cookie data
			readCookie:		function () { return _.readCookie(inst); }
		//	deleteCookie
		,	deleteCookie:	function () { _.deleteCookie(inst); }
		//	saveCookie - optionally pass keys-list and cookie-options (hash)
		,	saveCookie:		function (keys, cookieOpts) { return _.saveCookie(inst, keys, cookieOpts); }
		//	loadCookie - readCookie and use to loadState() - returns hash of cookie data
		,	loadCookie:		function () { return _.loadCookie(inst); }
		//	loadState - pass a hash of state to use to update options
		,	loadState:		function (stateData, animate) { _.loadState(inst, stateData, animate); }
		//	readState - returns hash of current layout-state
		,	readState:		function (keys) { return _.readState(inst, keys); }
		//	add JSON utility methods too...
		,	encodeJSON:		_.encodeJSON
		,	decodeJSON:		_.decodeJSON
		});

		// init state.stateData key, even if plugin is initially disabled
		inst.state.stateData = {};

		// read and load cookie-data per options
		var oS = inst.options.stateManagement;
		if (oS.enabled) {
			if (oS.autoLoad) // update the options from the cookie
				inst.loadCookie();
			else // don't modify options - just store cookie data in state.stateData
				inst.state.stateData = inst.readCookie();
		}
	}

,	_unload: function (inst) {
		var oS = inst.options.stateManagement;
		if (oS.enabled) {
			if (oS.autoSave) // save a state-cookie automatically
				inst.saveCookie();
			else // don't save a cookie, but do store state-data in state.stateData key
				inst.state.stateData = inst.readState();
		}
	}

};

// add state initialization method to Layout's onCreate array of functions
$.layout.onCreate.push( $.layout.state._create );
$.layout.onUnload.push( $.layout.state._unload );




/**
 * jquery.layout.buttons 1.0
 * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
 *
 * Copyright (c) 2010 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @dependancies: UI Layout 1.3.0.rc30.1 or higher
 *
 * @support: http://groups.google.com/group/jquery-ui-layout
 *
 * Docs: [ to come ]
 * Tips: [ to come ]
 */

// tell Layout that the state plugin is available
$.layout.plugins.buttons = true;

//	Add buttons options to layout.defaults
$.layout.defaults.autoBindCustomButtons = false;
// Specify autoBindCustomButtons as a layout-option, NOT a pane-option
$.layout.optionsMap.layout.push("autoBindCustomButtons");

/*
 *	Button methods
 */
$.layout.buttons = {

	/**
	* Searches for .ui-layout-button-xxx elements and auto-binds them as layout-buttons
	*
	* @see  _create()
	*
	* @param  {Object}		inst	Layout Instance object
	*/
	init: function (inst) {
		var pre		= "ui-layout-button-"
		,	layout	= inst.options.name || ""
		,	name;
		$.each("toggle,open,close,pin,toggle-slide,open-slide".split(","), function (i, action) {
			$.each($.layout.config.borderPanes, function (ii, pane) {
				$("."+pre+action+"-"+pane).each(function(){
					// if button was previously 'bound', data.layoutName was set, but is blank if layout has no 'name'
					name = $(this).data("layoutName") || $(this).attr("layoutName");
					if (name == undefined || name === layout)
						inst.bindButton(this, action, pane);
				});
			});
		});
	}

	/**
	* Helper function to validate params received by addButton utilities
	*
	* Two classes are added to the element, based on the buttonClass...
	* The type of button is appended to create the 2nd className:
	*  - ui-layout-button-pin		// action btnClass
	*  - ui-layout-button-pin-west	// action btnClass + pane
	*  - ui-layout-button-toggle
	*  - ui-layout-button-open
	*  - ui-layout-button-close
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
	*
	* @return {Array.<Object>}	If both params valid, the element matching 'selector' in a jQuery wrapper - otherwise returns null
	*/
,	get: function (inst, selector, pane, action) {
		var $E	= $(selector)
		,	o	= inst.options
		,	err	= o.errors.addButtonError
		;
		if (!$E.length) { // element not found
			$.layout.msg(err +" "+ o.errors.selector +": "+ selector, true);
		}
		else if ($.inArray(pane, $.layout.config.borderPanes) < 0) { // invalid 'pane' sepecified
			$.layout.msg(err +" "+ o.errors.pane +": "+ pane, true);
			$E = $("");  // NO BUTTON
		}
		else { // VALID
			var btn = o[pane].buttonClass +"-"+ action;
			$E	.addClass( btn +" "+ btn +"-"+ pane )
				.data("layoutName", o.name); // add layout identifier - even if blank!
		}
		return $E;
	}


	/**
	* NEW syntax for binding layout-buttons - will eventually replace addToggle, addOpen, etc.
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}			action
	* @param {string}			pane
	*/
,	bind: function (inst, selector, action, pane) {
		var _ = $.layout.buttons;
		switch (action.toLowerCase()) {
			case "toggle":			_.addToggle	(inst, selector, pane); break;	
			case "open":			_.addOpen	(inst, selector, pane); break;
			case "close":			_.addClose	(inst, selector, pane); break;
			case "pin":				_.addPin	(inst, selector, pane); break;
			case "toggle-slide":	_.addToggle	(inst, selector, pane, true); break;	
			case "open-slide":		_.addOpen	(inst, selector, pane, true); break;
		}
		return inst;
	}

	/**
	* Add a custom Toggler button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}  			pane 		Name of the pane the button is for: 'north', 'south', etc.
	* @param {boolean=}			slide 		true = slide-open, false = pin-open
	*/
,	addToggle: function (inst, selector, pane, slide) {
		$.layout.buttons.get(inst, selector, pane, "toggle")
			.click(function(evt){
				inst.toggle(pane, !!slide);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Open button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}			pane 		Name of the pane the button is for: 'north', 'south', etc.
	* @param {boolean=}			slide 		true = slide-open, false = pin-open
	*/
,	addOpen: function (inst, selector, pane, slide) {
		$.layout.buttons.get(inst, selector, pane, "open")
			.attr("title", inst.options[pane].tips.Open)
			.click(function (evt) {
				inst.open(pane, !!slide);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Close button for a pane
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
	*/
,	addClose: function (inst, selector, pane) {
		$.layout.buttons.get(inst, selector, pane, "close")
			.attr("title", inst.options[pane].tips.Close)
			.click(function (evt) {
				inst.close(pane);
				evt.stopPropagation();
			});
		return inst;
	}

	/**
	* Add a custom Pin button for a pane
	*
	* Four classes are added to the element, based on the paneClass for the associated pane...
	* Assuming the default paneClass and the pin is 'up', these classes are added for a west-pane pin:
	*  - ui-layout-pane-pin
	*  - ui-layout-pane-west-pin
	*  - ui-layout-pane-pin-up
	*  - ui-layout-pane-west-pin-up
	*
	* @param {Object}			inst		Layout Instance object
	* @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
	* @param {string}   		pane 		Name of the pane the pin is for: 'north', 'south', etc.
	*/
,	addPin: function (inst, selector, pane) {
		var	_	= $.layout.buttons
		,	$E	= _.get(inst, selector, pane, "pin");
		if ($E.length) {
			var s = inst.state[pane];
			$E.click(function (evt) {
				_.setPinState(inst, $(this), pane, (s.isSliding || s.isClosed));
				if (s.isSliding || s.isClosed) inst.open( pane ); // change from sliding to open
				else inst.close( pane ); // slide-closed
				evt.stopPropagation();
			});
			// add up/down pin attributes and classes
			_.setPinState(inst, $E, pane, (!s.isClosed && !s.isSliding));
			// add this pin to the pane data so we can 'sync it' automatically
			// PANE.pins key is an array so we can store multiple pins for each pane
			s.pins.push( selector ); // just save the selector string
		}
		return inst;
	}

	/**
	* Change the class of the pin button to make it look 'up' or 'down'
	*
	* @see  addPin(), syncPins()
	*
	* @param {Object}			inst	Layout Instance object
	* @param {Array.<Object>}	$Pin	The pin-span element in a jQuery wrapper
	* @param {string}			pane	These are the params returned to callbacks by layout()
	* @param {boolean}			doPin	true = set the pin 'down', false = set it 'up'
	*/
,	setPinState: function (inst, $Pin, pane, doPin) {
		var updown = $Pin.attr("pin");
		if (updown && doPin === (updown=="down")) return; // already in correct state
		var
			o		= inst.options[pane]
		,	pin		= o.buttonClass +"-pin"
		,	side	= pin +"-"+ pane
		,	UP		= pin +"-up "+	side +"-up"
		,	DN		= pin +"-down "+side +"-down"
		;
		$Pin
			.attr("pin", doPin ? "down" : "up") // logic
			.attr("title", doPin ? o.tips.Unpin : o.tips.Pin)
			.removeClass( doPin ? UP : DN ) 
			.addClass( doPin ? DN : UP ) 
		;
	}

	/**
	* INTERNAL function to sync 'pin buttons' when pane is opened or closed
	* Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
	*
	* @see  open(), close()
	*
	* @param {Object}			inst	Layout Instance object
	* @param {string}	pane	These are the params returned to callbacks by layout()
	* @param {boolean}	doPin	True means set the pin 'down', False means 'up'
	*/
,	syncPinBtns: function (inst, pane, doPin) {
		// REAL METHOD IS _INSIDE_ LAYOUT - THIS IS HERE JUST FOR REFERENCE
		$.each(inst.state[pane].pins, function (i, selector) {
			$.layout.buttons.setPinState(inst, $(selector), pane, doPin);
		});
	}


,	_load: function (inst) {
		var	_	= $.layout.buttons;
		// ADD Button methods to Layout Instance
		// Note: sel = jQuery Selector string
		$.extend( inst, {
			bindButton:		function (sel, action, pane) { return _.bind(inst, sel, action, pane); }
		//	DEPRECATED METHODS
		,	addToggleBtn:	function (sel, pane, slide) { return _.addToggle(inst, sel, pane, slide); }
		,	addOpenBtn:		function (sel, pane, slide) { return _.addOpen(inst, sel, pane, slide); }
		,	addCloseBtn:	function (sel, pane) { return _.addClose(inst, sel, pane); }
		,	addPinBtn:		function (sel, pane) { return _.addPin(inst, sel, pane); }
		});

		// init state array to hold pin-buttons
		for (var i=0; i<4; i++) {
			var pane = $.layout.config.borderPanes[i];
			inst.state[pane].pins = [];
		}

		// auto-init buttons onLoad if option is enabled
		if ( inst.options.autoBindCustomButtons )
			_.init(inst);
	}

,	_unload: function (inst) {
		// TODO: unbind all buttons???
	}

};

// add initialization method to Layout's onLoad array of functions
$.layout.onLoad.push(  $.layout.buttons._load );
//$.layout.onUnload.push( $.layout.buttons._unload );



/**
 * jquery.layout.browserZoom 1.0
 * $Date: 2011-12-29 08:00:00 (Thu, 29 Dec 2011) $
 *
 * Copyright (c) 2012 
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * @dependancies: UI Layout 1.3.0.rc30.1 or higher
 *
 * @support: http://groups.google.com/group/jquery-ui-layout
 *
 * @todo: Extend logic to handle other problematic zooming in browsers
 * @todo: Add hotkey/mousewheel bindings to _instantly_ respond to these zoom event
 */

// tell Layout that the plugin is available
$.layout.plugins.browserZoom = true;

$.layout.defaults.browserZoomCheckInterval = 1000;
$.layout.optionsMap.layout.push("browserZoomCheckInterval");

/*
 *	browserZoom methods
 */
$.layout.browserZoom = {

	_init: function (inst) {
		// abort if browser does not need this check
		if ($.layout.browserZoom.ratio() !== false)
			$.layout.browserZoom._setTimer(inst);
	}

,	_setTimer: function (inst) {
		// abort if layout destroyed or browser does not need this check
		if (inst.destroyed) return;
		var o	= inst.options
		,	s	= inst.state
		//	don't need check if inst has parentLayout, but check occassionally in case parent destroyed!
		//	MINIMUM 100ms interval, for performance
		,	ms	= inst.hasParentLayout ?  5000 : Math.max( o.browserZoomCheckInterval, 100 )
		;
		// set the timer
		setTimeout(function(){
			if (inst.destroyed || !o.resizeWithWindow) return;
			var d = $.layout.browserZoom.ratio();
			if (d !== s.browserZoom) {
				s.browserZoom = d;
				inst.resizeAll();
			}
			// set a NEW timeout
			$.layout.browserZoom._setTimer(inst);
		}
		,	ms );
	}

,	ratio: function () {
		var w	= window
		,	s	= screen
		,	d	= document
		,	dE	= d.documentElement || d.body
		,	b	= $.layout.browser
		,	v	= b.version
		,	r, sW, cW
		;
		// we can ignore all browsers that fire window.resize event onZoom
		if ((b.msie && v > 8)
		||	!b.msie
		) return false; // don't need to track zoom

		if (s.deviceXDPI)
			return calc(s.deviceXDPI, s.systemXDPI);
		// everything below is just for future reference!
		if (b.webkit && (r = d.body.getBoundingClientRect))
			return calc((r.left - r.right), d.body.offsetWidth);
		if (b.webkit && (sW = w.outerWidth))
			return calc(sW, w.innerWidth);
		if ((sW = s.width) && (cW = dE.clientWidth))
			return calc(sW, cW);
		return false; // no match, so cannot - or don't need to - track zoom

		function calc (x,y) { return (parseInt(x,10) / parseInt(y,10) * 100).toFixed(); }
	}

};
// add initialization method to Layout's onLoad array of functions
$.layout.onReady.push( $.layout.browserZoom._init );



})( jQuery );
/* This notice must be untouched at all times.

wz_jsgraphics.js    v. 3.05
The latest version is available at
http://www.walterzorn.com
or http://www.devira.com
or http://www.walterzorn.de

Copyright (c) 2002-2009 Walter Zorn. All rights reserved.
Created 3. 11. 2002 by Walter Zorn (Web: http://www.walterzorn.com )
Last modified: 2. 2. 2009

Performance optimizations for Internet Explorer
by Thomas Frank and John Holdsworth.
fillPolygon method implemented by Matthieu Haller.

High Performance JavaScript Graphics Library.
Provides methods
- to draw lines, rectangles, ellipses, polygons
	with specifiable line thickness,
- to fill rectangles, polygons, ellipses and arcs
- to draw text.
NOTE: Operations, functions and branching have rather been optimized
to efficiency and speed than to shortness of source code.

LICENSE: LGPL

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License (LGPL) as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA,
or see http://www.gnu.org/copyleft/lesser.html
*/


var jg_ok, jg_ie, jg_fast, jg_dom, jg_moz;


function _chkDHTM(wnd, x, i)
// Under XUL, owner of 'document' must be specified explicitly
{
	x = wnd.document.body || null;
	jg_ie = x && typeof x.insertAdjacentHTML != "undefined" && wnd.document.createElement;
	jg_dom = (x && !jg_ie &&
		typeof x.appendChild != "undefined" &&
		typeof wnd.document.createRange != "undefined" &&
		typeof (i = wnd.document.createRange()).setStartBefore != "undefined" &&
		typeof i.createContextualFragment != "undefined");
	jg_fast = jg_ie && wnd.document.all && !wnd.opera;
	jg_moz = jg_dom && typeof x.style.MozOpacity != "undefined";
	jg_ok = !!(jg_ie || jg_dom);
}

function _pntCnvDom()
{
	var x = this.wnd.document.createRange();
	x.setStartBefore(this.cnv);
	x = x.createContextualFragment(jg_fast? this._htmRpc() : this.htm);
	if(this.cnv) this.cnv.appendChild(x);
	this.htm = "";
}

function _pntCnvIe()
{
	if(this.cnv) this.cnv.insertAdjacentHTML("BeforeEnd", jg_fast? this._htmRpc() : this.htm);
	this.htm = "";
}

function _pntDoc()
{
	this.wnd.document.write(jg_fast? this._htmRpc() : this.htm);
	this.htm = '';
}

function _pntN()
{
	;
}

function _mkDiv(x, y, w, h)
{
	this.htm += '<div style="position:absolute;'+
		'left:' + x + 'px;'+
		'top:' + y + 'px;'+
		'width:' + w + 'px;'+
		'height:' + h + 'px;'+
		'clip:rect(0,'+w+'px,'+h+'px,0);'+
		'background-color:' + this.color +
		(!jg_moz? ';overflow:hidden' : '')+
		';"><\/div>';
}

function _mkDivIe(x, y, w, h)
{
	this.htm += '%%'+this.color+';'+x+';'+y+';'+w+';'+h+';';
}

function _mkDivPrt(x, y, w, h)
{
	this.htm += '<div style="position:absolute;'+
		'border-left:' + w + 'px solid ' + this.color + ';'+
		'left:' + x + 'px;'+
		'top:' + y + 'px;'+
		'width:0px;'+
		'height:' + h + 'px;'+
		'clip:rect(0,'+w+'px,'+h+'px,0);'+
		'background-color:' + this.color +
		(!jg_moz? ';overflow:hidden' : '')+
		';"><\/div>';
}

var _regex =  /%%([^;]+);([^;]+);([^;]+);([^;]+);([^;]+);/g;
function _htmRpc()
{
	return this.htm.replace(
		_regex,
		'<div style="overflow:hidden;position:absolute;background-color:'+
		'$1;left:$2px;top:$3px;width:$4px;height:$5px"></div>\n');
}

function _htmPrtRpc()
{
	return this.htm.replace(
		_regex,
		'<div style="overflow:hidden;position:absolute;background-color:'+
		'$1;left:$2px;top:$3px;width:$4px;height:$5px;border-left:$4px solid $1"></div>\n');
}

function _mkLin(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1;

	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx,
		ox = x;
		while(dx > 0)
		{--dx;
			++x;
			if(p > 0)
			{
				this._mkDiv(ox, y, x-ox, 1);
				y += yIncr;
				p += pru;
				ox = x;
			}
			else p += pr;
		}
		this._mkDiv(ox, y, x2-ox+1, 1);
	}

	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy,
		oy = y;
		if(y2 <= y1)
		{
			while(dy > 0)
			{--dy;
				if(p > 0)
				{
					this._mkDiv(x++, y, 1, oy-y+1);
					y += yIncr;
					p += pru;
					oy = y;
				}
				else
				{
					y += yIncr;
					p += pr;
				}
			}
			this._mkDiv(x2, y2, 1, oy-y2+1);
		}
		else
		{
			while(dy > 0)
			{--dy;
				y += yIncr;
				if(p > 0)
				{
					this._mkDiv(x++, oy, 1, y-oy);
					p += pru;
					oy = y;
				}
				else p += pr;
			}
			this._mkDiv(x2, oy, 1, y2-oy+1);
		}
	}
}

function _mkLin2D(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1;

	var s = this.stroke;
	if(dx >= dy)
	{
		if(dx > 0 && s-3 > 0)
		{
			var _s = (s*dx*Math.sqrt(1+dy*dy/(dx*dx))-dx-(s>>1)*dy) / dx;
			_s = (!(s-4)? Math.ceil(_s) : Math.round(_s)) + 1;
		}
		else var _s = s;
		var ad = Math.ceil(s/2);

		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx,
		ox = x;
		while(dx > 0)
		{--dx;
			++x;
			if(p > 0)
			{
				this._mkDiv(ox, y, x-ox+ad, _s);
				y += yIncr;
				p += pru;
				ox = x;
			}
			else p += pr;
		}
		this._mkDiv(ox, y, x2-ox+ad+1, _s);
	}

	else
	{
		if(s-3 > 0)
		{
			var _s = (s*dy*Math.sqrt(1+dx*dx/(dy*dy))-(s>>1)*dx-dy) / dy;
			_s = (!(s-4)? Math.ceil(_s) : Math.round(_s)) + 1;
		}
		else var _s = s;
		var ad = Math.round(s/2);

		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy,
		oy = y;
		if(y2 <= y1)
		{
			++ad;
			while(dy > 0)
			{--dy;
				if(p > 0)
				{
					this._mkDiv(x++, y, _s, oy-y+ad);
					y += yIncr;
					p += pru;
					oy = y;
				}
				else
				{
					y += yIncr;
					p += pr;
				}
			}
			this._mkDiv(x2, y2, _s, oy-y2+ad);
		}
		else
		{
			while(dy > 0)
			{--dy;
				y += yIncr;
				if(p > 0)
				{
					this._mkDiv(x++, oy, _s, y-oy+ad);
					p += pru;
					oy = y;
				}
				else p += pr;
			}
			this._mkDiv(x2, oy, _s, y2-oy+ad+1);
		}
	}
}

function _mkLinDott(x1, y1, x2, y2)
{
	if(x1 > x2)
	{
		var _x2 = x2;
		var _y2 = y2;
		x2 = x1;
		y2 = y1;
		x1 = _x2;
		y1 = _y2;
	}
	var dx = x2-x1, dy = Math.abs(y2-y1),
	x = x1, y = y1,
	yIncr = (y1 > y2)? -1 : 1,
	drw = true;
	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1),
		p = pr-dx;
		while(dx > 0)
		{--dx;
			if(drw) this._mkDiv(x, y, 1, 1);
			drw = !drw;
			if(p > 0)
			{
				y += yIncr;
				p += pru;
			}
			else p += pr;
			++x;
		}
	}
	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1),
		p = pr-dy;
		while(dy > 0)
		{--dy;
			if(drw) this._mkDiv(x, y, 1, 1);
			drw = !drw;
			y += yIncr;
			if(p > 0)
			{
				++x;
				p += pru;
			}
			else p += pr;
		}
	}
	if(drw) this._mkDiv(x, y, 1, 1);
}

function _mkOv(left, top, width, height)
{
	var a = (++width)>>1, b = (++height)>>1,
	wod = width&1, hod = height&1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	ox = 0, oy = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1),
	w, h;
	while(y > 0)
	{
		if(st < 0)
		{
			st += bb2*((x<<1)+3);
			tt += bb4*(++x);
		}
		else if(tt < 0)
		{
			st += bb2*((x<<1)+3) - aa4*(y-1);
			tt += bb4*(++x) - aa2*(((y--)<<1)-3);
			w = x-ox;
			h = oy-y;
			if((w&2) && (h&2))
			{
				this._mkOvQds(cx, cy, x-2, y+2, 1, 1, wod, hod);
				this._mkOvQds(cx, cy, x-1, y+1, 1, 1, wod, hod);
			}
			else this._mkOvQds(cx, cy, x-1, oy, w, h, wod, hod);
			ox = x;
			oy = y;
		}
		else
		{
			tt -= aa2*((y<<1)-3);
			st -= aa4*(--y);
		}
	}
	w = a-ox+1;
	h = (oy<<1)+hod;
	y = cy-oy;
	this._mkDiv(cx-a, y, w, h);
	this._mkDiv(cx+ox+wod-1, y, w, h);
}

function _mkOv2D(left, top, width, height)
{
	var s = this.stroke;
	width += s+1;
	height += s+1;
	var a = width>>1, b = height>>1,
	wod = width&1, hod = height&1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1);

	if(s-4 < 0 && (!(s-2) || width-51 > 0 && height-51 > 0))
	{
		var ox = 0, oy = b,
		w, h,
		pxw;
		while(y > 0)
		{
			if(st < 0)
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				w = x-ox;
				h = oy-y;

				if(w-1)
				{
					pxw = w+1+(s&1);
					h = s;
				}
				else if(h-1)
				{
					pxw = s;
					h += 1+(s&1);
				}
				else pxw = h = s;
				this._mkOvQds(cx, cy, x-1, oy, pxw, h, wod, hod);
				ox = x;
				oy = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}
		}
		this._mkDiv(cx-a, cy-oy, s, (oy<<1)+hod);
		this._mkDiv(cx+a+wod-s, cy-oy, s, (oy<<1)+hod);
	}

	else
	{
		var _a = (width-(s<<1))>>1,
		_b = (height-(s<<1))>>1,
		_x = 0, _y = _b,
		_aa2 = (_a*_a)<<1, _aa4 = _aa2<<1, _bb2 = (_b*_b)<<1, _bb4 = _bb2<<1,
		_st = (_aa2>>1)*(1-(_b<<1)) + _bb2,
		_tt = (_bb2>>1) - _aa2*((_b<<1)-1),

		pxl = new Array(),
		pxt = new Array(),
		_pxb = new Array();
		pxl[0] = 0;
		pxt[0] = b;
		_pxb[0] = _b-1;
		while(y > 0)
		{
			if(st < 0)
			{
				pxl[pxl.length] = x;
				pxt[pxt.length] = y;
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				pxl[pxl.length] = x;
				st += bb2*((x<<1)+3) - aa4*(y-1);
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				pxt[pxt.length] = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}

			if(_y > 0)
			{
				if(_st < 0)
				{
					_st += _bb2*((_x<<1)+3);
					_tt += _bb4*(++_x);
					_pxb[_pxb.length] = _y-1;
				}
				else if(_tt < 0)
				{
					_st += _bb2*((_x<<1)+3) - _aa4*(_y-1);
					_tt += _bb4*(++_x) - _aa2*(((_y--)<<1)-3);
					_pxb[_pxb.length] = _y-1;
				}
				else
				{
					_tt -= _aa2*((_y<<1)-3);
					_st -= _aa4*(--_y);
					_pxb[_pxb.length-1]--;
				}
			}
		}

		var ox = -wod, oy = b,
		_oy = _pxb[0],
		l = pxl.length,
		w, h;
		for(var i = 0; i < l; i++)
		{
			if(typeof _pxb[i] != "undefined")
			{
				if(_pxb[i] < _oy || pxt[i] < oy)
				{
					x = pxl[i];
					this._mkOvQds(cx, cy, x, oy, x-ox, oy-_oy, wod, hod);
					ox = x;
					oy = pxt[i];
					_oy = _pxb[i];
				}
			}
			else
			{
				x = pxl[i];
				this._mkDiv(cx-x, cy-oy, 1, (oy<<1)+hod);
				this._mkDiv(cx+ox+wod, cy-oy, 1, (oy<<1)+hod);
				ox = x;
				oy = pxt[i];
			}
		}
		this._mkDiv(cx-a, cy-oy, 1, (oy<<1)+hod);
		this._mkDiv(cx+ox+wod, cy-oy, 1, (oy<<1)+hod);
	}
}

function _mkOvDott(left, top, width, height)
{
	var a = (++width)>>1, b = (++height)>>1,
	wod = width&1, hod = height&1, hodu = hod^1,
	cx = left+a, cy = top+b,
	x = 0, y = b,
	aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
	st = (aa2>>1)*(1-(b<<1)) + bb2,
	tt = (bb2>>1) - aa2*((b<<1)-1),
	drw = true;
	while(y > 0)
	{
		if(st < 0)
		{
			st += bb2*((x<<1)+3);
			tt += bb4*(++x);
		}
		else if(tt < 0)
		{
			st += bb2*((x<<1)+3) - aa4*(y-1);
			tt += bb4*(++x) - aa2*(((y--)<<1)-3);
		}
		else
		{
			tt -= aa2*((y<<1)-3);
			st -= aa4*(--y);
		}
		if(drw && y >= hodu) this._mkOvQds(cx, cy, x, y, 1, 1, wod, hod);
		drw = !drw;
	}
}

function _mkRect(x, y, w, h)
{
	var s = this.stroke;
	this._mkDiv(x, y, w, s);
	this._mkDiv(x+w, y, s, h);
	this._mkDiv(x, y+h, w+s, s);
	this._mkDiv(x, y+s, s, h-s);
}

function _mkRectDott(x, y, w, h)
{
	this.drawLine(x, y, x+w, y);
	this.drawLine(x+w, y, x+w, y+h);
	this.drawLine(x, y+h, x+w, y+h);
	this.drawLine(x, y, x, y+h);
}

function jsgFont()
{
	this.PLAIN = 'font-weight:normal;';
	this.BOLD = 'font-weight:bold;';
	this.ITALIC = 'font-style:italic;';
	this.ITALIC_BOLD = this.ITALIC + this.BOLD;
	this.BOLD_ITALIC = this.ITALIC_BOLD;
}
var Font = new jsgFont();

function jsgStroke()
{
	this.DOTTED = -1;
}
var Stroke = new jsgStroke();

function JSGraphics(cnv, wnd)
{
	this.setColor = function(x)
	{
		this.color = x.toLowerCase();
	};

	this.setStroke = function(x)
	{
		this.stroke = x;
		if(!(x+1))
		{
			this.drawLine = _mkLinDott;
			this._mkOv = _mkOvDott;
			this.drawRect = _mkRectDott;
		}
		else if(x-1 > 0)
		{
			this.drawLine = _mkLin2D;
			this._mkOv = _mkOv2D;
			this.drawRect = _mkRect;
		}
		else
		{
			this.drawLine = _mkLin;
			this._mkOv = _mkOv;
			this.drawRect = _mkRect;
		}
	};

	this.setPrintable = function(arg)
	{
		this.printable = arg;
		if(jg_fast)
		{
			this._mkDiv = _mkDivIe;
			this._htmRpc = arg? _htmPrtRpc : _htmRpc;
		}
		else this._mkDiv = arg? _mkDivPrt : _mkDiv;
	};

	this.setFont = function(fam, sz, sty)
	{
		this.ftFam = fam;
		this.ftSz = sz;
		this.ftSty = sty || Font.PLAIN;
	};

	this.drawPolyline = this.drawPolyLine = function(x, y)
	{
		for (var i=x.length - 1; i;)
		{--i;
			this.drawLine(x[i], y[i], x[i+1], y[i+1]);
		}
	};

	this.fillRect = function(x, y, w, h)
	{
		this._mkDiv(x, y, w, h);
	};

	this.drawPolygon = function(x, y)
	{
		this.drawPolyline(x, y);
		this.drawLine(x[x.length-1], y[x.length-1], x[0], y[0]);
	};

	this.drawEllipse = this.drawOval = function(x, y, w, h)
	{
		this._mkOv(x, y, w, h);
	};

	this.fillEllipse = this.fillOval = function(left, top, w, h)
	{
		var a = w>>1, b = h>>1,
		wod = w&1, hod = h&1,
		cx = left+a, cy = top+b,
		x = 0, y = b, oy = b,
		aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
		st = (aa2>>1)*(1-(b<<1)) + bb2,
		tt = (bb2>>1) - aa2*((b<<1)-1),
		xl, dw, dh;
		if(w) while(y > 0)
		{
			if(st < 0)
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0)
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				xl = cx-x;
				dw = (x<<1)+wod;
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				dh = oy-y;
				this._mkDiv(xl, cy-oy, dw, dh);
				this._mkDiv(xl, cy+y+hod, dw, dh);
				oy = y;
			}
			else
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
			}
		}
		this._mkDiv(cx-a, cy-oy, w, (oy<<1)+hod);
	};

	this.fillArc = function(iL, iT, iW, iH, fAngA, fAngZ)
	{
		var a = iW>>1, b = iH>>1,
		iOdds = (iW&1) | ((iH&1) << 16),
		cx = iL+a, cy = iT+b,
		x = 0, y = b, ox = x, oy = y,
		aa2 = (a*a)<<1, aa4 = aa2<<1, bb2 = (b*b)<<1, bb4 = bb2<<1,
		st = (aa2>>1)*(1-(b<<1)) + bb2,
		tt = (bb2>>1) - aa2*((b<<1)-1),
		// Vars for radial boundary lines
		xEndA, yEndA, xEndZ, yEndZ,
		iSects = (1 << (Math.floor((fAngA %= 360.0)/180.0) << 3))
				| (2 << (Math.floor((fAngZ %= 360.0)/180.0) << 3))
				| ((fAngA >= fAngZ) << 16),
		aBndA = new Array(b+1), aBndZ = new Array(b+1);
		
		// Set up radial boundary lines
		fAngA *= Math.PI/180.0;
		fAngZ *= Math.PI/180.0;
		xEndA = cx+Math.round(a*Math.cos(fAngA));
		yEndA = cy+Math.round(-b*Math.sin(fAngA));
		_mkLinVirt(aBndA, cx, cy, xEndA, yEndA);
		xEndZ = cx+Math.round(a*Math.cos(fAngZ));
		yEndZ = cy+Math.round(-b*Math.sin(fAngZ));
		_mkLinVirt(aBndZ, cx, cy, xEndZ, yEndZ);

		while(y > 0)
		{
			if(st < 0) // Advance x
			{
				st += bb2*((x<<1)+3);
				tt += bb4*(++x);
			}
			else if(tt < 0) // Advance x and y
			{
				st += bb2*((x<<1)+3) - aa4*(y-1);
				ox = x;
				tt += bb4*(++x) - aa2*(((y--)<<1)-3);
				this._mkArcDiv(ox, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
				oy = y;
			}
			else // Advance y
			{
				tt -= aa2*((y<<1)-3);
				st -= aa4*(--y);
				if(y && (aBndA[y] != aBndA[y-1] || aBndZ[y] != aBndZ[y-1]))
				{
					this._mkArcDiv(x, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
					ox = x;
					oy = y;
				}
			}
		}
		this._mkArcDiv(x, 0, oy, cx, cy, iOdds, aBndA, aBndZ, iSects);
		if(iOdds >> 16) // Odd height
		{
			if(iSects >> 16) // Start-angle > end-angle
			{
				var xl = (yEndA <= cy || yEndZ > cy)? (cx - x) : cx;
				this._mkDiv(xl, cy, x + cx - xl + (iOdds & 0xffff), 1);
			}
			else if((iSects & 0x01) && yEndZ > cy)
				this._mkDiv(cx - x, cy, x, 1);
		}
	};

    this.drawArc = function(cx, cy, radius, startAngle, endAngle, step)
    {
        var x,
            y,
            angle = startAngle;

        if (!step) {
            step = 10;
        }

        while (Math.abs(angle - endAngle) > 1e-5) {
            angle = (angle + step) % 360;
            x = cx + radius * Math.cos(angle * Geometry.pi / 180.0);
            y = cy + radius * Math.sin(angle * Geometry.pi / 180.0);
            this.drawLine(x, y, x, y);
        }
        //alert(cnt);
    };

/* fillPolygon method, implemented by Matthieu Haller.
This javascript function is an adaptation of the gdImageFilledPolygon for Walter Zorn lib.
C source of GD 1.8.4 found at http://www.boutell.com/gd/

THANKS to Kirsten Schulz for the polygon fixes!

The intersection finding technique of this code could be improved
by remembering the previous intertersection, and by using the slope.
That could help to adjust intersections to produce a nice
interior_extrema. */
	this.fillPolygon = function(array_x, array_y)
	{
		var i;
		var y;
		var miny, maxy;
		var x1, y1;
		var x2, y2;
		var ind1, ind2;
		var ints;

		var n = array_x.length;
		if(!n) return;

		miny = array_y[0];
		maxy = array_y[0];
		for(i = 1; i < n; i++)
		{
			if(array_y[i] < miny)
				miny = array_y[i];

			if(array_y[i] > maxy)
				maxy = array_y[i];
		}
		for(y = miny; y <= maxy; y++)
		{
			var polyInts = new Array();
			ints = 0;
			for(i = 0; i < n; i++)
			{
				if(!i)
				{
					ind1 = n-1;
					ind2 = 0;
				}
				else
				{
					ind1 = i-1;
					ind2 = i;
				}
				y1 = array_y[ind1];
				y2 = array_y[ind2];
				if(y1 < y2)
				{
					x1 = array_x[ind1];
					x2 = array_x[ind2];
				}
				else if(y1 > y2)
				{
					y2 = array_y[ind1];
					y1 = array_y[ind2];
					x2 = array_x[ind1];
					x1 = array_x[ind2];
				}
				else continue;

				 //  Modified 11. 2. 2004 Walter Zorn
				if((y >= y1) && (y < y2))
					polyInts[ints++] = Math.round((y-y1) * (x2-x1) / (y2-y1) + x1);

				else if((y == maxy) && (y > y1) && (y <= y2))
					polyInts[ints++] = Math.round((y-y1) * (x2-x1) / (y2-y1) + x1);
			}
			polyInts.sort(_CompInt);
			for(i = 0; i < ints; i+=2)
				this._mkDiv(polyInts[i], y, polyInts[i+1]-polyInts[i]+1, 1);
		}
	};

	this.drawString = function(txt, x, y)
	{
		this.htm += '<div style="position:absolute;white-space:nowrap;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			'font-family:' +  this.ftFam + ';'+
			'font-size:' + this.ftSz + ';'+
			'color:' + this.color + ';' + this.ftSty + '">'+
			txt +
			'<\/div>';
	};

/* drawStringRect() added by Rick Blommers.
Allows to specify the size of the text rectangle and to align the
text both horizontally (e.g. right) and vertically within that rectangle */
	this.drawStringRect = function(txt, x, y, width, halign)
	{
		this.htm += '<div style="position:absolute;overflow:hidden;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			'width:'+width +'px;'+
			'text-align:'+halign+';'+
			'font-family:' +  this.ftFam + ';'+
			'font-size:' + this.ftSz + ';'+
			'color:' + this.color + ';' + this.ftSty + '">'+
			txt +
			'<\/div>';
	};

	this.drawImage = function(imgSrc, x, y, w, h, a)
	{
		this.htm += '<div style="position:absolute;'+
			'left:' + x + 'px;'+
			'top:' + y + 'px;'+
			// w (width) and h (height) arguments are now optional.
			// Added by Mahmut Keygubatli, 14.1.2008
			(w? ('width:' +  w + 'px;') : '') +
			(h? ('height:' + h + 'px;'):'')+'">'+
			'<img src="' + imgSrc +'"'+ (w ? (' width="' + w + '"'):'')+ (h ? (' height="' + h + '"'):'') + (a? (' '+a) : '') + '>'+
			'<\/div>';
	};

	this.clear = function()
	{
		this.htm = "";
		if(this.cnv) this.cnv.innerHTML = "";
	};

	this._mkOvQds = function(cx, cy, x, y, w, h, wod, hod)
	{
		var xl = cx - x, xr = cx + x + wod - w, yt = cy - y, yb = cy + y + hod - h;
		if(xr > xl+w)
		{
			this._mkDiv(xr, yt, w, h);
			this._mkDiv(xr, yb, w, h);
		}
		else
			w = xr - xl + w;
		this._mkDiv(xl, yt, w, h);
		this._mkDiv(xl, yb, w, h);
	};
	
	this._mkArcDiv = function(x, y, oy, cx, cy, iOdds, aBndA, aBndZ, iSects)
	{
		var xrDef = cx + x + (iOdds & 0xffff), y2, h = oy - y, xl, xr, w;

		if(!h) h = 1;
		x = cx - x;

		if(iSects & 0xff0000) // Start-angle > end-angle
		{
			y2 = cy - y - h;
			if(iSects & 0x00ff)
			{
				if(iSects & 0x02)
				{
					xl = Math.max(x, aBndZ[y]);
					w = xrDef - xl;
					if(w > 0) this._mkDiv(xl, y2, w, h);
				}
				if(iSects & 0x01)
				{
					xr = Math.min(xrDef, aBndA[y]);
					w = xr - x;
					if(w > 0) this._mkDiv(x, y2, w, h);
				}
			}
			else
				this._mkDiv(x, y2, xrDef - x, h);
			y2 = cy + y + (iOdds >> 16);
			if(iSects & 0xff00)
			{
				if(iSects & 0x0100)
				{
					xl = Math.max(x, aBndA[y]);
					w = xrDef - xl;
					if(w > 0) this._mkDiv(xl, y2, w, h);
				}
				if(iSects & 0x0200)
				{
					xr = Math.min(xrDef, aBndZ[y]);
					w = xr - x;
					if(w > 0) this._mkDiv(x, y2, w, h);
				}
			}
			else
				this._mkDiv(x, y2, xrDef - x, h);
		}
		else
		{
			if(iSects & 0x00ff)
			{
				if(iSects & 0x02)
					xl = Math.max(x, aBndZ[y]);
				else
					xl = x;
				if(iSects & 0x01)
					xr = Math.min(xrDef, aBndA[y]);
				else
					xr = xrDef;
				y2 = cy - y - h;
				w = xr - xl;
				if(w > 0) this._mkDiv(xl, y2, w, h);
			}
			if(iSects & 0xff00)
			{
				if(iSects & 0x0100)
					xl = Math.max(x, aBndA[y]);
				else
					xl = x;
				if(iSects & 0x0200)
					xr = Math.min(xrDef, aBndZ[y]);
				else
					xr = xrDef;
				y2 = cy + y + (iOdds >> 16);
				w = xr - xl;
				if(w > 0) this._mkDiv(xl, y2, w, h);
			}
		}
	};

	this.setStroke(1);
	this.setFont("verdana,geneva,helvetica,sans-serif", "12px", Font.PLAIN);
	this.color = "#000000";
	this.htm = "";
	this.wnd = wnd || window;

	if(!jg_ok) _chkDHTM(this.wnd);
    if(jg_ok)
	{
		if(cnv)
		{
			if(typeof(cnv) == "string")
				this.cont = document.all? (this.wnd.document.all[cnv] || null)
					: document.getElementById? (this.wnd.document.getElementById(cnv) || null)
					: null;
			else if(cnv == window.document)
				this.cont = document.getElementsByTagName("body")[0];
			// If cnv is a direct reference to a canvas DOM node
			// (option suggested by Andreas Luleich)
			else this.cont = cnv;
			// Create new canvas inside container DIV. Thus the drawing and clearing
			// methods won't interfere with the container's inner html.
			// Solution suggested by Vladimir.
			this.cnv = this.wnd.document.createElement("div");
			this.cnv.style.fontSize=0;
			this.cont.appendChild(this.cnv);
			this.paint = jg_dom? _pntCnvDom : _pntCnvIe;
		}
		else
			this.paint = _pntDoc;
	}
	else
		this.paint = _pntN;

	this.setPrintable(false);
}

function _mkLinVirt(aLin, x1, y1, x2, y2)
{
	var dx = Math.abs(x2-x1), dy = Math.abs(y2-y1),
	x = x1, y = y1,
	xIncr = (x1 > x2)? -1 : 1,
	yIncr = (y1 > y2)? -1 : 1,
	p,
	i = 0;
	if(dx >= dy)
	{
		var pr = dy<<1,
		pru = pr - (dx<<1);
		p = pr-dx;
		while(dx > 0)
		{--dx;
			if(p > 0)    //  Increment y
			{
				aLin[i++] = x;
				y += yIncr;
				p += pru;
			}
			else p += pr;
			x += xIncr;
		}
	}
	else
	{
		var pr = dx<<1,
		pru = pr - (dy<<1);
		p = pr-dy;
		while(dy > 0)
		{--dy;
			y += yIncr;
			aLin[i++] = x;
			if(p > 0)    //  Increment x
			{
				x += xIncr;
				p += pru;
			}
			else p += pr;
		}
	}
	for(var len = aLin.length, i = len-i; i;)
		aLin[len-(i--)] = x;
};

function _CompInt(x, y)
{
	return(x - y);
}


var jCore = (function ($, window) {

    var isCtrl = false,             // if the control key is pressed
        isShift = false,            // if the shift key is pressed
        activeCanvas = null,        // pointer to the active canvas
        ArrayList,
        Point,
        Geometry,
        Graphics,
        Utils,
        Command,
        CommandStack,
        CommandResize,
        CommandConnect,
        CommandReconnect,
        CommandSegmentMove,
        CommandMove,
        CommandCreate,
        CommandSwitchContainer,
        CommandDelete,
        CommandPaste,
        CommandEditLabel,
        ContainerBehavior,
        RegularContainerBehavior,
        NoContainerBehavior,
        DragBehavior,
        RegularDragBehavior,
        NoDragBehavior,
        ConnectionDragBehavior,
        CustomShapeDragBehavior,
        ResizeBehavior,
        RegularResizeBehavior,
        NoResizeBehavior,
        DropBehavior,
        ConnectionDropBehavior,
        NoDropBehavior,
        ContainerDropBehavior,
        ConnectionContainerDropBehavior,
        Color,
        Style,
        JCoreObject,
        Handler,
        ReadOnlyLayer,
        ResizeHandler,
        SegmentMoveHandler,
        Port,
        Router,
        ManhattanConnectionRouter,
        ConnectionDecorator,
        Connection,
        BehavioralElement,
        Layer,
        Shape,
        Label,
        CustomShape,
        Segment,
        RegularShape,
        Polygon,
        Rectangle,
        Oval,
        Arc,
        MultipleSelectionContainer,
        Intersection,
        Snapper,
        Canvas,
        version = '0.2.0';  //jCore Version

/**
 * @class ArrayList
 * Construct a List similar to Java's ArrayList that encapsulates methods for
 * making a list that supports operations like get, insert and others.
 *
 *      some examples:
 *      var item,
 *          arrayList = new ArrayList();
 *      arrayList.getSize()                 // 0
 *      arrayList.insert({                  // insert an object
 *          id: 100,
 *          width: 100,
 *          height: 100
 *      });
 *      arrayList.getSize();                // 1
 *      arrayList.asArray();                // [{id : 100, ...}]
 *      item = arrayList.find('id', 100);   // finds the first element with an id that equals 100
 *      arrayList.remove(item);             // remove item from the arrayList
 *      arrayList.getSize();                // 0
 *      arrayList.isEmpty();                // true because the arrayList has no elements
 *
 * @constructor Returns an instance of the class ArrayList
 */
ArrayList = function () {
    /**
     * The elements of the arrayList
     * @property {Array}
     * @private
     */
    var elements = [],
        /**
         * The size of the array
         * @property {number} [size=0]
         * @private
         */
        size = 0,
        index,
        i;
    return {

        /**
         * The ID of this ArrayList is generated using the function Math.random
         * @property {number} id
         */
        id: Math.random(),
        /**
         * Gets an element in the specified index or undefined if the index
         * is not present in the array
         * @param {number} index
         * @returns {Object / undefined}
         */
        get : function (index) {
            return elements[index];
        },
        /**
         * Inserts an element at the end of the list
         * @param {Object}
         * @chainable
         */
        insert : function (item) {
            elements[size] = item;
            size += 1;
            return this;
        },
        /**
         * Removes an item from the list
         * @param {Object} item
         * @return {boolean}
         */
        remove : function (item) {
            index = this.indexOf(item);
            if (index === -1) {
                return false;
            }
            //swap(elements[index], elements[size-1]);
            size -= 1;
            elements.splice(index, 1);
            return true;
        },
        /**
         * Gets the length of the list
         * @return {number}
         */
        getSize : function () {
            return size;
        },
        /**
         * Returns true if the list is empty
         * @returns {boolean}
         */
        isEmpty : function () {
            return size === 0;
        },
        /**
         * Returns the first occurrence of an element, if the element is not
         * contained in the list then returns -1
         * @param {Object} item
         * @return {number}
         */
        indexOf : function (item) {
            for (i = 0; i < size; i += 1) {
                if (item.id === elements[i].id) {
                    return i;
                }
            }
            return -1;
        },
        /**
         * Returns the the first object of the list that has the
         * specified attribute with the specified value
         * if the object is not found it returns undefined
         * @param {string} attribute
         * @param {string} value
         * @return {Object / undefined}
         */
        find : function (attribute, value) {
            var i,
                current;
            for (i = 0; i < elements.length; i += 1) {
                current = elements[i];
                if (current[attribute] === value) {
                    return current;
                }
            }
            return undefined;
        },

        /**
         * Returns true if the list contains the item and false otherwise
         * @param {Object} item
         * @return {boolean}
         */
        contains : function (item) {
            if (this.indexOf(item) !== -1) {
                return true;
            }
            return false;
        },
        /**
         * Sorts the list using compFunction if possible, if no compFunction
         * is passed as an parameter then it returns false (the list is not sorted)
         * @param {Function} compFunction
         * @return {boolean}
         */
        sort : function (compFunction) {
            var returnValue = false;
            if (compFunction) {
                elements.sort(compFunction);
                returnValue = true;
            }
            return returnValue;
        },
        /**
         * Returns the list as an array
         * @return {Array}
         */
        asArray : function () {
            return elements;
        },
        /**
         * Returns the first element of the list
         * @return {Object}
         */
        getFirst : function () {
            return elements[0];
        },
        /**
         * Returns the last element of the list
         * @return {Object}
         */
        getLast : function () {
            return elements[size - 1];
        },

        /**
         * Returns the last element of the list and deletes it from the list
         * @return {Object}
         */
        popLast : function () {
            var lastElement;
            size -= 1;
            lastElement = elements[size];
            elements.splice(size, 1);
            return lastElement;
        },
        /**
         * Returns an array with the objects that determine the minimum size
         * the container should have
         * The array values are in this order TOP, RIGHT, BOTTOM AND LEFT
         * @return {Array}
         */
        getDimensionLimit : function () {
            var result = [100000, -1, -1, 100000],
                objects = [undefined, undefined, undefined, undefined];
            //number of pixels we want the inner shapes to be
            //apart from the border

            for (i = 0; i < size; i += 1) {
                if (result[0] > elements[i].y) {
                    result[0] = elements[i].y;
                    objects[0] = elements[i];

                }
                if (result[1] < elements[i].x + elements[i].width) {
                    result[1] = elements[i].x + elements[i].width;
                    objects[1] = elements[i];
                }
                if (result[2] < elements[i].y + elements[i].height) {
                    result[2] = elements[i].y + elements[i].height;
                    objects[2] = elements[i];
                }
                if (result[3] > elements[i].x) {
                    result[3] = elements[i].x;
                    objects[3] = elements[i];
                }
            }
            return result;
        },
        /**
         * Clears the content of the arrayList
         * @chainable
         */
        clear : function () {
            if (size !== 0) {
                elements = [];
                size = 0;
            }
            return this;
        },
        /**
         * Returns the canvas of an element if possible
         * @return {Canvas / undefined}
         */
        getCanvas : function () {
            return (this.getSize() > 0) ? this.get(0).getCanvas() : undefined;
        }
    };
};

// Declarations created to instantiate in NodeJS environment
if (typeof exports !== 'undefined') {
    module.exports = ArrayList;
//    var _ = require('../../lib/underscore/underscore.js');
}

/**
 * @class Point
 * Class to represent points in the jCore library
 *
 *        // i.e.
 *        var p = new Point(100, 100);
 *
 * @constructor Creates an instance of this class
 * @param {number} xCoordinate x-coordinate of the point
 * @param {number} yCoordinate y-coordinate of the point
 * @return {Point}
 */
Point = function (xCoordinate, yCoordinate) {
    /**
     * x coordinate of the point in the plane
     */
    this.x = xCoordinate;
    /**
     * y coordinate of the point in the plane
     */
    this.y = yCoordinate;
};

/**
 * Type of this class
 * @property {String}
 */
Point.prototype.type = "Point";

/**
 * Returns the X coordinate
 * @property {number}
 **/
Point.prototype.getX = function () {
    return this.x;
};

/**
 * Returns the Y coordinate
 * @property {number}
 **/
Point.prototype.getY = function () {
    return this.y;
};

/**
 * Adds `other` point to `this` point and returns a new point with those coordinates.
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3);
 *      p1.add(p2);     // new Point(5, 8)
 *
 * @param {Point} other Point to be added to the current point
 * @returns {Point}
 */
Point.prototype.add = function (other) {
    return new Point(this.x + other.x, this.y + other.y);
};

/**
 * Subtracts the other point to the one that called the function.
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3);
 *      p1.subtract(p2);     // new Point(1, 2)
 *
 * @param {Point} other Point to be added to the current point
 * @returns {Point}
 */
Point.prototype.subtract = function (other) {
    return new Point(this.x - other.x, this.y - other.y);
};

/**
 * Multiplies the point with a scalar k.
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          k = 3;
 *      p1.multiply(k);     // new Point(9, 15)
 *
 * @param {number} k
 * @return {Point}
 */
Point.prototype.multiply = function (k) {
    return new Point(this.x * k, this.y * k);
};

/**
 * Determine if the points are equal.
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3),
 *          p3 = new Point(3, 5);
 *      p1.equals(p2);     // false
 *      p1.equals(p3);     // true
 *      p1.equals(p1);     // true
 *
 * @param {Point} other Point to be compared with the current point
 * @returns {boolean}
 */
Point.prototype.equals = function (other) {
    return (Math.abs(this.x - other.x) < Geometry.eps) &&
            (Math.abs(this.y - other.y) < Geometry.eps);
};

/**
 * Determine the distance between two Points
 *
 *      // i.e.
 *      // distance = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3);
 *      p1.getDistance(p2);         // sqrt(1 + 4)
 *
 * @param {Point} other Point to be calculated from current point
 * @returns {number}
 **/
Point.prototype.getDistance = function (other) {
    return Math.sqrt(
        (this.x - other.x) * (this.x - other.x) +
            (this.y - other.y) * (this.y - other.y)
    );
};

/**
 * Determine the squared distance between two Points
 *
 *      // i.e.
 *      // distance = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))
 *      // but since it's the squared distance then
 *      // distance = pow(distance, 2)
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3);
 *      p1.getSquaredDistance(p2);         // (1 + 4)
 *
 * @param {Point} other Point to be calculated from current point
 * @returns {number}
 **/
Point.prototype.getSquaredDistance = function (other) {
    return (this.x - other.x) * (this.x - other.x) +
        (this.y - other.y) * (this.y - other.y);
};

/**
 * Determine the manhattan distance between two Points
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          p2 = new Point(2, 3);
 *      p1.getManhattanDistance(p2);         // (1 + 2)
 *
 * @param {Point} other Point to be calculated from current point
 * @returns {number}
 **/
Point.prototype.getManhattanDistance = function (other) {
    return Math.abs(this.x - other.x) + Math.abs(this.y - other.y);
};

/**
 * Makes this a copy of the point named other
 *
 *      // i.e.
 *      var p1 = new Point(3, 5),
 *          cloneP1;
 *      cloneP1 = p1.clone();       // cloneP1 is Point(3, 5)
 *
 * @param {Point} other Point to be cloned
 * @returns {Point} This point
 */
Point.prototype.clone = function () {
    return new Point(this.x, this.y);
};

// Declarations created to instantiate in NodeJS environment
if (typeof exports !== 'undefined') {
    module.exports = Point;
}

/**
 * @class Geometry
 * A little object that encapsulates most geometry functions used in the designer, most of the examples
 * are in 'spec/draw/geometry.spec.js'
 *
 * @singleton
 */
Geometry = {
    /**
     * The number pi
     * @property {number} [pi=Math.acos(-1)]
     */
    pi : Math.acos(-1),
    /**
     * Epsilon used for the correctness in comparison of float numbers
     * @property {number} [eps=1e-8]
     */
    eps : 1e-8,
    /**
     * Calculates the cross product of 2-dimensional vectors
     * @param {Point} p1
     * @param {Point} p2
     * @return {number}
     */
    cross : function (p1, p2) {
        return p1.x * p2.y - p1.y * p2.x;
    },
    /**
     * Calculates the SIGNED area of a parallelogram given three points, these three points are the points
     * that conforms the triangle that is half of the parallelogram, so. the area of the triangle
     * defined with these points is half the returned number (this method can return negative values)
     *
     *      // i.e.
     *      var p1 = new Point(0, 0),
     *          p2 = new Point(0, 1),
     *          p3 = new Point(1, 0),
     *          parallelogramArea,
     *          triangleArea;
     *
     *      parallelogramArea = Geometry.area(p1, p2, p3)   // -1 (area of the parallelogram)
     *      triangleArea = parallelogramArea / 2            // -0.5 (area of the triangle)
     *
     * @param {Point} p1
     * @param {Point} p2
     * @param {Point} p3
     * @return {number}
     */
    area : function (p1, p2, p3) {
        var auxP2 = p2.clone(),
            auxP3 = p3.clone();
        return this.cross(auxP2.subtract(p1), auxP3.subtract(p1));
    },
    /**
     * Determines if the point P is on segment AB
     * @param {Point} P
     * @param {Point} A
     * @param {Point} B
     * @return {boolean}
     */
    onSegment : function (P, A, B) {
        return (Math.abs(this.area(A, B, P)) < this.eps &&
            P.x >= Math.min(A.x, B.x) && P.x <= Math.max(A.x, B.x) &&
            P.y >= Math.min(A.y, B.y) && P.y <= Math.max(A.y, B.y));
    },
    /**
     * Checks if two perpendicular segments intersect, if so it returns the intersection point,
     * (this method only allows the perpendicular segment to be parallel to the x and y axis)
     * @param {Point} A
     * @param {Point} B
     * @param {Point} C
     * @param {Point} D
     * @return {Object}
     */
    perpendicularSegmentIntersection : function (A, B, C, D) {
        var clone,
            returnValue = null;

        // swap the segments if possible
        if (A.x > B.x || A.y > B.y) {
            clone = A.clone();
            A = B.clone();
            B = clone;
        }

        if (C.x > D.x || C.y > D.y) {
            clone = C.clone();
            C = D.clone();
            D = clone;
        }

        if (A.x === B.x) {
            if (C.y === D.y && C.x < A.x && A.x < D.x &&
                        A.y < C.y && C.y < B.y) {
                returnValue = new Point(A.x, C.y);
            }
        } else if (A.y === B.y) {
            if (C.x === D.x && A.x < C.x && C.x < B.x &&
                    C.y < A.y && A.y < D.y) {
                returnValue = new Point(C.x, A.y);
            }
        }
        return returnValue;
    },
    /**
     * Determines if segment AB intersects with segment CD (won't check infinite intersections),
     * if `strict` is set to `true` then it'll consider the case when one end of a segment is right in the
     * other segment
     * @param {Point} A
     * @param {Point} B
     * @param {Point} C
     * @param {Point} D
     * @param {boolean} [strict]
     * @return {boolean}
     */
    segmentIntersection : function (A, B, C, D, strict) {

        var area1 = this.area(C, D, A),
            area2 = this.area(C, D, B),
            area3 = this.area(A, B, C),
            area4 = this.area(A, B, D),
            returnValue;
        if (((area1 > 0 && area2 < 0) || (area1 < 0 && area2 > 0)) &&
                ((area3 > 0 && area4 < 0) || (area3 < 0 && area4 > 0))) {
            return true;
        }

        returnValue = false;
        if (strict) {
            if (area1 === 0 && this.onSegment(A, C, D)) {
                returnValue = true;
            } else if (area2 === 0 && this.onSegment(B, C, D)) {
                returnValue = true;
            } else if (area3 === 0 && this.onSegment(C, A, B)) {
                returnValue = true;
            } else if (area4 === 0 && this.onSegment(D, A, B)) {
                returnValue = true;
            }
        }
        return returnValue;
    },
    /**
     * Checks if two segments intersect, if so it returns the intersection point
     * @param {Point} A
     * @param {Point} B
     * @param {Point} C
     * @param {Point} D
     * @return {Point}
     */
    segmentIntersectionPoint: function (A, B, C, D) {
        return A.add((B.subtract(A))
            .multiply(this.cross(C.subtract(A), D.subtract(A)) /
                this.cross(B.subtract(A), D.subtract(C))));
    },
    /**
     * Determines whether a point is in a given rectangle or not given its
     * upperLeft and bottomRight corner (consider that a rectangle is turned in the y-axis)
     * @param {Point} point
     * @param {Point} upperLeft
     * @param {Point} bottomRight
     * @return {boolean}
     */
    pointInRectangle : function (point, upperLeft, bottomRight) {
        return (point.x >= upperLeft.x && point.x <= bottomRight.x &&
            point.y >= upperLeft.y && point.y <= bottomRight.y);
    },
    /**
     * Determines whether a point is in a circle or not given its center and
     * radius
     * @param {Point} point
     * @param {Point} center
     * @param {number} radius
     * @returns {boolean}
     */
    pointInCircle : function (point, center, radius) {
        return center.getDistance(point) <= radius;
    },
    /**
     * Determine whether a point is inside a rhombus or not given its center
     * and its points in clockwise order
     * @param {Point} point
     * @param {Array} rhombus
     * @param {Point} center
     * @return {boolean}
     */
    pointInRhombus : function (point, rhombus, center) {
        var i,
            j = rhombus.length - 1;
        for (i = 0; i < rhombus.length; j = i, i += 1) {
            if (this.segmentIntersection(center, point,
                    rhombus[j], rhombus[i], true) &&
                    this.onSegment(point, rhombus[j], rhombus[i]) === false) {
                return false;
            }
        }
        return true;
    }
};

// Declarations created to instantiate in NodeJS environment
if (typeof exports !== 'undefined') {
    module.exports = Geometry;
}


/**
 * @class Graphics 
 * Class Graphics is the HTMLElement drawing engine used to draw lines (as HTMLElement divs),
 * arcs (using HTMLElement divs) and ovals.
 * Currently some elements in the designer are completely represented with the drawing engine:
 *
 * - Connection => a set of segments (regular, segmented, dotted)
 * - Port => oval
 * - Intersection => arc
 *
 * Some important notes:
 *
 * - Currently this class acts as an interface between the library **jCore** and the HTMLElement
 * drawing engine wz_jsGraphics
 * - The drawing engine constructor needs the HTMLElement where it will go as a parameter **(this
 * HTMLElement must exist in the DOM)**
 *
 * @constructor
 * Creates an instance of this class (currently it's an interface of the wz_graphics framework)
 * @param {Object} html This parameter can be either an id, or an html object
 */
Graphics = function (html) {

    if (!html) {
        return null;
    }

    /**
     * Create an instance of the class JSGraphics (this.graphics is an interface)
     * @type {Object}
     */
    this.graphics = new JSGraphics(html);

    /**
     * Creates an instance of the class Color (color black)
     * @type {Color}
     */
    this.color = new Color(0, 0, 0);
};

/**
 * Draws a line of a given type between two points.
 *
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {string} type the type of line we wish to draw
 * @param {Color} color The color of the segment
 * @param {number} segLength the segment length for segmented and segmentdot type of line
 * @param {number} spaceLength the space length for segmented and segmentdot type of line
 * @param {boolean} [doNotErasePrevious] if set to true then it won't clear the elements drew with this instance
 */
Graphics.prototype.drawLine = function (x1, y1, x2, y2, type, color, segLength,
                                       spaceLength, doNotErasePrevious) {

    if (!doNotErasePrevious) {
        this.graphics.clear();
    }

    if (!type) {
        type = "regular";
    }
    switch (type) {
    case "dotted":
        this.graphics.setStroke(-1);
        break;
    case "segmented":
        this.graphics.setStroke(1);
        this.graphics.drawLine = this.makeSegmentedLine;
        break;
    case "segmentdot":
        this.graphics.setStroke(1);
        this.graphics.drawLine = this.makeSegmentDotLine;
        break;
    default:
        this.graphics.setStroke(1);
    }

    this.graphics.setColor(color.getCSS());
    this.graphics.drawLine(x1, y1, x2, y2, segLength, spaceLength);
    this.graphics.paint();

};

///**
// * NOTE: Unused definition
// * Initializes the graphics variable with a new html container
// * @param {HTMLElement} html
// * @returns {Graphics}
// */
//Graphics.prototype.initGraphics = function (html) {
//    if (html) {
//        this.graphics = new JSGraphics(html);
//    }
//    return this;
//};

/**
 * Returns the color that was being used for drawing
 * @returns {Color}
 */
Graphics.prototype.getColor = function () {
    return this.color;
};

/**
 * Sets the color to be used for drawing
 * @param newColor
 * @chainable
 */
Graphics.prototype.setColor = function (newColor) {
    if (newColor.type === "Color") {
        this.color = newColor;
    }
    return this;
};

/**
 * This function will make a segmented line between two points in the same axis,
 * if points in different axis are provided the method would simple return
 *
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} segmentLength the segment length for segmented and
 * segmentdot type of line
 * @param {number} spLength the space length for segmented and
 * segmentdot type of line
 */
Graphics.prototype.makeSegmentedLine = function (x1, y1, x2, y2, segmentLength,
                                                 spLength) {
    var dx,
        dy,
        aux,
        segLength = 4,
        spaceLength = 3,
        diff = 0,
        x,
        y;

    //not same axis so just return
    if ((x2 !== x1 && y2 !== y1)) {
        return;
    }

    if (x2 === x1) {
        //same point just return
        if (y2 === y1) {
            return;
        }
        dx = 0;
        //swap
        if (y2 < y1) {
            aux = y2;
            y2 = y1;
            y1 = aux;
        }
        dy = diff = y2 - y1;
    } else {
        dy = 0;
        if (x2 < x1) {
            aux = x2;
            x2 = x1;
            x1 = aux;
        }
        dx = diff = x2 - x1;
    }

    x = x1;
    y = y1;

    if (diff < 7) {
        segLength = 2;
        spaceLength = 1;
    }

    segLength = (!segmentLength) ? segLength : segmentLength;
    spaceLength = (!spLength) ? spaceLength : spLength;

    if (dy === 0) {
        while (dx > 0) {
            if (dx >= segLength) {
                this._mkDiv(x, y, segLength, 1);
                x += segLength + spaceLength;
                dx -= (segLength + spaceLength);
            } else {
                this._mkDiv(x, y, dx, 1);
                dx = 0;
            }
        }
    } else {
        while (dy > 0) {
            if (dy >= segLength) {
                this._mkDiv(x, y, 1, segLength);
                y += segLength + spaceLength;
                dy -= (segLength + spaceLength);
            } else {
                this._mkDiv(x, y, 1, dy);
                dy = 0;
            }
        }
    }
};

/**
 * This function will make a segment between two points in the same axis with
 * the following structure segment-dot-segment
 * if points in different axis are provided the function will simply return.
 *
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} segmentLength the segment length for segmented and
 * segmentdot type of line
 * @param {number} spLength the space length for segmented and
 * segmentdot type of line
 */

Graphics.prototype.makeSegmentDotLine = function (x1, y1, x2, y2, segmentLength,
                                                  spLength) {
    var dx,
        dy,
        aux,
        segLength = 7,
        spaceLength = 4,
    //in case its necessary dot Length
        dotLength = 1,
        diff = 0,
        x,
        y;

    //not same axis so just return
    if ((x2 !== x1 && y2 !== y1)) {
        return;
    }


    if (x2 === x1) {
        //same point just return
        if (y2 === y1) {
            return;
        }
        dx = 0;
        //swap
        if (y2 < y1) {
            aux = y2;
            y2 = y1;
            y1 = aux;
        }
        dy  = y2 - y1;
        diff = dy;
    } else {
        dy = 0;
        if (x2 < x1) {
            aux = x2;
            x2 = x1;
            x1 = aux;
        }
        dx = x2 - x1;
        diff = dx;
    }

    x = x1;
    y = y1;

    segLength = (!segmentLength) ? segLength : segmentLength;
    spaceLength = (!spLength) ? spaceLength : spLength;

    if (dy === 0) {
        while (dx > 0) {
            if (dx >= segLength) {
                this._mkDiv(x, y, segLength, 1);
                dx -= (segLength + spaceLength);
                x += segLength + spaceLength;
                if (dx > 0) {
                    //we need to implement this if the dot length would be
                    // different than one
                    //if(dx < dotLength){
                    //	this._mkDiv(x,y,dx,1);
                    //  dx  = 0; continue;
                    //}
                    this._mkDiv(x, y, dotLength, 1);
                    dx -= (dotLength + spaceLength);
                    x += dotLength + spaceLength;

                }
            } else {
                this._mkDiv(x, y, dx, 1);
                dx = 0;
            }
        }
    } else {
        while (dy > 0) {
            if (dy >= segLength) {
                this._mkDiv(x, y, 1, segLength);
                dy -= (segLength + spaceLength);
                y += segLength + spaceLength;
                if (dy > 0) {
                    //we need to implement this if the dot length would be
                    // different than one
                    //if(dy < dotLength){
                    //	this._mkDiv(x,y,1,dy);
                    //  dy  = 0; continue;
                    //}
                    this._mkDiv(x, y, 1, dotLength);
                    dy -= (dotLength + spaceLength);
                    y += dotLength + spaceLength;

                }
            } else {
                this._mkDiv(x, y, 1, dy);
                dy = 0;
            }
        }
    }

};
/**
 * Draws an arc with the center `[cx, cy]`, with a radius equal to `radius` from `startAngle` to `endAngle`
 * and drawing a line every `step` steps.
 * Logic:
 *
 * 1. Let's assume that we have a circle with center `[cx, cy]` and with a radius equal to `radius`
 * 2. We want to draw only a portion of the circle (from `startAngle` to `endAngle`)
 * 3. Given any angle of the circle `0 <= angle < 360` we can get its `x` and `y` coordinates using
 *    Pythagoras triangle rectangle laws.
 *      - We know that `hyp^2 = dx^2 + dy^2` and that `hyp = radius`
 *      - We know that `cos(angle) = dx / radius` so `dx = radius * cos(angle)`
 *      - We know that `sin(angle) = dy / radius` so `dx = radius * cos(angle)`
 * 4. Finally let's use the given center of the circle to move the triangle
 *
 * @param {number} cx
 * @param {number} cy
 * @param {number} radius
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} step
 */
Graphics.prototype.drawArc = function (cx, cy, radius, startAngle,
                                       endAngle, step) {
    var x,
        y,
        angle = startAngle;

    if (!step) {
        step = 10;
    }

    while (Math.abs(angle - endAngle) > 1e-5) {
        angle = (angle + step) % 360;
        x = cx + radius * Math.cos(angle * Geometry.pi / 180.0);
        y = cy + radius * Math.sin(angle * Geometry.pi / 180.0);
        this.graphics.drawLine(x, y, x, y);
    }
};

/**
 * @class Utils
 * A class that has utilities used in the library like coordinates converter,
 * unique id generator, and shape locator.
 *
 * @singleton
 */

Utils = {
    /**
     * Converts the coordinates `xCoord` and `yCoord` (assuming that xCoord and yCoord are pageCoordinates)
     * or the page coordinates gathered from the object `e` if there is no `xCoord` or `yCoord` to
     * `shape` coordinates, this new coordinate also considers the scroll done in the canvas
     *
     *      // i.e.
     *      // Let's assume that:
     *      // the canvas coordinates are [100, 100] and that it has no scroll
     *      // the shape coordinates are [100, 100] (inside the canvas)
     *      // e is an object containing page.X = 300, page.Y = 300
     *      Utils.pageCoordinatesToShapeCoordinates(shape, e)  // new Point(100, 100) respect to the shape
     *
     *
     * @param {Object} shape
     * @param {Object} e
     * @param {number} [xCoord]
     * @param {number} [yCoord]
     * @return {Point} a point relative to the canvas
     */
    pageCoordinatesToShapeCoordinates : function (shape, e, xCoord, yCoord) {
        var coordinates,
            x = (!xCoord) ? e.pageX : xCoord,
            y = (!yCoord) ? e.pageY : yCoord,
            canvas = shape.getCanvas();
        x += canvas.getLeftScroll() - shape.getAbsoluteX() - canvas.getX();
        y += canvas.getTopScroll() - shape.getAbsoluteY() - canvas.getY();
        coordinates = new Point(x, y);
        return coordinates;
    },
    /**
     * Converts the coordinates of the `shape` to page coordinates, this method
     * also considers the scroll of the canvas in the calculation
     *
     *      // i.e.
     *      // Let's assume that:
     *      // the canvas coordinates are [100, 100] and that it has no scroll
     *      // the shape coordinates are [100, 100] (inside the canvas)
     *      Utils.getPointRelativeToPage(shape)     // new Point(200, 200) respect to the page
     *
     * @param {Object} shape
     * @return {Point} a point relative to the page
     */
    getPointRelativeToPage : function (shape) {
        var canvas = shape.getCanvas(),
            x = shape.absoluteX + canvas.getX() - canvas.getLeftScroll() +
                shape.zoomWidth / 2,
            y = shape.absoluteY + canvas.getY() - canvas.getTopScroll() +
                shape.zoomHeight / 2;
        return new Point(x, y);
    },
    /**
     * Generates a random string of 32 characters
     *      // i.e.
     *      Utils.generateUniqueId()        //87945323950cb672d438a84031660752
     *      Utils.generateUniqueId()        //61920554050cb6736438a91037314125
     * @return {string}
     */
    generateUniqueId : function () {
        var rand = function (min, max) {
                // Returns a random number
                //
                // version: 1109.2015
                // discuss at: http://phpjs.org/functions/rand
                // +   original by: Leslie Hoare
                // +   bugfixed by: Onno Marsman
                // %          note 1: See the commented out code below for a
                // version which will work with our experimental
                // (though probably unnecessary) srand() function)
                // *     example 1: rand(1, 1);
                // *     returns 1: 1

                // fix for jsLint
                // from: var argc = arguments.length;
                if (typeof min === "undefined") {
                    min = 0;
                }
                if (typeof max === "undefined") {
                    max = 999999999;
                }
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            uniqid = function (prefix, more_entropy) {
                // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
                // +    revised by: Kankrelune (http://www.webfaktory.info/)
                // %        note 1: Uses an internal counter (in php_js global) to avoid collision
                // *     example 1: uniqid();
                // *     returns 1: 'a30285b160c14'
                // *     example 2: uniqid('foo');
                // *     returns 2: 'fooa30285b1cd361'
                // *     example 3: uniqid('bar', true);
                // *     returns 3: 'bara20285b23dfd1.31879087'
                if (typeof prefix === 'undefined') {
                    prefix = "";
                }

                var retId,
                    formatSeed = function (seed, reqWidth) {
                        var tempString = "",
                            i;
                        seed = parseInt(seed, 10).toString(16); // to hex str
                        if (reqWidth < seed.length) { // so long we split
                            return seed.slice(seed.length - reqWidth);
                        }
                        if (reqWidth > seed.length) { // so short we pad
                            // jsLint fix
                            tempString = "";
                            for (i = 0; i < 1 + (reqWidth - seed.length); i += 1) {
                                tempString += "0";
                            }
                            return tempString + seed;
                        }
                        return seed;
                    };

                // BEGIN REDUNDANT
                if (!this.php_js) {
                    this.php_js = {};
                }
                // END REDUNDANT
                if (!this.php_js.uniqidSeed) { // init seed with big random int
                    this.php_js.uniqidSeed = Math.floor(Math.random() * 0x75bcd15);
                }
                this.php_js.uniqidSeed += 1;

                retId = prefix; // start with prefix, add current milliseconds hex string
                retId += formatSeed(parseInt(new Date().getTime() / 1000, 10), 8);
                retId += formatSeed(this.php_js.uniqidSeed, 5); // add seed hex string
                if (more_entropy) {
                    // for more entropy we add a float lower to 10
                    retId += (Math.random() * 10).toFixed(8).toString();
                }

                return retId;
            },
            sUID;

        do {
            sUID = uniqid(rand(0, 999999999), true);
            sUID = sUID.replace('.', '0');
        } while (sUID.length !== 32);

        return sUID;
    }
};

/**
 * @class Command
 * Abstract class command which declares some abstract methods such as
 * execute (redo) and inverseExecute (undo) a command.
 *
 * A command is implemented in the library as follows:
 *
 * - The command must define a method execute which does the operation desired (i.e. commandDelete's execute
 *      method deletes shapes and connections from a canvas).
 * - The command must define a method undo which undoes what the method execute did.
 * - The command must define a method redo which simply calls the execute method (redo must do the
 *      same operation as execute).
 *
 * Finally to execute and save the command let's use the {@link Canvas#property-commandStack} property that any
 * canvas has so:
 *
 *      // i.e.
 *      // let's assume that canvas is an instance of the class Canvas
 *      // let's create an instance of commandDelete
 *      // let's assume that config has the correct configuration options of this command
 *      var command = new CommandDelete(config)
 *      // let's add the command to the canvas's commandStack
 *      canvas.commandStack.add(command);
 *      // finally let's execute the command
 *      command.execute();      // this line actually removes the shapes!
 *
 *      // if we want to undo the last command
 *      canvas.commandStack.undo();     // this line recreates the shapes
 *
 *      // if we want to redo the last command
 *      canvas.commandStack.redo();     // this line removes the shapes again
 *
 * @abstract
 * @constructor Creates an instance of the class command
 * @param {Object} receiver The object that will execute the command
 */
Command = function (receiver) {

    /**
     * The object that executes the command
     * @property {Object}
     */
    this.receiver = receiver;
    /**
     * Reference to the canvas
     * @property {Canvas}
     */
    this.canvas = (!receiver) ? null : receiver.getCanvas();
};

/**
 * Family of this command
 * @property {String}
 */
Command.prototype.family = "Command";

/**
 * Executes the command
 * @template
 * @protected
 */
Command.prototype.execute = function (stopTrigger) {
};

/**
 * InverseExecutes the command (a.k.a. undo)
 * @template
 * @protected
 */
Command.prototype.undo = function (stopTrigger) {
};

/**
 * Executes the command (a.k.a. redo)
 * @template
 * @protected
 */
Command.prototype.redo = function (stopTrigger) {
};

/**
 * @class CommandStack
 * Command stack stores the commands executed to perform undos and redos, it consists of 2 stacks:
 *
 * - undoStack (represented as an array)
 * - redoStack (represented as an array)
 *
 * Every time an undo or redo action is executed the stacks automatically get updated and the function passed
 * during the instantiation is called.
 *
 *      // i.e.
 *      // let's assume that commandCreateInstance is an instance of CommandCreate
 *      // let's assume that commandResizeInstance is an instance of CommandResize
 *
 *      // first let's create the stacks (max size of the redo stack is 5)
 *      var commandStack = new CommandStack(5);
 *
 *      // commandStack.add() inserts the command to the undoStack (emptying the redo stack too)
 *      commandStack.add(commandCreateInstance);
 *      commandStack.add(commandResizeInstance);
 *      commandStack.add(commandResizeInstance);
 *      commandStack.add(commandResizeInstance);
 *      commandStack.add(commandResizeInstance);
 *
 *      // at this point the redo stack is full (we defined a max size of 5), so the following add will remove the
 *      // last element of the stack (which is commandCreateInstance) and the undoStack will only consist of
 *      // command resize instances
 *      commandStack.add(commandResizeInstance);
 *
 *      // whenever an undo operation is executed in the commandStack, the first command (which is the last command
 *      // in the undoStack) executes its undo operation and the command is removed from the undoStack and pushed to
 *      // the redoStack, graphically:
 *
 *      // Let's define an stack graphically as '[['
 *      // if an element (e1) is pushed to the stack the stack becomes: [[e1
 *      // if an element (e2) is pushed to the stack the stack becomes: [[e1, e2
 *      // if an element (e3) is pushed to the stack the stack becomes: [[e1, e2, e3
 *      // if an element is removed from the stack the stack becomes: [[e1, e2
 *      // Note the direction of the stack, if it's defined as ']]'
 *      // the operations executed above turn the stack into:
 *      // e1]]; e2, e1]]; e3, e2, e1]]; e2, e1]]
 *
 *      // Let's alias commandResizeInstance as cRI and commandCreateInstance cCI.
 *      // With the example defined above of commandResizeInstance, the following line does:
 *      // pre state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4, cRI_5
 *      // redoStack = ]]
 *      // post state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4
 *      // redoStack = cRI_5]]
 *      commandStack.undo();
 *
 *      // executing undo again leads to:
 *      // pre state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4
 *      // redoStack = cRI_5]]
 *      // post state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3
 *      // redoStack = cRI_4, cRI_5]]
 *      commandStack.undo();
 *
 *      // executing redo leads to:
 *      // pre state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3
 *      // redoStack = cRI_4, cRI_5]]
 *      // post state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4
 *      // redoStack = cRI_5]]
 *      commandStack.redo();
 *
 *      // adding a new command to the stack empties the redo stack so:
 *      // pre state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4
 *      // redoStack = cRI_5]]
 *      // post state:
 *      // undoStack = [[cRI_1, cRI_2, cRI_3, cRI_4, cCI_1
 *      // redoStack = ]]
 *      commandStack.add(commandCreateInstance);
 *
 * @constructor Creates an instance of the class CommandStack
 * @param {number} stackSize The maximum number of operations to be saved
 * @param {Function} successCallback Function to be executed after add, undo or redo,
 * `this` will refer to the object itself, not the constructor
 */
CommandStack = function (stackSize, successCallback) {

    var undoStack,
        redoStack,
        maxSize;

    /**
     * Stacks that contains commands (when pushed to the undoStack)
     * @property {Array} [undoStack=[]]
     * @private
     */
    undoStack = [];
    /**
     * Stacks that contains commands (when pushed to the redoStack)
     * @property {Array} [redoStack=[]]
     * @private
     */
    redoStack = [];
    /**
     * Maximum size of the undo stack
     * @property {number} [maxSize=20]
     * @private
     */
    maxSize = stackSize || 20;

    /**
     * Empties the redo stack (when a new event is added to the undoStack)
     * @private
     */
    function emptyRedoStack() {
        redoStack = [];
    }

    /**
     * Handler to be called when a special action occurs
     */
    function onSuccess() {
//        // debug
//        console.log("onSuccess was called");
//        console.log(this.getUndoSize() + " " + this.getRedoSize());
    }

    if (successCallback && {}.toString.call(successCallback) === '[object Function]') {
        onSuccess = successCallback;
    }

    return {
        /**
         * Adds an action (command) to the undoStack
         * @param {Command} action
         */
        add: function (action) {
            emptyRedoStack();
            undoStack.push(action);
            if (undoStack.length > maxSize) {
                // got to the max size of the stack
                undoStack.shift();
            }
            onSuccess();
        },
        /**
         * Adds an action (command) to the redoStack
         * @param {Command} action
         */
        addToRedo: function (action) {
            redoStack.push(action);
        },
        /**
         * Undoes the last action executing undoStack's first item undo
         * @return {boolean}
         */
        undo: function () {
            var action;     // action to be inverse executed

            if (undoStack.length === 0) {
                console.log("undo(): can't undo because there are no " +
                    "actions to undo");
                return false;
            }

            action = undoStack.pop();

            // inverse execute the action
            action.undo();

            redoStack.unshift(action);

            // execute on success handler
            onSuccess();
            return true;
        },
        /**
         * Redoes the last action executing redoStack's first item redo
         * @return {boolean}
         */
        redo: function () {
            var action;     // action to be inverse executed

            if (redoStack.length === 0) {
                console.log("redo(): can't redo because there are no " +
                    "actions to redo");
                return false;
            }

            action = redoStack.shift();

            // execute the action
            action.redo();

            undoStack.push(action);

            // execute on success handler
            onSuccess();
            return true;
        },
        /**
         * Clear both stacks
         */
        clearStack: function () {
            console.log("CommandStack.clearStack(): WARNING - " +
                "clearing the stacks");
            redoStack = [];
            undoStack = [];
        },
        /**
         * Debugging method to show the state of each stack
         * @param {boolean} showDetailed
         */
        debug: function (showDetailed) {
            var i;
            console.log("Debugging command stack:");
            console.log("Undo stack size: " + undoStack.length);
            if (showDetailed) {
                for (i = 0; i < undoStack.length; i += 1) {
                    console.log((i + 1) + ") " + undoStack[i].type);
                }
            }
            console.log("Redo stack size: " + redoStack.length);
            if (showDetailed) {
                for (i = 0; i < redoStack.length; i += 1) {
                    console.log((i + 1) + ") " + redoStack[i].type);
                }
            }
        },
        /**
         * Gets the size of the redo stack
         * @return {Number}
         */
        getRedoSize: function () {
            return redoStack.length;
        },
        /**
         * Gets the size of the redo stack
         * @return {Number}
         */
        getUndoSize: function () {
            return undoStack.length;
        },
        /**
         * Sets the onSuccess handler of this object
         * @param successCallback
         * @chainable
         */
        setHandler: function (successCallback) {
            if (successCallback && {}.toString.call(successCallback) === '[object Function]') {
                onSuccess = successCallback;
            }
            return this;
        }
    };
};

/**
 * @class CommandResize
 * Class CommandResize determines the actions executed when some shapes are resized (redo) and the actions
 * executed when they're resized back (undo).
 *
 * Instances of this class are created in {@link RegularResizeBehavior#event-resizeEnd}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandResize
 * @param {Object} receiver The object that will execute the command
 */
CommandResize = function (receiver) {
    Command.call(this, receiver);

    /**
     * Object that represents the state of the shape before changing
     * its dimension
     * @property {Object}
     */
    this.before = {
        x: this.receiver.getOldX(),
        y: this.receiver.getOldY(),
        width: this.receiver.getOldWidth(),
        height: this.receiver.getOldHeight()
    };

    /**
     * Object that represents the state of the shape after changing
     * its dimension
     * @property {Object}
     */
    this.after = {
        x: this.receiver.getX(),
        y: this.receiver.getY(),
        width: this.receiver.getWidth(),
        height: this.receiver.getHeight()
    };
};

CommandResize.prototype = new Command();

/**
 * Type of command of this object
 * @property {String}
 */
CommandResize.prototype.type = "CommandResize";

/**
 * Executes the command.
 * The steps are:
 *
 * 1. Set the new position and dimension of the shape (using `this.after`)
 * 2. Fix its connections on resize
 * 3. Trigger the dimension change event
 * 4. Trigger the position change event
 *
 * @chainable
 */
CommandResize.prototype.execute = function () {
    var shape = this.receiver,
        canvas = shape.getCanvas();
    shape.setPosition(this.after.x, this.after.y)
         .setDimension(this.after.width, this.after.height);
    shape.fixConnectionsOnResize(shape.resizing, true);
    canvas.triggerDimensionChangeEvent(shape, this.before.width,
        this.before.height, this.after.width, this.after.height);
    if ((this.after.x !== this.before.x) || (this.after.y !== this.before.y)) {
        canvas.triggerPositionChangeEvent(
            [shape],
            [{
                x : this.before.x,
                y : this.before.y
            }],
            [{
                x : this.after.x,
                y : this.after.y
            }]
        );
    }
    return this;
};

/**
 * Inverse executes a command a.k.a undo.
 * The steps are:
 *
 * 1. Set the new position and dimension of the shape (using `this.before`)
 * 2. Fix its connections on resize
 * 3. Trigger the dimension change event
 * 4. Trigger the position change event
 *
 * @chainable
 */
CommandResize.prototype.undo = function () {
    var shape = this.receiver,
        canvas = shape.getCanvas();
    shape.setPosition(this.before.x, this.before.y)
         .setDimension(this.before.width, this.before.height);
    shape.fixConnectionsOnResize(shape.resizing, true);
    canvas.triggerDimensionChangeEvent(shape, this.after.width,
        this.after.height, this.before.width, this.before.height);
    if ((this.after.x !== this.before.x) || (this.after.y !== this.before.y)) {
        canvas.triggerPositionChangeEvent(
            [shape],
            [{
                x : this.after.x,
                y : this.after.y
            }],
            [{
                x : this.before.x,
                y : this.before.y
            }]
        );
    }
    return this;
};

/**
 * Executes the command a.k.a redo.
 * @chainable
 */
CommandResize.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandConnect
 * Class CommandConnect determines the actions executed when a connection is created (redo) and the actions
 * executed when it's destroyed (undo).
 *
 * Instances of this class are created in {@link Canvas#removeElements}.
 *
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandConnect.
 * @param {Object} receiver The object that will execute the command
 */
CommandConnect = function (receiver) {
    Command.call(this, receiver);
};

CommandConnect.prototype = new Command();

/**
 * Type of command
 * @property {String}
 */
CommandConnect.prototype.type = "CommandConnect";

/**
 * Executes the command.
 * The steps are:
 *
 * 1. Insert the ports in their respective parents (shapes)
 * 2. Append the html of the ports
 * 3. Add the connection html to the canvas
 * 4. Trigger the create event
 *
 * @chainable
 */
CommandConnect.prototype.execute = function () {

    var connection = this.receiver,
        canvas = connection.canvas,
        srcPort = connection.getSrcPort(),
        destPort = connection.getDestPort();

    // save the ports in its parents' ports array
    srcPort.parent.ports.insert(srcPort);
    destPort.parent.ports.insert(destPort);

    // append the html of the ports to its parents (customShapes)
    srcPort.parent.html.appendChild(srcPort.getHTML());
    destPort.parent.html.appendChild(destPort.getHTML());

    // add the connection to the canvas (its html is appended)
    canvas.addConnection(connection);
    canvas.updatedElement = connection;
    canvas.triggerCreateEvent(connection, []);
    return this;
};

/**
 * Inverse executes the command a.k.a. undo.
 * The steps are:
 *
 * 1. Save the connection (detach it from the DOM)
 * 2. Trigger the remove event
 *
 * @chainable
 */
CommandConnect.prototype.undo = function () {
    this.receiver.saveAndDestroy();
    this.receiver.canvas.triggerRemoveEvent(this.receiver, []);
    return this;
};

/**
 * Executes the command a.k.a. redo by calling `this.execute`
 * @chainable
 */
CommandConnect.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandReconnect
 * Class CommandReconnect determines the actions executed when a connection is reconnected, i.e. when a connection
 * source port or end port are dragged to another shape or another position in the same shape (redo)
 * and the actions executed to revert the last drag to another shape or another position in the same shape (undo).
 *
 * Instances of this class are created in {@link ConnectionDropBehavior#onDrop}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandReconnect
 * @param {Object} receiver The object that will execute the command
 */
CommandReconnect = function (receiver) {
    Command.call(this, receiver);

    /**
     * Object that represents the state of the shape before changing
     * its dimension
     * @property {Object}
     */
    this.before = {
        x: this.receiver.getOldX(),
        y: this.receiver.getOldY(),
        parent: this.receiver.getOldParent()
    };

    /**
     * Object that represents the state of the shape after changing
     * its dimension
     * @property {Object}
     */
    this.after = {
        x: this.receiver.getX(),
        y: this.receiver.getY(),
        parent: this.receiver.getParent()
    };
};

CommandReconnect.prototype = new Command();

/**
 * Type of command.
 * @property {String}
 */
CommandReconnect.prototype.type = "CommandReconnect";

/**
 * Executes the command
 * The steps are:
 *
 * 1. Hide the currentConnection of the canvas if there's one
 * 2. If the new parent of the dragged port is different than the old parent
 *      - Remove the port from its old parent
 *      - Add the port to the new parent
 * 3. If the new parent of the dragged port is equal to the old parent
 *      - Redefine its position in the shape
 * 4. Reconnect the connection (using the new ports) and check for intersections
 * 4. Trigger the port change event
 *
 * @chainable
 */
CommandReconnect.prototype.execute = function () {

    var port = this.receiver,
        parent = this.after.parent,
        oldParent = this.before.parent;

    // hide the connection if its visible
    if (parent.canvas.currentConnection) {
        parent.canvas.currentConnection.hidePortsAndHandlers();
        parent.canvas.currentConnection = null;
    }

    if (parent.getID() !== oldParent.getID()) {
        oldParent.removePort(port);
//        parent.addPort(port, this.after.x, this.after.y, true);
        port.canvas.regularShapes.insert(port);
    } else {
        parent.definePortPosition(port,
            new Point(this.after.x + Math.round(port.getWidth() / 2),
                this.after.y + Math.round(port.getHeight()/2)));
    }

    port.connection
        .disconnect()
        .connect()
        .setSegmentMoveHandlers()
        .checkAndCreateIntersectionsWithAll();

    // custom trigger
    this.receiver.canvas.triggerPortChangeEvent(port);
    return this;
};

/**
 * Inverse executes a command i.e. undo.
 * The steps are:
 *
 * 1. Hide the currentConnection of the canvas if there's one
 * 2. If the old parent of the port is different than the new parent
 *      - Remove the port from its new parent
 *      - Add the port to the old parent
 * 3. If the old parent of the port is equal to the new parent
 *      - Redefine its position in the shape
 * 4. Reconnect the connection (using the new ports) and check for intersections
 * 4. Trigger the port change event
 *
 * @chainable
 */
CommandReconnect.prototype.undo = function () {
    var port = this.receiver,
        parent = this.after.parent,
        oldParent = this.before.parent;

    // hide the connection if its visible
    if (parent.canvas.currentConnection) {
        parent.canvas.currentConnection.hidePortsAndHandlers();
        parent.canvas.currentConnection = null;
    }

    if (parent.getID() !== oldParent.getID()) {
        parent.removePort(port);
        oldParent.addPort(port, this.before.x, this.before.y, true);
        port.canvas.regularShapes.insert(port);
    } else {
        parent.definePortPosition(port,
            new Point(this.before.x + Math.round(port.getWidth() / 2),
                this.before.y + Math.round(port.getHeight()/2)));
    }

    port.connection
        .disconnect()
        .connect()
        .setSegmentMoveHandlers()
        .checkAndCreateIntersectionsWithAll();

    // custom trigger
    this.receiver.canvas.triggerPortChangeEvent(port);
    return this;
};

/**
 * Inverse executes a command i.e. undo
 * @chainable
 */
CommandReconnect.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandSegmentMove
 * Class CommandSegmentMove determines the actions executed when a segment is moved through its move handler (redo)
 * and the actions executed when the segment is moved back (undo).
 *
 * Instances of this class are created in {@link SegmentMoveHandler#event-dragEnd}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandSegmentMove
 * @param {Connection} receiver The object that will execute the command
 * @param {Object} options Initialization options
 * @cfg {Array} [oldPoints=[]] Array of old points of the connection
 * @cfg {Array} [newPoints=[]] Array of new points of the connection
 */
CommandSegmentMove = function (receiver, options) {
    Command.call(this, receiver);

    /**
     * Array of points that represent the state of the connection before moving the segment move handler
     * @property {Array}
     */
    this.oldPoints = [];

    /**
     *  Array of points that represent the state of the connection after moving the segment move handler
     * @property {Array}
     */
    this.newPoints = [];

    CommandSegmentMove.prototype.initObject.call(this, options);
};

CommandSegmentMove.prototype = new Command();

/**
 * Type of command of this object
 * @property {String}
 */
CommandSegmentMove.prototype.type = "CommandResize";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains old points and new points
 * @private
 */
CommandSegmentMove.prototype.initObject = function (options) {
    var defaults = {
        oldPoints: [],
        newPoints: []
    },
        i,
        point;
    $.extend(true, defaults, options);
    this.oldPoints = [];
    for (i = 0; i < defaults.oldPoints.length; i += 1) {
        point = defaults.oldPoints[i];
        this.oldPoints.push(new Point(point.x, point.y));
    }
    this.newPoints = [];
    for (i = 0; i < defaults.newPoints.length; i += 1) {
        point = defaults.newPoints[i];
        this.newPoints.push(new Point(point.x, point.y));
    }
};

/**
 * There's a common behavior between execute and inverseExecute in
 * this command so merge both files and use a parameter to choose
 * between execute and inverseExecute.
 * The steps are:
 *
 * 1. Select the connection by triggering a click in its destination decorator
 * 2. Hide the ports and handlers of the connection and reconnect the connection using points
 * 3. Check and create the intersections and show the ports of the connection
 * 4. Trigger the segment move event
 *
 * @private
 * @chainable
 */
CommandSegmentMove.prototype.common = function (action) {
    var connection = this.receiver;
    // trigger targetSpriteDecorator onClick
    $(connection.destDecorator.getHTML()).trigger('click');

    connection.hidePortsAndHandlers();
    connection.disconnect(true).connect({
        algorithm: 'user',
        points: this[action]
    });

    // delete and create handlers to avoid
    // the creation of two handlers in
    // connection.checkAndCreateIntersectionsWithAll()
    connection.setSegmentMoveHandlers();

    // create intersections with all other connections
    connection.checkAndCreateIntersectionsWithAll();

    // show the ports and handlers again
    connection.showPortsAndHandlers();

    // trigger event
    connection.canvas.triggerConnectionStateChangeEvent(connection);
    return this;
};

/**
 * Executes a command
 * @chainable
 */
CommandSegmentMove.prototype.execute = function () {
    this.common("newPoints");
    return this;
};

/**
 * Inverse executes the command a.k.a. undo
 * @chainable
 */
CommandSegmentMove.prototype.undo = function () {
    this.common("oldPoints");
    return this;
};

/**
 * Executes the command a.k.a. redo
 * @chainable
 */
CommandSegmentMove.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandMove
 * Encapsulates the action of moving an element
 *
 *              //i.e.
 *              var command = new CommandMove(shape);
 * @extends Command
 *
 * @constructor
 * Creates an instance of CommandMove
 * @param {Object} receiver The object that will perform the action
 */
CommandMove = function (receiver) {
    Command.call(this, receiver);
    this.before = null;
    this.after = null;
    this.relatedShapes = [];
    CommandMove.prototype.initObject.call(this, receiver);
};

CommandMove.prototype = new Command();
/**
 * Type of the instances of this class
 * @property {String}
 */
CommandMove.prototype.type = "CommandMove";

/**
 * Initializes the command parameters
 * @param {JCoreObject} receiver The object that will perform the action
 */
CommandMove.prototype.initObject = function (receiver) {
    var i,
        beforeShapes = [],
        afterShapes = [];
    for (i = 0; i < receiver.getSize(); i += 1) {
        this.relatedShapes.push(receiver.get(i));
        beforeShapes.push({
            x : receiver.get(i).getOldX(),
            y : receiver.get(i).getOldY()
        });
        afterShapes.push({
            x : receiver.get(i).getX(),
            y : receiver.get(i).getY()
        });
    }
    this.before = {
        shapes : beforeShapes
    };
    this.after = {
        shapes : afterShapes
    };
    //first time do not has been dragged
    this.isDragged =  true;
};

/**
 * Executes the command, changes the position of the element, and if necessary
 * updates the position of its children, and refreshes all connections
 */
CommandMove.prototype.execute = function () {
    var i,
        shape;

    for (i = 0; i < this.relatedShapes.length; i += 1) {
        shape = this.relatedShapes[i];
        if (!this.isDragged) {
            shape.setPosition(this.after.shapes[i].x, this.after.shapes[i].y);
        }
        shape.refreshChildrenPositions(true);
        shape.refreshConnections(false, this.isDragged);

    }
    this.isDragged =  false;
    this.canvas.triggerPositionChangeEvent(this.relatedShapes,
        this.before.shapes, this.after.shapes);
};

/**
 * Returns to the state before the command was executed
 */
CommandMove.prototype.undo = function () {
    var i,
        shape;
    for (i = 0; i < this.relatedShapes.length; i += 1) {
        shape = this.relatedShapes[i];
        shape.setPosition(this.before.shapes[i].x, this.before.shapes[i].y)
            .refreshChildrenPositions(true);
        shape.refreshConnections(false, this.isDragged);
    }
    this.canvas.triggerPositionChangeEvent(this.relatedShapes,
        this.after.shapes, this.before.shapes);
};

/**
 *  Executes the command again after an undo action has been done
 */
CommandMove.prototype.redo = function () {
    this.execute();
};

/**
 * @class CommandCreate
 * Class CommandCreate determines the actions executed when some shapes are created (redo) and the actions
 * executed when they're destroyed (undo).
 *
 * Instances of this class are created in {@link ConnectionDropBehavior#onDrop}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandCreate
 * @param {Object} receiver The object that will execute the command
 *
 */
CommandCreate = function (receiver) {
    Command.call(this, receiver);

    /**
     * Object that represents the state of the receiver before
     * it was created
     * @property {Object}
     */
    this.before = null;

    /**
     * Object that represents the state of the receiver after
     * it was created
     * @property {Object}
     */
    this.after = null;

    CommandCreate.prototype.initObject.call(this, receiver);
};

CommandCreate.prototype = new Command();

/**
 * Type of command
 * @property {String}
 */
CommandCreate.prototype.type = "CommandCreate";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} receiver
 * @private
 */
CommandCreate.prototype.initObject = function (receiver) {
    this.before = {
    };
    this.after = {
        x: receiver.getX(),
        y: receiver.getY(),
        parent: receiver.getParent()
    };
};

/**
 * Executes the command.
 * The steps are:
 *
 * 1. Insert the current shape to the children of its parent if it's possible
 * 2. Append it to the HTML of its parent
 * 3. Add the shape to either `canvas.customShapes` or `canvas.regularShapes`
 * 4. Trigger the create event
 *
 * @chainable
 */
CommandCreate.prototype.execute = function () {

    // execute the trigger
    var shape = this.receiver,
        parent = shape.parent;

    // append the html to its parent
    // NOTE: in the first execution (in containerDropBehavior) the html is
    // already in the parent so the following line appends it again (html
    // is not created)

    // note that during the execution of this command the next line may called twice (one in
    // RegularContainerBehavior.addToContainer and the other here) so check if it's not
    // already in its children
    if (!parent.getChildren().contains(shape)) {
        parent.getChildren().insert(shape);
    }
    this.after.parent.html.appendChild(shape.getHTML());
    shape.canvas.addToList(shape);
    shape.showOrHideResizeHandlers(false);
    shape.canvas.triggerCreateEvent(shape, []);
    return this;
};

/**
 * Inverse executes the command a.k.a. undo
 *
 * The steps are:
 *
 * 1. Remove the current shape from the children of its parent if it's possible
 * 2. Remove its HTML (detach it from the DOM)
 * 4. Trigger the remove event
 *
 * @chainable
 */
CommandCreate.prototype.undo = function () {
    this.receiver.parent.getChildren().remove(this.receiver);
    this.receiver.saveAndDestroy();
    this.receiver.canvas.triggerRemoveEvent(this.receiver, []);
    return this;
};

/**
 * Executes the command a.k.a redo
 * @chainable
 */
CommandCreate.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandSwitchContainer
 * Class that encapsulates the action of switching containers
 *
 *              //i.e.
 *              var command = new CommandSwitchContainer(arrayOfShapes);
 * @extends Command
 *
 * @constructor
 * Creates an instance of this command
 * @param {Array} shapesAdded array of shapes that are going to switch container
 */
CommandSwitchContainer = function (shapesAdded) {
    Command.call(this, shapesAdded[0].shape);
    /**
     * Properties of the object before the command is executed
     * @property {Object}
     */
    this.before = null;
    /**
     * Properties of the object after the command is executed
     * @property {Object}
     */
    this.after = null;
    /**
     * Reference to all objects involved in this command
     * @type {Array}
     */
    this.relatedShapes = [];
    CommandSwitchContainer.prototype.initObject.call(this, shapesAdded);
};

CommandSwitchContainer.prototype = new Command();

/**
 * Type of the instances of this command
 * @property {String}
 */
CommandSwitchContainer.prototype.type = "CommandSwitchContainer";

/**
 * Initializer of the command
 * @param {Array} shapesAdded array of shapes that are going to switch container
 */
CommandSwitchContainer.prototype.initObject = function (shapesAdded) {
    var i,
        shape,
        beforeShapes = [],
        afterShapes = [];

    for (i = 0; i < shapesAdded.length; i += 1) {
        shape = shapesAdded[i];
        this.relatedShapes.push(shape.shape);
        beforeShapes.push({
            parent : shape.shape.parent,
            x : shape.shape.getOldX(),
            y : shape.shape.getOldY(),
            topLeft: true
        });
        afterShapes.push({
            parent : shape.container,
            x : shape.x,
            y : shape.y,
            topLeft : shape.topLeft
        });
    }

    this.before = {
        shapes : beforeShapes
    };

    this.after = {
        shapes : afterShapes
    };
};

/**
 * The command execution implementation, updates the parents, and if necessary,
 * updates the children positions and connections.
 */
CommandSwitchContainer.prototype.execute = function () {
    var i,
        shape;
    for (i = 0; i < this.relatedShapes.length;  i += 1) {
        shape = this.relatedShapes[i];
        this.before.shapes[i].parent.swapElementContainer(
            shape,
            this.after.shapes[i].parent,
            this.after.shapes[i].x,
            this.after.shapes[i].y,
            this.after.shapes[i].topLeft
        );
        shape.refreshChildrenPositions()
            .refreshConnections();
    }
    this.canvas.triggerParentChangeEvent(this.relatedShapes,
        this.before.shapes, this.after.shapes);
};

/**
 * Returns to the state before this command was executed
 */
CommandSwitchContainer.prototype.undo = function () {
    var i,
        shape;
    for (i = 0; i < this.relatedShapes.length;  i += 1) {
        shape = this.relatedShapes[i];
        this.before.shapes[i].parent.swapElementContainer(
            shape,
            this.before.shapes[i].parent,
            this.before.shapes[i].x,
            this.before.shapes[i].y,
            this.before.shapes[i].topLeft
        );
        shape.refreshChildrenPositions()
            .refreshConnections();
    }
    this.canvas.triggerParentChangeEvent(this.relatedShapes,
        this.after.shapes, this.before.shapes);
};

/**
 *  Executes the command again after an undo action has been done
 */
CommandSwitchContainer.prototype.redo = function () {
    this.execute();
};

/**
 * @class CommandDelete
 * Class CommandDelete determines the actions executed when some shapes are deleted (redo) and the actions
 * executed when they're recreated (undo).
 *
 * Instances of this class are created in {@link Canvas#removeElements}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandDelete
 * @param {Object} receiver The object that will execute the command
 */
CommandDelete = function (receiver) {
    Command.call(this, receiver);

    /**
     * A stack of commandsConnect
     * @property {Array}
     */
    this.stackCommandConnect = [];

    /**
     * ArrayList that represents the selection that was active before deleting the elements
     * @property {ArrayList}
     */
    this.currentSelection = new ArrayList();

    /**
     * Reference to the current connection in the canvas
     * @property {Connection}
     */
    this.currentConnection = null;

    /**
     * List of all the elements related to the commands
     * @property {Array}
     */
    this.relatedElements = [];

    CommandDelete.prototype.initObject.call(this, receiver);
};

CommandDelete.prototype = new Command();

/**
 * Type of command
 * @property {String}
 */
CommandDelete.prototype.type = "CommandDelete";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} receiver The object that will execute the command
 * @private
 */
CommandDelete.prototype.initObject = function (receiver) {
    var i,
        shape;

    // move the current selection to this.currentSelection array
    for (i = 0; i < receiver.getCurrentSelection().getSize() > 0; i += 1) {
        shape = receiver.getCurrentSelection().get(i);
        this.currentSelection.insert(shape);
    }

    // save the currentConnection of the canvas if possible
    if (receiver.currentConnection) {
        this.currentConnection = receiver.currentConnection;
    }

};
/**
 * Saves and destroys connections and shapes
 * @private
 * @param {Object} shape
 * @param {boolean} root True if `shape` is a root element in the tree
 * @param {boolean} [fillArray] If set to true it'll fill `this.relatedElements` with the objects erased
 * @return {boolean}
 */
CommandDelete.prototype.saveAndDestroy = function (shape, root, fillArray) {
    var i,
        child,
        parent,
        children = null,
        connection,
        canvas = shape.canvas;

    if (shape.hasOwnProperty("children")) {
        children = shape.children;
    }

    // special function to be called as an afterwards
    // BIG NOTE: doesn't have to delete html
    if (shape.destroy) {
        shape.destroy();
    }

    for (i = 0; i < children.getSize(); i += 1) {
        child = children.get(i);
        this.saveAndDestroy(child, false, fillArray);
    }

    while (shape.ports && shape.ports.getSize() > 0) {
        connection = shape.ports.getFirst().connection;
        if (fillArray) {
            this.relatedElements.push(connection);
        }

        this.stackCommandConnect.push(
            new CommandConnect(connection)
        );
        connection.saveAndDestroy();
    }

    // remove from the children array of its parent
    if (root) {
        parent = shape.parent;
        parent.getChildren().remove(shape);
        if (parent.isResizable()) {
            parent.resizeBehavior.updateResizeMinimums(shape.parent);
        }

        // remove from the currentSelection and from either the customShapes
        // arrayList or the regularShapes arrayList
        canvas.removeFromList(shape);

        // remove the html only from the root
        shape.html = $(shape.html).detach()[0];
    }
    if (fillArray) {
        this.relatedElements.push(shape);
    }
    return true;
};

/**
 * Executes the command
 * The steps are:
 *
 * 1. Retrieve the old currentSelection (saved in `this.initObject()`)
 * 2. Remove the shapes (detaching them from the DOM)
 * 3. Remove the currentConnection if there's one
 * 4. Trigger the remove event
 *
 * @chainable
 */
CommandDelete.prototype.execute = function () {
    var shape,
        i,
        canvas = this.receiver,
        currentConnection,
        stringified,
        fillArray = false,
        mainShape = null;
    if (this.relatedElements.length === 0) {
        fillArray = true;
    }

    canvas.emptyCurrentSelection();

    // copy from this.currentConnection
    for (i = 0; i < this.currentSelection.getSize(); i += 1) {
        shape = this.currentSelection.get(i);
        canvas.addToSelection(shape);
    }
    if (canvas.currentSelection.getSize() === 1) {
        mainShape = shape;
    }
    // remove the elements in the canvas current selection

    stringified = [];
    while (canvas.getCurrentSelection().getSize() > 0) {
        shape = canvas.getCurrentSelection().getFirst();


//        // TESTING JSON
//        canvas.stringifyTest(JSON.stringify(
//            shape.stringify()
//        ));

        this.saveAndDestroy(shape, true, fillArray);

        stringified.push(shape.stringify());
//        this.saveAndDestroy(shape, true);

    }
//    // TESTING JSON
//    canvas.stringifyTest(JSON.stringify(
//        stringified
//    ));

    // destroy the currentConnection
    canvas.currentConnection = this.currentConnection;
    currentConnection = canvas.currentConnection;
    if (currentConnection) {

//        // TESTING JSON
//        canvas.stringifyTest(JSON.stringify(
//            this.currentConnection.stringify()
//        ));

        // add to relatedElements just in the case when only a connection is
        // selected and deleted
        this.relatedElements.push(currentConnection);

        this.stackCommandConnect.push(
            new CommandConnect(currentConnection)
        );

        currentConnection.saveAndDestroy();
        currentConnection = null;
    }
    canvas.triggerRemoveEvent(mainShape, this.relatedElements);
    return this;
};

/**
 * Inverse executes the command a.k.a. undo
 *
 * The steps are:
 *
 * 1. Retrieve the old currentSelection (saved in `this.initObject()`)
 * 2. Restore the shapes (attaching them to the DOM)
 * 3. Restore the currentConnection if there was one
 * 4. Trigger the create event
 *
 * @chainable
 */
CommandDelete.prototype.undo = function () {
    // undo recreates the shapes
    var i,
        shape,
        mainShape = this.receiver.currentSelection.getFirst();

    for (i = 0; i < this.currentSelection.getSize(); i += 1) {
        shape = this.currentSelection.get(i);

        // add to the canvas array of regularShapes and customShapes
        shape.canvas.addToList(shape);

        // add to the children of the parent
        shape.parent.getChildren().insert(shape);
        shape.parent.html.appendChild(shape.getHTML());
        ResizeBehavior.prototype.updateResizeMinimums(shape.parent);

        shape.showOrHideResizeHandlers(false);
    }
    // reconnect using the stack of commandConnect
    for (i = this.stackCommandConnect.length - 1; i >= 0; i -= 1) {
        this.stackCommandConnect[i].redo();
    }

    this.receiver.triggerCreateEvent(mainShape, this.relatedElements);
    return this;
};

/**
 * Executes the command (a.k.a redo)
 * @chainable
 */
CommandDelete.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandPaste
 * Class CommandPaste determines the actions executed when some shapes are pasted (redo) and the actions
 * executed when they're removed (undo).
 *
 * Instances of this class are created in {@link Canvas#paste}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandPaste
 * @param {Object} receiver The object that will execute the command
 * @param {Object} options Initialization options
 * @cfg {Array} [stackCommandConnect=[]] Array of commands connect
 * @cfg {Array} [stackCommandCreate=[]] Array of commands create
 */
CommandPaste = function (receiver, options) {

    Command.call(this, receiver);

    /**
     * A stack of commandsConnect (for connections)
     * @property {Array}
     */
    this.stackCommandConnect = [];

    /**
     * A stack of commandsCreate (for shapes)
     * @property {Array}
     */
    this.stackCommandCreate = [];

    CommandPaste.prototype.initObject.call(this, receiver, options);
};

CommandPaste.prototype = new Command();

/**
 * Type of command
 * @property {String}
 */
CommandPaste.prototype.type = "CommandPaste";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} receiver The object that will execute the command
 * @private
 */
CommandPaste.prototype.initObject = function (receiver, options) {
    var i,
        shape,
        defaults = {
            stackCommandConnect: [],
            stackCommandCreate: []
        };

    $.extend(true, defaults, options);

    this.stackCommandConnect = defaults.stackCommandConnect;
    this.stackCommandCreate = defaults.stackCommandCreate;

};

/**
 * Executes the command.
 * The steps are:
 *
 * 1. Execute the redo operation for each command create
 * 2. Execute the redo operation for each command connect
 *
 * @chainable
 */
CommandPaste.prototype.execute = function () {
    var i,
        command;
    for (i = 0; i < this.stackCommandCreate.length; i += 1) {
        command = this.stackCommandCreate[i];
        command.redo();
    }
    for (i = 0; i < this.stackCommandConnect.length; i += 1) {
        command = this.stackCommandConnect[i];
        command.redo();
    }
    return this;
};

/**
 * Inverse executes the command a.k.a. undo.
 * The steps are:
 *
 * 1. Execute the undo operation for each command create
 * 2. Execute the undo operation for each command connect
 *
 * @chainable
 */
CommandPaste.prototype.undo = function () {
    var i,
        command;
    for (i = 0; i < this.stackCommandCreate.length; i += 1) {
        command = this.stackCommandCreate[i];
        command.undo();
    }
    for (i = 0; i < this.stackCommandConnect.length; i += 1) {
        command = this.stackCommandConnect[i];
        command.undo();
    }
    return this;
};

/**
 * Executes the command a.k.a redo
 * @chainable
 */
CommandPaste.prototype.redo = function () {
    this.execute();
    return this;
};

/**
 * @class CommandEditLabel
 * Encapsulates the action of editing a label
 *
 *                  //i.e.
 *                  // var command = new CommandEditLabel(label, "new message");
 * @extends Command
 *
 * @constructor
 * Creates an instance of this command
 * @param {Label} receiver The object that will perform the action
 * @param {String} newMessage
 */
CommandEditLabel = function (receiver, newMessage) {
    Command.call(this, receiver);
    this.before = null;
    this.after = null;
    CommandEditLabel.prototype.initObject.call(this, receiver, newMessage);
};

CommandEditLabel.prototype = new Command();
/**
 * Type of the instances
 * @property {String}
 */
CommandEditLabel.prototype.type = "CommandEditLabel";
/**
 * Initializes the command
 * @param {Label} receiver The object that will perform the action
 * @param {String} newMessage
 */
CommandEditLabel.prototype.initObject = function (receiver, newMessage) {
    var parentHeight = 0,
        parentWidth = 0;
    if (receiver.parent) {
        parentHeight = receiver.parent.height;
        parentWidth = receiver.parent.width;
    }
    this.before = {
        message : receiver.message,
        width : receiver.width,
        height : receiver.height,
        parentHeight : parentHeight,
        parentWidth : parentWidth
    };
    this.after = {
        message : newMessage,
        width : 0,
        height : 0,
        parentHeight: parentWidth,
        parentWidth: parentHeight
    };
};
/**
 * Executes the command, sets the new message updates the dimensions and its,
 * parent if necessary
 */
CommandEditLabel.prototype.execute = function (stopTrigger) {
    this.receiver.setMessage(this.after.message);
    this.receiver.updateDimension();
    if (this.after.width === 0) {
        this.after.width = this.receiver.width;
        this.after.height = this.receiver.height;
        if (this.after.parentWidth !== 0) {
            this.after.parentWidth = this.receiver.parent.width;
            this.after.parentHeight = this.receiver.parent.height;
        }
    }
    this.receiver.paint();
    if (!stopTrigger) {
        this.receiver.canvas.triggerTextChangeEvent(this.receiver,
            this.before.message, this.after.message);
        if ((this.after.parentWidth !== this.before.parentWidth) &&
                (this.before.parentHeight !== this.after.parentHeight)) {
            this.receiver.canvas.triggerDimensionChangeEvent
                (
                    this.receiver.parent,
                    this.before.parentWidth,
                    this.before.parentHeight,
                    this.after.parentWidth,
                    this.after.parentHeight
                );
        }
    }
};
/**
 * Returns to the previous state before executing the command
 */
CommandEditLabel.prototype.undo = function (stopTrigger) {
    this.receiver.setMessage(this.before.message);

    if (this.receiver.parent) {
        this.receiver.parent.setDimension(this.before.parentWidth,
                this.before.parentHeight);
    }
    this.receiver.setDimension(this.before.width, this.before.height);
    this.receiver.updateDimension();
    this.receiver.paint();
    this.receiver.canvas.triggerTextChangeEvent(this.receiver,
        this.after.message, this.before.message);
    if ((this.after.parentWidth !== this.before.parentWidth) &&
            (this.before.parentHeight !== this.after.parentHeight)) {
        this.receiver.canvas.triggerDimensionChangeEvent(this.receiver.parent,
            this.after.parentWidth, this.after.parentHeight,
            this.before.parentWidth, this.before.parentHeight);
    }
};
/**
 * Executes the command again after an undo action has been done
 */
CommandEditLabel.prototype.redo = function () {
    this.execute();
};

/**
 * @abstract
 * @class ContainerBehavior
 * Object that encapsulates the container of shapes, this is an abstract class,
 * so all its methods should be implemented by its subclasses

 * @constructor
 * Creates a new instance of the class
 */
ContainerBehavior  = function () {
};
/**
 * Type of the instances
 * @property {String}
 */
ContainerBehavior.prototype.type = "ContainerBehavior";
/**
 * Family of the instances
 * @property {String}
 */
ContainerBehavior.prototype.family = "ContainerBehavior";
/**
 * @abstract
 * Sets a shape's container to a given container
 * @param {BehavioralElement} container element using this behavior
 * @param {Shape} shape shape to be added
 * @template
 * @protected
 */
ContainerBehavior.prototype.addToContainer = function (container, shape, x, y,
                                                            topLeftCorner) {
};
/**
 * @abstract
 * Removes shape from its current container
 * @param {Shape} shape shape to be removed
 * @template
 * @protected
 */
ContainerBehavior.prototype.removeFromContainer = function (shape) {
};
/**
 * @abstract
 * Adds a shape to a given container
 * @param {BehavioralElement} container container element using this behavior
 * @param {Shape} shape shape to be added to the container
 * @template
 * @protected
 */
ContainerBehavior.prototype.addShape = function (container, shape, x, y) {
};
/**
 * Returns whether a shape is a container or not
 * @return {boolean}
 */
ContainerBehavior.prototype.isContainer = function () {
    return false;
};


/**
 * @class RegularContainerBehavior
 * Encapsulates the behavior of a regular container
 * @extends ContainerBehavior
 *
 * @constructor
 * Creates a new instance of the class
 */

RegularContainerBehavior = function () {
};

RegularContainerBehavior.prototype = new ContainerBehavior();
/**
 * Type of the instances
 * @property {String}
 */
RegularContainerBehavior.prototype.type = "RegularContainerBehavior";
/**
 * Adds a shape to a given container given its coordinates
 * @param {BehavioralElement} container container using this behavior
 * @param {Shape} shape shape to be added
 * @param {number} x x coordinate where the shape will be added
 * @param {number} y y coordinate where the shape will be added
 * @param {boolean} topLeftCorner Determines whether the x and y coordinates
 * will be considered from the top left corner or from the center
 */
RegularContainerBehavior.prototype.addToContainer = function (container,
                                                              shape, x, y,
                                                              topLeftCorner) {
    var shapeLeft = 0,
        shapeTop = 0,
        shapeWidth,
        shapeHeight,
        canvas,
        topLeftFactor = (topLeftCorner === true) ? 0 : 1;

    if (container.family === "Canvas") {
        canvas = container;
    } else {
        canvas = container.canvas;
    }


    shapeWidth = shape.getZoomWidth();
    shapeHeight = shape.getZoomHeight();

    shapeLeft += x - (shapeWidth / 2) * topLeftFactor;
    shapeTop += y - (shapeHeight / 2) * topLeftFactor;

    shapeLeft /= canvas.zoomFactor;
    shapeTop /= canvas.zoomFactor;

    shape.setParent(container);
    container.getChildren().insert(shape);
    this.addShape(container, shape, shapeLeft, shapeTop);

    // fix the zIndex of this shape and it's children
    shape.fixZIndex(shape, 0);

    // fix resize minWidth and minHeight and also fix the dimension
    // of this shape (if a child made it grow)
    container.updateDimensions(10);

    // adds the shape to either the customShape arrayList or the regularShapes
    // arrayList if possible
    canvas.addToList(shape);
};
/**
 * Removes a shape from the container implementing this behavior
 * @param {Shape} shape shape to be removed
 */
RegularContainerBehavior.prototype.removeFromContainer = function (shape) {
    var parent = shape.parent;
    parent.getChildren().remove(shape);
    if (parent.isResizable()) {
        parent.resizeBehavior.updateResizeMinimums(shape.parent);
    }
    shape.parent = null;
};
/**
 * Sets the position of the shape, and append its html
 * @param {BehavioralElement} container element implementing this behavior
 * @param {Shape} shape shape added to the container
 * @param {number} x x coordinate of the position that will be set relative to
 * the container
 * @param {number} y y coordinate of the position that will be set relative to
 * the container
 * @chainable
 */
RegularContainerBehavior.prototype.addShape = function (container, shape, x,
                                                        y) {
    shape.setPosition(x, y);
    //insert the shape HTML to the DOM
    //console.log(container.html);
    //console.log(shape.getHTML());
    container.getHTML().appendChild(shape.getHTML());

    shape.paint();
    shape.updateHTML();
    return this;

};


/**
 * @class NoContainerBehavior
 * Encapsulates the behavior of elements that has no container behavior, useful
 * for implementing the strategy pattern
 * @extends ContainerBehavior
 *
 *
 * @constructor
 * Creates a new instance of the class
 */
NoContainerBehavior = function () {
};

NoContainerBehavior.prototype = new ContainerBehavior();
/**
 * Type of the instances
 * @property {String}
 */
NoContainerBehavior.prototype.type = "NoContainerBehavior";

/**
 * @abstract
 * @class DragBehavior
 * Abstract class that encapsulates the drag behavior of an object
 *
 * @constructor Creates a new instance of the class
 *
 */
DragBehavior = function () {
};

/**
 * Type of the object
 * @property {String}
 */
DragBehavior.prototype.type = "DragBehavior";
/**
 * Family of the object
 * @property {String}
 */
DragBehavior.prototype.family = "DragBehavior";


/**
 * Attach the drag listener and its corresponding ui properties to the shape
 * @param {Shape} shape
 */
DragBehavior.prototype.attachDragBehavior = function (shape) {
    var dragOptions,
        $shape = $(shape.getHTML());
    dragOptions = {
        revert : false,
        helper : "none",
        cursorAt : false,
        revertDuration : 0,
        grid : [1, 1],
        start : this.onDragStart(shape),
        drag : this.onDrag(shape),
        stop : this.onDragEnd(shape)
    };
    $shape.draggable(dragOptions);
};
/**
 * @event dragStart
 * @abstract drag start handler, function that runs when the drag start event occurs,
 * it should return a function so that any implementation should go inside the
 * return
 * @param {Shape} shape current shape being dragged
 * @template
 * @protected
 */
DragBehavior.prototype.onDragStart = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event drag
 * Drag handler, function that runs when dragging is occurring,
 * it should return a function so that any implementation should go inside the
 * return
 * @param {Shape} shape shape being dragged
 * @template
 * @protected
 */
DragBehavior.prototype.onDrag = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event dragEnd
 * Drag end handler, function that runs when the drag end event occurs,
 * it should return a function so that any implementation should go inside the
 * return
 * @param {Shape} shape
 * @template
 * @protected
 */
DragBehavior.prototype.onDragEnd = function (shape) {
    return function (e, ui) {
    };
};
/**
 * @abstract Executes the hook Function for the drag start event
 * @template
 * @protected
 */
DragBehavior.prototype.dragStartHook = function (hookFunction) {
};

/**
 * @abstract Executes the hook function for the drag event
 * @template
 * @protected
 */
DragBehavior.prototype.dragHook = function (hookFunction) {
};
/**
 * @abstract Executes the hook function for the drag end event
 * @template
 * @protected
 */
DragBehavior.prototype.dragEndHook = function () {
};

/**
 * @class RegularDragBehavior
 * Class that encapsulates the regular drag behavior of a shape
 * @extends DragBehavior
 *
 * @constructor Creates a new instance of the class
 *
 */
RegularDragBehavior = function () {
};

RegularDragBehavior.prototype = new DragBehavior();
/**
 * Type of the object
 * @property {String}
 */
RegularDragBehavior.prototype.type = "RegularDragBehavior";
/**
 * Attach the drag behavior to a given shape
 * @param {Shape} shape
 */
RegularDragBehavior.prototype.attachDragBehavior = function (shape) {
    var $shape = $(shape.getHTML());
    DragBehavior.prototype.attachDragBehavior.call(this, shape);
    $shape.draggable({'cursor' : "move"});
};
/**
 * On drag start handler, initializes everything that is needed for a shape to
 * be dragged
 * @param {Shape} shape
 * @return {Function}
 */
RegularDragBehavior.prototype.onDragStart = function (shape) {
    return function (e, ui) {
        var canvas = shape.canvas,
            currentLabel = canvas.currentLabel,
            selectedShape,
            i;

        // hide the current connection if there was one
        canvas.hideCurrentConnection();
        if (currentLabel) {
            currentLabel.loseFocus();
            $(currentLabel.textField).focusout();
        }

        if (!canvas.currentSelection.contains(shape)) {
            canvas.emptyCurrentSelection();     /* ALSO DECREASES THE Z-INDEX */
            canvas.addToSelection(shape);
        }

        // added by mauricio
        // these lines must be here and not in the top (currentSelection
        // is updated in the if above)
        for (i = 0; i < canvas.currentSelection.getSize(); i += 1) {
            selectedShape = canvas.currentSelection.get(i);
            selectedShape.setOldX(selectedShape.getX());
            selectedShape.setOldY(selectedShape.getY());
            selectedShape.setOldParent(selectedShape.getParent());
        }

        // increase shape's ancestors zIndex
        shape.increaseParentZIndex(shape.getParent());
        return true;
    };
};
/**
 * On drag handler, sets the position of the shape to current position of the
 * shape in the screen
 * @param {Shape} shape
 * @return {Function}
 */
RegularDragBehavior.prototype.onDrag = function (shape) {
    return function (e, ui) {

        shape.setPosition(ui.helper.position().left,
            ui.helper.position().top);

        // show or hide the snappers
        shape.canvas.showOrHideSnappers(shape);
    };
};
/**
 * On drag end handler, set the final position of the shape and fires the
 * command move
 * @param {Shape} shape
 * @return {Function}
 */
RegularDragBehavior.prototype.onDragEnd = function (shape) {
    return function (e, ui) {
        var command;
//        var currentSelection = shape.getCanvas().getCurrentSelection();
        shape.setPosition(ui.helper.position().left,
            ui.helper.position().top);

        // decrease the zIndex of the oldParent of this shape
        shape.decreaseParentZIndex(shape.oldParent);

        shape.dragging = false;

        // hide the snappers
        shape.canvas.verticalSnapper.hide();
        shape.canvas.horizontalSnapper.hide();
        if (!shape.changedContainer) {
            command = new CommandMove(shape);
            command.execute();
            shape.canvas.commandStack.add(command);
        }
        shape.changedContainer = false;
        // update current selection zIndex
//        for (i = 0; i < currentSelection.getSize(); i += 1) {
//            shape = currentSelection.get(i);
//            shape.increaseZIndex();
//        }
    };
};

/**
 * @class NoDragBehavior
 * Class that encapsulates the drag behavior corresponding to the elements that
 * cannot be dragged
 * @extends DragBehavior
 *
 * @constructor Creates a new instance of the class
 *
 */
NoDragBehavior = function () {
};

NoDragBehavior.prototype = new DragBehavior();
/**
 * Type of the instances
 * @property {String}
 */
NoDragBehavior.prototype.type = "NoDragBehavior";

/**
 * On drag start handler, this method prevents drag from occurring
 * @param {Shape} shape
 * @return {Function}
 */
NoDragBehavior.prototype.onDragStart = function (shape) {
    // hide the current connection if there was one
    return function (e, ui) {
        shape.canvas.hideCurrentConnection();
        return false;
    };
};

/**
 * @class ConnectionDragBehavior
 * Class that encapsulates the behavior for a connection drag.
 * A connection drag behavior means that instead of moving a shape when dragging
 * occurs, it creates a connection segment that let's us connect to shapes
 * @extends DragBehavior
 *
 * @constructor Creates a new instance of the class
 *
 */
ConnectionDragBehavior = function () {
};

ConnectionDragBehavior.prototype = new DragBehavior();
/**
 * Type of the instances
 * @property {String}
 */
ConnectionDragBehavior.prototype.type = "ConnectionDragBehavior";
/**
 * Attach the drag behavior and ui properties to the corresponding shape
 * @param {Shape} shape
 */
ConnectionDragBehavior.prototype.attachDragBehavior = function (shape) {
    var $shape = $(shape.getHTML()),
        dragOptions;
    dragOptions = {
        helper : shape.createDragHelper,
        cursorAt : {top : 0, left : 0},
        revert : true
    };
    DragBehavior.prototype.attachDragBehavior.call(this, shape);
    $shape.draggable(dragOptions);
    $shape.draggable('enable');
};
/**
 * On drag start handler, initializes all properties needed to start a
 * connection drag
 * @param {CustomShape} customShape
 * @return {Function}
 */
ConnectionDragBehavior.prototype.onDragStart = function (customShape) {
    return function (e, ui) {
        var canvas  = customShape.canvas,
            currentLabel = canvas.currentLabel;

        // empty the current selection so that the segment created by the
        // helper is always on top
        customShape.canvas.emptyCurrentSelection();

        if (currentLabel) {
            currentLabel.loseFocus();
            $(currentLabel.textField).focusout();
        }
        if (customShape.family !== "CustomShape") {
            return false;
        }
        customShape.setOldX(customShape.getX());
        customShape.setOldY(customShape.getY());
        customShape.startConnectionPoint.x += customShape.getAbsoluteX();
        customShape.startConnectionPoint.y += customShape.getAbsoluteY();
//        customShape.increaseParentZIndex(customShape.parent);
        return true;

    };
};
/**
 * On drag handler, creates a connection segment from the shape to the current
 * mouse position
 * @param {CustomShape} customShape
 * @return {Function}
 */
ConnectionDragBehavior.prototype.onDrag = function (customShape) {
    return function (e, ui) {
        var canvas = customShape.getCanvas(),
            endPoint = new Point();
        if (canvas.connectionSegment) {
            //remove the connection segment in order to create another one
            $(canvas.connectionSegment.getHTML()).remove();
        }

        //Determine the point where the mouse currently is
        endPoint.x = e.pageX - canvas.getX() + canvas.getLeftScroll();
        endPoint.y = e.pageY - canvas.getY() + canvas.getTopScroll();

        //creates a new segment from where the helper was created to the
        // currently mouse location

        canvas.connectionSegment = new Segment({
            startPoint : customShape.startConnectionPoint,
            endPoint : endPoint,
            parent : canvas,
            zOrder: Style.MAX_ZINDEX * 2
        });
        //We make the connection segment point to helper in order to get
        // information when the drop occurs
        canvas.connectionSegment.pointsTo = customShape;
        //create HTML and paint
        //canvas.connectionSegment.createHTML();
        canvas.connectionSegment.paint();
    };

};
/**
 * On drag end handler, deletes the connection segment created while dragging
 * @param {CustomShape} customShape
 * @return {Function}
 */
ConnectionDragBehavior.prototype.onDragEnd = function (customShape) {
    return function (e, ui) {
        if (customShape.canvas.connectionSegment) {
            //remove the connection segment left
            $(customShape.canvas.connectionSegment.getHTML()).remove();
        }
        customShape.setPosition(customShape.getOldX(), customShape.getOldY());
        customShape.dragging = false;
    };
};

/**
 * @class CustomShapeDragBehavior
 * Encapsulates the drag behavior of a custom shape (with ports and connections)
 * , it also encapsulates the behavior for multiple drag
 * @extends DragBehavior
 *
 * @constructor Creates a new instance of the class
 *
 */
CustomShapeDragBehavior = function () {
};

CustomShapeDragBehavior.prototype = new DragBehavior();
/**
 * Type of the instances
 * @property {String}
 */
CustomShapeDragBehavior.prototype.type = "CustomShapeDragBehavior";
/**
 * Attach the drag behavior and ui properties to the corresponding shape
 * @param {CustomShape} customShape
 */
CustomShapeDragBehavior.prototype.attachDragBehavior = function (customShape) {
    var dragOptions,
        $customShape = $(customShape.getHTML());
    dragOptions = {
        revert : false,
        helper : "none",
        cursorAt : false,
        revertDuration : 0,
        disable : false,
        grid : [1, 1],
        start : this.onDragStart(customShape),
        drag : this.onDrag(customShape, true),
        stop : this.onDragEnd(customShape, true)
    };
    $customShape.draggable(dragOptions);
};

//TODO Encapsulates behaviors for multiple drag, and simple custom shape drag
//TODO Initialize all oldX and oldY values
/**
 * On drag start handler, it uses the {@link RegularDragBehavior}.onDragStart
 * method to initialize the drag, but also initializes other properties
 * @param {CustomShape} customShape
 * @return {Function}
 */
CustomShapeDragBehavior.prototype.onDragStart = function (customShape) {
    return function (e, ui) {
        RegularDragBehavior.prototype.onDragStart.call(this,
            customShape)(e, ui);

        customShape.previousXDragPosition = customShape.getX();
        customShape.previousYDragPosition = customShape.getY();

        //init snappers
        customShape.canvas.startSnappers(e);
    };
};
/**
 * Procedure executed while dragging, it takes care of multiple drag, moving
 * connections, updating positions and children of the shapes being dragged
 * @param {CustomShape} customShape shape being dragged
 * @param {boolean} root return whether this is the shape where the drag started
 * @param {number} childDiffX x distance needed for the non-root shapes to move
 * @param {number} childDiffY y distance needed for the non-root shapes to move
 * @param {Object} e jQuery object containing the properties when a drag event
 * occur
 * @param {Object} ui JQuery UI object containing the properties when a drag
 * event occur
 */
CustomShapeDragBehavior.prototype.onDragProcedure = function (customShape, root,
                                                     childDiffX, childDiffY,
                                                     e, ui) {
    var i,
        j,
        sibling,
        diffX,
        diffY,
        port,
        child,
        connection,
        shape1,
        shape2,
        canvas = customShape.canvas;
    // shapes
    if (root) {
        if (customShape.canvas.snapToGuide) {
            customShape.canvas.processGuides(e, ui, customShape);
        } else {
//            customShape.setPosition(ui.helper.position().left / canvas.zoomFactor,
//                ui.helper.position().top / canvas.zoomFactor);
        }
        customShape.setPosition(ui.helper.position().left / canvas.zoomFactor,
            ui.helper.position().top / canvas.zoomFactor);
        //console.log(customShape.x+','+customShape.y);
        diffX = customShape.x - customShape.previousXDragPosition;
        diffY = customShape.y - customShape.previousYDragPosition;

        customShape.previousXDragPosition = customShape.x;
        customShape.previousYDragPosition = customShape.y;

        for (i = 0; i < customShape.canvas.currentSelection.getSize(); i += 1) {
            sibling = customShape.canvas.currentSelection.get(i);
            if (sibling.id !== customShape.id) {
                sibling.setPosition(sibling.x + diffX, sibling.y + diffY);
            }
        }
    } else {
        customShape.setPosition(customShape.x, customShape.y);
    }

    // children
    if (root) {
        for (i = 0; i < customShape.canvas.currentSelection.getSize(); i += 1) {
            sibling = customShape.canvas.currentSelection.get(i);
            for (j = 0; j < sibling.children.getSize(); j += 1) {
                child = sibling.children.get(j);
                CustomShapeDragBehavior.prototype.onDragProcedure.call(this, child,
                    false, diffX, diffY, e, ui);
            }
        }
    } else {
        for (i = 0; i < customShape.children.getSize(); i += 1) {
            child = customShape.children.get(i);
            CustomShapeDragBehavior.prototype.onDragProcedure.call(this, child,
                false, childDiffX, childDiffY, e, ui);
        }
    }

    // connections
    if (root) {
        for (i = 0; i < customShape.canvas.currentSelection.getSize(); i += 1) {
            sibling = customShape.canvas.currentSelection.get(i);
            for (j = 0; j < sibling.ports.getSize(); j += 1) {
                //for each port update its absolute position and repaint its connection
                port = sibling.ports.get(j);
                connection = port.connection;

                port.setPosition(port.x, port.y);

                if (customShape.canvas.sharedConnections.
                        find('id', connection.getID())) {
                    // move the segments of this connections
                    if (connection.srcPort.parent.getID() ===
                            sibling.getID()) {
                        // to avoid moving the connection twice
                        // (two times per shape), move it only if the shape
                        // holds the sourcePort
                        connection.move(diffX * canvas.zoomFactor,
                            diffY * canvas.zoomFactor);
                    }
                } else {
                    connection
                        // repaint: false
                        //.setSegmentColor(Color.GREY, false)
                        //.setSegmentStyle("regular", false) // repaint: false
                        .disconnect()
                        .connect();
                }
            }
        }
    } else {
        for (i = 0; i < customShape.ports.getSize(); i += 1) {
            //for each port update its absolute position and repaint its connection
            port = customShape.ports.get(i);
            connection = port.connection;
            shape1 = connection.srcPort.parent;
            shape2 = connection.destPort.parent;

            port.setPosition(port.x, port.y);

            if (customShape.canvas.sharedConnections.
                    find('id', connection.getID())) {
                // to avoid moving the connection twice
                // (two times per shape), move it only if the shape
                // holds the sourcePort
                if (connection.srcPort.parent.getID() ===
                        customShape.getID()) {
                    connection.move(childDiffX * canvas.zoomFactor,
                            childDiffY * canvas.zoomFactor);
                }
            } else {
                connection
                    // repaint: false
                    .setSegmentColor(Color.GREY, false)
                    .setSegmentStyle("regular", false)
                    .disconnect()
                    .connect();
            }
        }
    }
};
/**
 * On drag handler, calls the drag procedure while the dragging is occurring,
 * and also takes care of the snappers
 * @param {CustomShape} customShape shape being dragged
 * @param {boolean} root return whether this is the shape where the drag started
 * @param {number} childDiffX x distance needed for the non-root shapes to move
 * @param {number} childDiffY y distance needed for the non-root shapes to move
 * @return {Function}
 */
CustomShapeDragBehavior.prototype.onDrag = function (customShape, root,
                                                childDiffX, childDiffY) {
    var self = this;
    return function (e, ui) {

        // call to dragEnd procedure
        self.onDragProcedure(customShape, root, childDiffX,
            childDiffY, e, ui);

    };
};
/**
 * Procedure executed on drag end, it takes care of multiple drag, moving
 * connections, updating positions and children of the shapes being dragged
 * @param {CustomShape} customShape shape being dragged
 * @param {boolean} root return whether this is the shape where the drag started
 * @param {Object} e jQuery object containing the properties when a drag event
 * occur
 * @param {Object} ui JQuery UI object containing the properties when a drag
 * event occur
 */
CustomShapeDragBehavior.prototype.dragEndProcedure = function (customShape,
                                                                 root, e, ui) {
    var i,
        j,
        sibling,
        port,
        child,
        connection,
        shape1,
        shape2,
        canvas = customShape.canvas;

    // shapes
    if (root) {

        // the difference between this segment of code and the segment of code
        // found in dragProcedure is that it's not needed to move the shapes
        // anymore using differentials
            customShape.setPosition(ui.helper.position().left / canvas.zoomFactor,
                ui.helper.position().top / canvas.zoomFactor);
            customShape.wasDragged = true;

//        for (i = 0; i < customShape.canvas.currentSelection.getSize();
//                i += 1) {
//            sibling = customShape.canvas.currentSelection.get(i);
//           sibling.setPosition(sibling.x, sibling.y);
//        }

    } else {
        customShape.setPosition(customShape.x, customShape.y);
    }

    // children
    if (root) {
        for (i = 0; i < customShape.canvas.currentSelection.getSize();
                i += 1) {
            sibling = customShape.canvas.currentSelection.get(i);
            for (j = 0; j < sibling.children.getSize(); j += 1) {
                child = sibling.children.get(j);
                child.changedContainer = true;
                CustomShapeDragBehavior.prototype.dragEndProcedure.call(this,
                    child, false, e, ui);
            }
        }
    } else {
        for (i = 0; i < customShape.children.getSize(); i += 1) {
            child = customShape.children.get(i);
            CustomShapeDragBehavior.prototype.dragEndProcedure.call(this,
                child, false, e, ui);
        }
    }

    // connections
    if (root) {
        for (i = 0; i < customShape.canvas.currentSelection.getSize();
                i += 1) {
            sibling = customShape.canvas.currentSelection.get(i);
            for (j = 0; j < sibling.ports.getSize(); j += 1) {

                // for each port update its absolute position and repaint
                // its connection
                port = sibling.ports.get(j);
                connection = port.connection;

                port.setPosition(port.x, port.y);

                if (customShape.canvas.sharedConnections.
                        find('id', connection.getID())) {
                    // move the segments of this connections
                    if (connection.srcPort.parent.getID() ===
                            sibling.getID()) {
                        // to avoid moving the connection twice
                        // (two times per shape), move it only if the shape
                        // holds the sourcePort
                        connection.disconnect(true).connect({
                            algorithm: 'user',
                            points: connection.points,
                            dx: parseFloat($(connection.html).css('left')),
                            dy: parseFloat($(connection.html).css('top'))
                        });
                        connection.checkAndCreateIntersectionsWithAll();
                    }
                } else {
                    connection
                        // repaint: false
                        .setSegmentColor(connection.originalSegmentColor, false)
                        .setSegmentStyle(connection.originalSegmentStyle, false);
                        //.disconnect()
                        //.connect();
                    connection.setSegmentMoveHandlers();
                    connection.checkAndCreateIntersectionsWithAll();
                }
            }
        }
    } else {
        for (i = 0; i < customShape.ports.getSize(); i += 1) {
            //for each port update its absolute position and repaint
            //its connection
            port = customShape.ports.get(i);
            connection = port.connection;
            shape1 = connection.srcPort.parent;
            shape2 = connection.destPort.parent;

            port.setPosition(port.x, port.y);
            if (customShape.canvas.sharedConnections.
                    find('id', connection.getID())) {
                // to avoid moving the connection twice
                // (two times per shape), move it only if the shape
                // holds the sourcePort
                if (connection.srcPort.parent.getID() ===
                        customShape.getID()) {
                    connection.checkAndCreateIntersectionsWithAll();
                }
            } else {
                connection
                    // repaint: false
                    .setSegmentColor(connection.originalSegmentColor, false)
                    .setSegmentStyle(connection.originalSegmentStyle, false)
                    .disconnect()
                    .connect();
                connection.setSegmentMoveHandlers();
                connection.checkAndCreateIntersectionsWithAll();
            }
        }
    }

};
/**
 * On drag end handler, ot calls drag end procedure, removes the snappers and,
 * fires the command move if necessary
 * @param {CustomShape} customShape
 * @return {Function}
 */
CustomShapeDragBehavior.prototype.onDragEnd = function (customShape) {
    var command,
        self = this;
    return function (e, ui) {

        // call to dragEnd procedure
        self.dragEndProcedure(customShape, true, e, ui);

        customShape.dragging = false;

        // hide the snappers
        customShape.canvas.verticalSnapper.hide();
        customShape.canvas.horizontalSnapper.hide();

        if (!customShape.changedContainer) {

            command = new CommandMove(customShape.canvas.currentSelection);
            command.execute();
            customShape.canvas.commandStack.add(command);
        }
        customShape.changedContainer = false;

        // decrease the zIndex of the oldParent of customShape
        customShape.decreaseParentZIndex(customShape.oldParent);
    };
};

/**
 * @abstract
 * @class ResizeBehavior
 * Abstract class which inherited classes' instances are used for delegation of the resize behavior of a shape.
 *
 * @constructor Creates an instance of the class ResizeBehavior
 */
ResizeBehavior = function () {
};

/**
 * The type of each instance of this class.
 * @property {String}
 */
ResizeBehavior.prototype.type = "ResizeBehavior";

/**
 * The family of each instance of this class.
 * @property {String}
 */
ResizeBehavior.prototype.family = "ResizeBehavior";


/**
 * Initialize JQueryUI's resize plugin
 * @param {Shape} shape
 */
ResizeBehavior.prototype.init = function (shape) {
    var $shape = $(shape.getHTML()),
        shapeResizeOptions = {
            handles: shape.getHandlesIDs(),
            disable: false,
            start: this.onResizeStart(shape),
            resize: this.onResize(shape),
            stop: this.onResizeEnd(shape)
        };
    $shape.resizable(shapeResizeOptions);

    // update the min height and min width of the parent
    this.updateResizeMinimums(shape.parent);
};

/**
 * @abstract
 * @event resizeStart
 * Abstract method to be implemented in inherited classes
 * @param {Shape} shape
 */
ResizeBehavior.prototype.onResizeStart = function (shape) {
};
/**
 * @abstract
 * @event resize
 * Abstract method to be implemented in inherited classes
 * @param {Shape} shape
 */
ResizeBehavior.prototype.onResize = function (shape) {
};
/**
 * @abstract
 * @event resizeEnd
 * Abstract method to be implemented in inherited classes
 * @param {Shape} shape
 */
ResizeBehavior.prototype.onResizeEnd = function (shape) {
};

///**
// * Sets a shape's container to a given container
// * @param container
// * @param shape
// */
//ResizeBehavior.prototype.resizeStartHook = function () {
//};
///**
// * Removes shape from its current container
// * @param shape
// */
//ResizeBehavior.prototype.resizeHook = function () {
//};
///**
// * Adds a shape to a given container
// * @param container
// * @param shape
// */
//ResizeBehavior.prototype.resizeEndHook = function () {
//};

/**
 * Updates the minimum height and maximum height of the JQqueryUI's resizable plugin.
 * @param {Shape} shape
 * @chainable
 */
ResizeBehavior.prototype.updateResizeMinimums = function (shape) {
    var minW,
        minH,
        children = shape.getChildren(),
        limits = children.getDimensionLimit(),
        margin = 15,
        $shape = $(shape.getHTML());

    // TODO: consider the labels width and height
//    if (subProcess.label.orientation === 'vertical') {
//        minW = Math.max(limits[1], Math.max(labelH, subProcess.label.height)) +
//            margin + 8;
//        minH = Math.max(limits[2], Math.max(labelW, subProcess.label.width)) +
//            margin;
//    } else {
//        minW = Math.max(limits[1], Math.max(labelW, subProcess.label.width)) +
//            margin;
//        minH = Math.max(limits[2], Math.max(labelH, subProcess.label.height)) +
//            margin + 8;
//    }

    minW = limits[1] + margin;
    minH = limits[2] + margin;

    // update jQueryUI's minWidth and minHeight
    $shape.resizable('option', 'minWidth', minW);
    $shape.resizable('option', 'minHeight', minH);
    return this;
};

/**
 * @class RegularResizeBehavior
 * Class that encapsulates the regular resize behavior of a shape
 * @extends ResizeBehavior
 *
 * @constructor Creates a new instance of the class RegularResizeBehavior
 */
RegularResizeBehavior = function () {
};

RegularResizeBehavior.prototype = new ResizeBehavior();

/**
 * The type of each instance of this class
 * @property {String}
 */
RegularResizeBehavior.prototype.type = "RegularResizeBehavior";

/**
 * Initialize JQueryUI's resizable plugin
 * @param {Shape} shape
 */
RegularResizeBehavior.prototype.init = function (shape) {
    var $shape = $(shape.getHTML());
    ResizeBehavior.prototype.init.call(this, shape);
    $shape.resizable('enable');
    shape.applyStyleToHandlers('resizableStyle');

    // hide its handles (jQueryUI's resizable shows the handles by default)
    shape.showOrHideResizeHandlers(false);
};

/**
 * @event resizeStart
 * ResizeStart event fired when the user resizes a shape.
 * It does the following:
 *
 * - Save old values (for the undo-redo stack)
 * - Empties the {@link Canvas#property-currentSelection}, and adds `shape` to that arrayList
 * - Hides the resize handlers of the shape
 *
 * @param {Shape} shape
 */
RegularResizeBehavior.prototype.onResizeStart = function (shape) {
    return function (e, ui) {
        shape.resizing = true;
        shape.dragging = false;

        shape.oldWidth = shape.width;
        shape.oldHeight = shape.height;
        shape.oldX = shape.x;
        shape.oldY = shape.y;
        shape.oldAbsoluteX = shape.absoluteX;
        shape.oldAbsoluteY = shape.absoluteY;

        if (shape.ports) {
            shape.initPortsChange();
        }

        if (shape.canvas.currentSelection.getSize() > 1) {
            // empty current selection and add this item to the currentSelection
            shape.canvas.emptyCurrentSelection();
            shape.canvas.addToSelection(shape);
        }
        shape.showOrHideResizeHandlers(false);

        // calculate percentage of each label in each axis
        shape.calculateLabelsPercentage();
        return true;
    };
};

/**
 * @event resize
 * Resize event fired when the user is resizing a shape.
 * It does the following:
 *
 * - Sets the position and dimensions of the shape
 * - Fixes the ports of `shape` and from the its children (recursively)
 * - Updates the position of its labels
 *
 * @param {Shape} shape
 */
RegularResizeBehavior.prototype.onResize = function (shape) {
    return function (e, ui) {
        var i,
            port,
            canvas = shape.canvas;
        shape.setPosition(ui.position.left / canvas.zoomFactor,
                ui.position.top / canvas.zoomFactor);
        shape.setDimension(ui.size.width / canvas.zoomFactor,
                ui.size.height / canvas.zoomFactor);

        // fix the position of the shape's ports (and the positions and port
        // position of its children)
        // parameters (shape, resizing, root)
        shape.fixConnectionsOnResize(shape.resizing, true);

        // fix the labels positions on resize (on x = true and y = true)
        shape.updateLabelsPosition();
    };
};

/**
 * @event resizeEnd
 * ResizeEnd event fired when the user stops resizing a shape.
 * It does the following:
 *
 * - Shows the handlers of `shape`
 * - Updates the dimension of its parent (this shape might have outgrown the shape)
 * - Creates an instance of {@link CommandResize} to add it to the undo-redo stack
 *
 * @param {Shape} shape
 */
RegularResizeBehavior.prototype.onResizeEnd = function (shape) {
    return function (e, ui) {
        var i,
            label,
            command;
        shape.resizing = false;

        // last resize
        RegularResizeBehavior.prototype.onResize.call(this, shape)(e, ui);

        // show the handlers again
        shape.showOrHideResizeHandlers(true);

        // update the dimensions of the parent if possible (a shape might
        // have been resized out of the dimensions of its parent)
        shape.parent.updateDimensions(10);

        if (shape.ports) {
            shape.firePortsChange();
        }

        // TESTING COMMANDS
        command = new CommandResize(shape);
        shape.canvas.commandStack.add(command);
        command.execute();
        for (i = 0; i < shape.labels.getSize(); i += 1) {
            label = shape.labels.get(i);
            label.setLabelPosition(label.location, label.diffX, label.diffY);
        }

        return true;
    };
};

/**
 * @class NoResizeBehavior
 * Class that encapsulates the regular resize behavior of a shape when it's not supposed to be resizable
 * @extends ResizeBehavior
 *
 * @constructor Creates a new instance of the class RegularResizeBehavior
 */
NoResizeBehavior = function () {
};

NoResizeBehavior.prototype = new ResizeBehavior();

/**
 * The type of each instance of this class.
 * @property {String}
 */
NoResizeBehavior.prototype.type = "NoResizeBehavior";

/**
 * Initialize JQueryUI's resize plugin (disables the resizable plugin).
 * @param {Shape} shape
 */
NoResizeBehavior.prototype.init = function (shape) {
    var $shape = $(shape.getHTML());
    ResizeBehavior.prototype.init.call(this, shape);
    $shape.resizable('disable');
    $shape
//        .removeClass('ui-resizable-disabled')
        .removeClass('ui-state-disabled');
    shape.applyStyleToHandlers('nonResizableStyle');
    shape.showOrHideResizeHandlers(false);
};

/**
 * Overwrites the method {@link ResizeBehavior#updateResizeMinimums} since
 * a shape that is not resizable shouldn't update its resize minimums.
 * @param {Shape} shape
 */
NoResizeBehavior.prototype.updateResizeMinimums = function (shape) {
};

/**
 * @class DropBehavior
 * Abstract class where all the drop behavior classes inherit from
 * Strategy Pattern
 * @constructor
 *  Creates a new instance of the class
 * @param {Array} [selectors=[]] css selectors that the drop behavior
 * will accept
 */
DropBehavior = function (selectors) {
    /**
     * css selectors that the used for the drop behaviors beside the defaults
     * @property {Array}
     */
    this.selectors = selectors || [];
};
/**
 * Type of the instances
 * @property {String}
 */
DropBehavior.prototype.type = "DropBehavior";
/**
 * Family of the instances
 * @property {String}
 */
DropBehavior.prototype.family = "DropBehavior";
/**
 * Default css selectors for the drop behavior
 * @property {String}
 */
DropBehavior.prototype.defaultSelector = "";
/**
 * Attach the drop behaviors and assign the handlers to the corresponding shape
 * @param {Shape} shape
 */
DropBehavior.prototype.attachDropBehavior = function (shape) {
    var $shape = $(shape.getHTML()),
        dropOptions = {
            accept: this.defaultSelector,
            drop: this.onDrop(shape),
            over: this.onDragEnter(shape),
            out : this.onDragLeave(shape),
            greedy : true
        };
    $shape.droppable(dropOptions);
};

/**
 * @event dragEnter
 * @abstract Handler for the drag enter event
 * @param {Shape} shape
 * @template
 * @protected
 */
DropBehavior.prototype.onDragEnter = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event dragLeave
 * @abstract Handler for the drag leave event
 * @param {Shape} shape
 * @template
 * @protected
 */
DropBehavior.prototype.onDragLeave = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event drop
 * @abstract Handler for the on drop event
 * @param {Shape} shape
 * @template
 * @protected
 */
DropBehavior.prototype.onDrop = function (shape) {
    return function (e, ui) {
    };
};
/**
 * Sets the selectors that the drop behavior will accept
 * @param {Array} selectors css selectors
 * @param {boolean} overwrite determines whether the default selectors will be
 * overridden or not
 * @chainable
 */
DropBehavior.prototype.setSelectors = function (selectors, overwrite) {
    var currentSelectors = "",
        index,
        i;
    if (selectors) {
        this.selectors = selectors;
    }
    if (!overwrite) {
        currentSelectors = this.defaultSelector;
        index = 0;
    } else if (selectors.length > 0) {
        currentSelectors = selectors[0];
        index = 1;
    }
    for (i = index; i < selectors.length; i += 1) {
        currentSelectors += "," + this.selectors[i];
    }
    return this;
};
/**
 * Updates the accepted drop selectors
 * @param {Shape} shape
 * @param {Array} selectors
 * @chainable
 */
DropBehavior.prototype.updateSelectors = function (shape, selectors) {
    var $shape = $(shape.getHTML()),
        currentSelectors,
        i;
    if (selectors) {
        this.selectors = selectors;
    }
//    if (!overwrite) {
//        currentSelectors = $shape.droppable("option", "accept");
//        console.log(currentSelectors);
//    }
    if (this.selectors.length > 0) {
        currentSelectors = this.selectors[0];
    }
    for (i = 1; i < this.selectors.length; i += 1) {
        currentSelectors += ',' + this.selectors[i];
    }
    $shape.droppable({"accept" : currentSelectors});
    return this;
};

/**
 * Hook for the drag enter handler
 * @template
 * @protected
 */
DropBehavior.prototype.dragEnterHook = function () {
    return true;
};

/**
 * Hook for the drag leave handler
 * @template
 * @protected
 */
DropBehavior.prototype.dragLeaveHook = function () {
    return true;
};

/**
 * Hook for the drop handler, executes before the on drop handler logic
 * @param {Shape} shape
 * @param {Object} e jQuery object that contains the properties on the
 * drop event
 * @param {Object} ui jQuery object that contains the properties on the
 * drop event
 * @template
 * @protected
 */
DropBehavior.prototype.dropStartHook = function (shape, e, ui) {
    return true;
};
/**
 * Hook for the on drop handler
 * @param {Shape} shape
 * @param {Object} e jQuery object that contains the properties on the
 * drop event
 * @param {Object} ui jQuery object that contains the properties on the
 * drop event
 * @template
 * @protected
 */
DropBehavior.prototype.dropHook = function (shape, e, ui) {
    return true;
};
/**
 * Hook for the on drop handler, executes after the drop logic has concluded
 * @param {Shape} shape
 * @param {Object} e jQuery object that contains the properties on the
 * drop event
 * @param {Object} ui jQuery object that contains the properties on the
 * drop event
 * @template
 * @protected
 */
DropBehavior.prototype.dropEndHook = function (shape, e, ui) {
    return true;
};

/**
 * @class ConnectionDropBehavior
 * Class that encapsulates the drop behavior for dropped connections in shapes
 * @extends DropBehavior
 *
 * @constructor
 * Creates a new instance of the class
 * @param selectors
 */
ConnectionDropBehavior = function (selectors) {
    DropBehavior.call(this, selectors);
};

ConnectionDropBehavior.prototype = new DropBehavior();
/**
 * Type of the instances
 * @property {String}
 */
ConnectionDropBehavior.prototype.type = "ConnectionDropBehavior";
/**
 * Defaults selectors for this drop behavior
 * @property {String}
 */
ConnectionDropBehavior.prototype.defaultSelector = ".custom_shape,.port";

/**
 * Sets the selectors for this drop behavior including the defaults
 * @param selectors
 * @param overwrite
 * @return {*}
 */
ConnectionDropBehavior.prototype.setSelectors = function (selectors, overwrite) {
    DropBehavior.prototype.setSelectors.call(this, selectors, overwrite);
    this.selectors.push(".port");
    this.selectors.push(".custom_shape");

    return this;
};
/**
 * Drag enter hook for this drop behavior, marks that a shape is over a
 * droppable element
 * @param {Shape} shape
 * @return {Function}
 */
ConnectionDropBehavior.prototype.onDragEnter = function (shape) {
    return function (e, ui) {
        shape.entered = true;
    };
};

/**
 * Drag leave hook for this drop behavior, marks that a shape has left a
 * droppable element
 * @param {Shape} shape
 * @return {Function}
 */
ConnectionDropBehavior.prototype.onDragLeave = function (shape) {
    return function (e, ui) {
        shape.entered = false;
    };
};
/**
 * On drop handler for this drop behavior, creates a connection between the
 * droppable element and the dropped element, or move ports among those shapes
 * @param {Shape} shape
 * @return {Function}
 */
ConnectionDropBehavior.prototype.onDrop = function (shape) {
    var that = this;
    return function (e, ui) {
        var canvas  = shape.getCanvas(),
            //regularShapes = shape.canvas.regularShapes,
            id = ui.draggable.attr('id'),
            //port = regularShapes.find('id', id),
            x,
            y,
            currLeft,
            currTop,
            startPoint,
            sourceShape,
            sourcePort,
            endPort,
            endPortXCoord,
            endPortYCoord,
            connection,
            currentConnection = canvas.currentConnection,
            srcPort,
            dstPort,
            port,
            success = false,
            command;
        shape.entered = false;
        if (!shape.dropBehavior.dropStartHook(shape, e, ui)) {
            return false;
        }
        if (shape.getConnectionType() === "none") {
            return true;
        }
        //shape.entered = false;
        if (currentConnection) {
            srcPort = currentConnection.srcPort;
            dstPort = currentConnection.destPort;
            if (srcPort.id === id) {
                port = srcPort;
            } else if (dstPort.id === id) {
                port = dstPort;
            } else {
                port = null;
            }
        }
        if (ui.helper && ui.helper.attr('id') === "drag-helper") {

            //if its the helper then we need to create two ports and draw a
            // connection
            //we get the points and the corresponding shapes involved
            startPoint = shape.canvas.connectionSegment.startPoint;
            sourceShape = shape.canvas.connectionSegment.pointsTo;
            //determine the points where the helper was created
            if (sourceShape.parent && sourceShape.parent.id === shape.id) {
                return true;
            }
            sourceShape.setPosition(sourceShape.oldX, sourceShape.oldY);

            startPoint.x -= sourceShape.absoluteX;
            startPoint.y -= sourceShape.absoluteY;

            //create the ports
            sourcePort = new Port({
                width: 8,
                height: 8
            });
            endPort = new Port({
                width: 8,
                height: 8
            });

            //determine the position where the helper was dropped
            endPortXCoord = ui.offset.left - shape.canvas.getX() -
                shape.getAbsoluteX() + shape.canvas.getLeftScroll();
            endPortYCoord = ui.offset.top - shape.canvas.getY() -
                shape.getAbsoluteY() + shape.canvas.getTopScroll();

            // add ports to the corresponding shapes
            // addPort() determines the position of the ports
            sourceShape.addPort(sourcePort, startPoint.x, startPoint.y);
            shape.addPort(endPort, endPortXCoord, endPortYCoord,
                false, sourcePort);

            //add ports to the canvas array for regularShapes
            //shape.canvas.regularShapes.insert(sourcePort).insert(endPort);

            //create the connection
            connection = new Connection({
                srcPort : sourcePort,
                destPort: endPort,
                canvas : shape.canvas,
                segmentStyle: shape.connectionType
            });

//            console.log(sourcePort.direction);
//            console.log(endPort.direction);

            //set its decorators
            connection.setSrcDecorator(new ConnectionDecorator({
                width: 11,
                height: 11,
                canvas: canvas,
                decoratorPrefix: "con_normal",
                decoratorType: "source",
                parent: connection
            }));
            connection.setDestDecorator(new ConnectionDecorator({
                width: 11,
                height: 11,
                canvas: canvas,
                decoratorPrefix: "con_normal",
                decoratorType: "target",
                parent: connection
            }));

            connection.canvas.commandStack.add(new CommandConnect(connection));

            //connect the two ports
            connection.connect();
            connection.setSegmentMoveHandlers();

            // / fixes the zIndex of the connection
            //connection.fixZIndex();

            //add the connection to the canvas, that means insert its html to
            // the DOM and adding it to the connections array
            canvas.addConnection(connection);

            // now that the connection was drawn try to create the intersections
            connection.checkAndCreateIntersectionsWithAll();

            //attaching port listeners
            sourcePort.attachListeners(sourcePort);
            endPort.attachListeners(endPort);

            // finally trigger createEvent
            canvas.triggerCreateEvent(connection, []);
        } else if (port) {

            port.setOldParent(port.getParent());
            port.setOldX(port.getX());
            port.setOldY(port.getY());

            x = ui.position.left;
            y = ui.position.top;
            port.setPosition(x, y);
            shape.dragging = false;
            if (shape.getID() !== port.parent.getID()) {
                port.parent.removePort(port);
                currLeft = ui.offset.left - canvas.getX() -
                    shape.absoluteX + shape.canvas.getLeftScroll();
                currTop = ui.offset.top - canvas.getY() -
                    shape.absoluteY + shape.canvas.getTopScroll();
                shape.addPort(port, currLeft, currTop, true);
                canvas.regularShapes.insert(port);
            } else {
                shape.definePortPosition(port, port.getPoint(true));
            }

            // LOGIC: when portChangeEvent is triggered it gathers the state
            // of the connection but since at this point there's only a segment
            // let's paint the connection, gather the state and then disconnect
            // it (the connection is later repainted on, I don't know how)
            port.connection.connect();
            canvas.triggerPortChangeEvent(port);
            port.connection.disconnect();

            command = new CommandReconnect(port);
            port.canvas.commandStack.add(command);
        }
//        shape.dropBehavior.dropEndHook(shape, e, ui);
        return false;
    };
};

/**
 * @class  NoDropBehavior
 * Encapsulates the drop behavior representing an object that can't be droppable
 * @extends DropBehavior
 *
 * @constructor
 * Creates a new instance of the class
 */
NoDropBehavior = function (selectors) {
    DropBehavior.call(this, selectors);
};

NoDropBehavior.prototype = new DropBehavior();
/**
 * Type of the instances
 * @property {String}
 */
NoDropBehavior.prototype.type = "NoDropBehavior";
/**
 * Attach the drop behavior, sets the accepted elements to none
 * @param {Shape} shape
 */
NoDropBehavior.prototype.attachDropBehavior = function (shape) {
    var $shape = $(shape.getHTML());
    DropBehavior.prototype.attachDropBehavior.call(this, shape);
    $(shape).droppable('accept', "");
};

/**
 * @class ContainerDropBehavior
 * Encapsulates the drop behavior of a container
 * @extends DropBehavior
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Array} [selectors=[]] css selectors that this drop behavior will
 * accept
 */
ContainerDropBehavior = function (selectors) {
    DropBehavior.call(this, selectors);
};

ContainerDropBehavior.prototype = new DropBehavior();
/**
 * Type of the instances
 * @property {String}
 */
ContainerDropBehavior.prototype.type = "ContainerDropBehavior";
/**
 * Default selectors for this drop behavior
 * @property {String}
 */
ContainerDropBehavior.prototype.defaultSelector = ".custom_shape";

/**
 * On drop handler for this drop behavior, creates shapes when dropped from the
 * toolbar, or move shapes among containers
 * @param {Shape} shape
 * @return {Function}
 */
ContainerDropBehavior.prototype.onDrop = function (shape) {
    return function (e, ui) {
        var customShape = null,
            canvas = shape.getCanvas(),
            selection,
            sibling,
            i,
            command,
            coordinates,
            id,
            shapesAdded =  [],
            containerBehavior = shape.containerBehavior;
        if (canvas.readOnly) {
            return false;
        }

        shape.entered = false;
        if (ui.helper && ui.helper.attr('id') === "drag-helper") {
            return false;
        }
        id = ui.draggable.attr('id');
        customShape = canvas.toolBarShapeFactory(id);
        if (customShape === null) {

            customShape = canvas.customShapes.find('id', id);

            if (!customShape || !shape.dropBehavior.dropHook(shape, e, ui)) {
                return false;
            }

            if (!(customShape.parent &&
                customShape.parent.id === shape.id)) {

                selection = canvas.currentSelection;
                for (i = 0; i < selection.getSize(); i += 1) {
                    sibling = selection.get(i);
//                    sibling.oldParent = sibling.parent;
//                    sibling.oldX = sibling.x;
//                    sibling.oldY = sibling.y;
//                    sibling.oldAbsoluteX = sibling.absoluteX;
//                    sibling.oldAbsoluteY = sibling.absoluteY;
                    coordinates = Utils.getPointRelativeToPage(sibling);
                    coordinates = Utils
                        .pageCoordinatesToShapeCoordinates(shape, null,
                            coordinates.x, coordinates.y);

//                    sibling.parent.containerBehavior.removeFromContainer(sibling);
//                    shape.addElement(sibling, coordinates.x,
//                        coordinates.y, false);
                    shapesAdded.push({
                        shape : sibling,
                        container : shape,
                        x : coordinates.x,
                        y : coordinates.y,
                        topLeft : false
                    });


//                    sibling.parent.swapElementContainer(sibling, shape,
//                        coordinates.x, coordinates.y, false);
//                    shape.swapElementContainer()
//                    sibling.fixZIndex(sibling, 0);
//                    sibling.changeParent(sibling.oldX, sibling.oldY,
//                        sibling.oldAbsoluteX, sibling.oldAbsoluteY,
//                        sibling.oldParent, sibling.canvas);
                    //console.log(shape.children.getSize());
                }
                command = new CommandSwitchContainer(shapesAdded);
                command.execute();
                canvas.commandStack.add(command);
                canvas.multipleDrop = true;

            }

            // fix resize minWidth and minHeight and also fix the dimension
            // of this shape (if a child made it grow)

            shape.updateDimensions(10);


            canvas.updatedElement = null;
        } else {
            coordinates = Utils.pageCoordinatesToShapeCoordinates(shape, e);
            shape.addElement(customShape, coordinates.x, coordinates.y,
                    customShape.topLeftOnCreation);
            customShape.attachListeners();

            //since it is a new element in the designer, we triggered the
            //custom on create element event
            canvas.updatedElement = customShape;

            // create the command for this new shape
            command = new CommandCreate(customShape);
            canvas.commandStack.add(command);
            command.execute();
            //shape.updateSize();
        }
    };
};

/**
 * @class ConnectionContainerDropBehavior
 * Class that encapsulates the drop behaviors for containers that can also be
 * connected
 * @extends DropBehavior
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Array} [selectors=[]] css selectors that this drop behavior will
 * accept
 */
ConnectionContainerDropBehavior = function (selectors) {
    DropBehavior.call(this, selectors);
};


ConnectionContainerDropBehavior.prototype = new DropBehavior();
/**
 * Type of the instances
 * @property {String}
 */
ConnectionContainerDropBehavior.prototype.type = "ConnectionContainerDropBehavior";
/**
 * Default selectors for this drop behavior
 * @property {String}
 */
ConnectionContainerDropBehavior.prototype.defaultSelector =
        ".custom_shape,.port";
/**
 * Set the selectors for this drop behavior including the default selectors
 * @param {Array} selectors css selectors
 * @param {boolean} overwrite
 * @return {*}
 */
ConnectionContainerDropBehavior.prototype.setSelectors = function (selectors,
        overwrite) {
    DropBehavior.prototype.setSelectors.call(this, selectors, overwrite);
    this.selectors.push(".port");
    this.selectors.push(".custom_shape");
    return this;
};
/**
 * On drop handler for this drop behavior, determines whether to create a
 * connection or add a shape to the container that is using this drop behavior
 * @param {Shape} shape
 * @return {Function}
 */
ConnectionContainerDropBehavior.prototype.onDrop = function (shape) {
    return function (e, ui) {
        if (!ConnectionDropBehavior.prototype.onDrop.call(this, shape)(e, ui)) {
            ContainerDropBehavior.prototype.onDrop.call(this, shape)(e, ui);
        }

    };
};



/**
 * @class Color
 * This class holds the representation and operations of RGBa representation of color,
 * it's very useful if we want to save color constants as an instance and later get the representation
 * in CSS.
 *
 *      //i.e.
 *      var color = new Color(
 *          128,    // red
 *          128,    // green
 *          128,    // blue
 *          1       // opacity
 *      )
 *
 * @constructor Creates an instance of this class.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @param {number} opacity
 * @return {Color}
 */
Color = function (red, green, blue, opacity) {
    /**
     * Red value of the RGB Color
     * @property {number} [red=0]
     */
    this.red = (!red) ? 0 : red;
    /**
     * Green value of the RGB Color
     * @property {number} [green=0]
     */
    this.green = (!green) ? 0 : green;
    /**
     * Blue value of the RGB Color
     * @property {number} [blue=0]
     */
    this.blue = (!blue) ? 0 : blue;
    /**
     * Opacity of the RGB Color
     * @property {number} [opacity=1]
     */
    this.opacity = (!opacity) ? 1 : opacity;
};

/**
 * Type of this class
 * @property {String}
 */
Color.prototype.type = "Color";

/**
 * Constant for the color grey
 * @property {Color} [GREY=new Color(192, 192, 192, 1)]
 */
Color.GREY = new Color(192, 192, 192, 1);

/**
 * Returns the red value of the RGB Color
 * @returns {number}
 */
Color.prototype.getRed = function () {
    return this.red;
};

/**
 * Returns the green value of the RGB Color
 * @returns {number}
 */
Color.prototype.getGreen = function () {
    return this.green;
};

/**
 * Returns the blue value of the RGB Color
 * @returns {number}
 */
Color.prototype.getBlue = function () {
    return this.blue;
};

/**
 * Returns the opacity of the RGB Color
 * @returns {number}
 */
Color.prototype.getOpacity = function () {
    return this.opacity;
};

/**
 * Sets the red value of the RGB Color
 * @param {number} newRed
 * @chainable
 */
Color.prototype.setRed = function (newRed) {
    if (typeof newRed === "number" && newRed >= 0 && newRed <= 255) {
        this.red = newRed;
    }
    return this;
};

/**
 * Sets the green value of the RGB Color
 * @param {number} newRed
 * @chainable
 */
Color.prototype.setGreen = function (newGreen) {
    if (typeof newGreen === "number" && newGreen >= 0 && newGreen <= 255) {
        this.green = newGreen;
    }
    return this;
};

/**
 * Sets the blue value of the RGB Color
 * @param {number} newBlue
 * @chainable
 */
Color.prototype.setBlue = function (newBlue) {
    if (typeof newBlue === "number" && newBlue >= 0 && newBlue <= 255) {
        this.blue = newBlue;
    }
    return this;
};

/**
 * Sets the opacity of the RGB Color
 * @param {number} newOpacity
 * @chainable
 */
Color.prototype.setOpacity = function (newOpacity) {
    if (typeof newOpacity === "number" && newOpacity >= 0 && newOpacity <= 255) {
        this.opacity = newOpacity;
    }
    return this;
};

/**
 * Returns the css representation of the RGB color
 *      //i.e.
 *      var color = new Color(10, 20, 30, 0.1);
 *      color.getCSS();         // "rgba(10, 20, 30, 0.1)"
 * @returns {String}
 */
Color.prototype.getCSS = function () {
    var css = "rgba(" + this.red + "," + this.green + "," + this.blue +
        "," + this.opacity + ")";
    return css;
};

/**
 * @class Style
 * Class that represent the style of a an object, {@link JCoreObject} creates an instance of this class so every
 * class that inherits from {@link JCoreObject} has an instance of this class.
 *
 *      // i.e
 *      // Let's assume that 'shape' is a CustomShape
 *      var style = new Style({
 *          cssClasses: [
 *              'sprite-class', 'marker-class', ...
 *          ],
 *          cssProperties: {
 *              border: 1px solid black,
 *              background-color: grey,
 *              ...
 *          },
 *          belongsTo: shape
 *      })
 *
 * @constructor Creates a new instance of this class
 * @param {Object} options
 * @cfg {Array} [cssClasses=[]] the classes that `this.belongsTo` has
 * @cfg {Object} [cssProperties={}] the css properties that `this.belongsTo` has
 * @cfg {Object} [belongsTo=null] a pointer to the owner of this instance
 */
Style = function (options) {

    /**
     * JSON Object used to map each of the css properties of the object,
     * this object has the same syntax as the object passed to jQuery.css()
     *      cssProperties: {
     *          background-color: [value],
     *          border: [value],
     *          ...
     *      }
     * @property {Object}
     */
    this.cssProperties = null;

    /**
     * Array of all the classes of this object
     *      cssClasses = [
     *          'class_1',
     *          'class_2',
     *          ...
     *      ]
     * @property {Array}
     */
    this.cssClasses = null;

    /**
     * Pointer to the object to whom this style belongs to
     * @property {Object}
     */
    this.belongsTo = null;


    Style.prototype.initObject.call(this, options);
};


/**
 * The type of this class
 * @property {String}
 */
Style.prototype.type = "Style";

/**
 * Constant for the max z-index
 * @property {number} [MAX_ZINDEX=100]
 */
Style.MAX_ZINDEX = 100;

/**
 * Instance initializer which uses options to extend the config options to
 * initialize the instance
 * @private
 * @param {Object} options
 */
Style.prototype.initObject = function (options) {
    var defaults = {
        cssClasses: [],
        cssProperties: {},
        belongsTo: null
    };
    $.extend(true, defaults, options);
    this.cssClasses = defaults.cssClasses;
    this.cssProperties = defaults.cssProperties;
    this.belongsTo = defaults.belongsTo;
};

/**
 * Applies cssProperties and cssClasses to `this.belongsTo`
 * @chainable
 */
Style.prototype.applyStyle = function () {

    if (!this.belongsTo.html) {
        throw new Error("applyStyle(): can't apply style to an" +
            " object with no html");
    }

    var i,
        class_i;

    // apply the cssProperties
    $(this.belongsTo.html).css(this.cssProperties);

    // apply saved classes
    for (i = 0; i < this.cssClasses.length; i += 1) {
        class_i = this.cssClasses[i];
        if (!$(this.belongsTo.html).hasClass(class_i)) {
            $(this.belongsTo.html).addClass(class_i);
        }
    }
    return this;
};

/**
 * Extends the property `cssProperties` with a new object and also applies those new properties
 * @param {Object} properties
 * @chainable
 */
Style.prototype.addProperties = function (properties) {
    $.extend(true, this.cssProperties, properties);
    $(this.belongsTo.html).css(properties);
    return this;
};

/**
 * Gets a property from `this.cssProperties` using jQuery or `window.getComputedStyle()`
 * @param {String} property
 * @return {String}
 */
Style.prototype.getProperty = function (property) {
    return this.cssProperties[property] ||
        $(this.belongsTo.html).css(property) ||
            window.getComputedStyle(this.belongsTo.html, null)
            .getPropertyValue(property);
};

/**
 * Removes properties from the this.cssProperties, also disables those properties from
 * the HTMLElement
 * @param {Object} properties
 * @chainable
 */
Style.prototype.removeProperties = function (properties) {
    var property,
        i;
    for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        if (this.cssProperties.hasOwnProperty(property)) { // JS Code Convention
            $(this.belongsTo.html).css(property, "");   // reset inline style
            delete this.cssProperties[property];
        }
    }
    return this;
};

/**
 * Adds new classes to this.cssClasses array
 * @param {Array} cssClasses
 * @chainable
 */
Style.prototype.addClasses = function (cssClasses) {
    var i,
        cssClass;
    if (cssClasses && cssClasses instanceof Array) {
        for (i = 0; i < cssClasses.length; i += 1) {
            cssClass = cssClasses[i];
            if (typeof cssClass === "string") {
                if (this.cssClasses.indexOf(cssClass) === -1) {
                    this.cssClasses.push(cssClass);
                    $(this.belongsTo.html).addClass(cssClass);
                }
            } else {
                throw new Error("addClasses(): array element is not of type string");
            }
        }
    } else {
        throw new Error("addClasses(): parameter must be of type Array");
    }
    return this;
};

/**
 * Removes classes from this.cssClasses array, also removes those classes from
 * the HTMLElement
 * @param {Array} cssClasses
 * @chainable
 */
Style.prototype.removeClasses = function (cssClasses) {

    var i,
        index,
        cssClass;
    if (cssClasses && cssClasses instanceof Array) {
        for (i = 0; i < cssClasses.length; i += 1) {
            cssClass = cssClasses[i];
            if (typeof cssClass === "string") {
                index = this.cssClasses.indexOf(cssClass);
                if (index !== -1) {
                    $(this.belongsTo.html).removeClass(this.cssClasses[index]);
                    this.cssClasses.splice(index, 1);
                }
            } else {
                throw new Error("removeClasses(): array element is not of " +
                    "type string");
            }
        }
    } else {
        throw new Error("removeClasses(): parameter must be of type Array");
    }
    return this;
};

/**
 * Removes all the classes from this.cssClasses array
 * @param {Array} cssClasses
 * @chainable
 */
Style.prototype.removeAllClasses = function () {
    this.cssClasses = [];
    $(this.belongsTo.html).removeClass();
    return this;
};

/**
 * Checks if the class is a class stored in this.cssClasses
 * @param cssClass
 * @return {boolean}
 */
Style.prototype.containsClass = function (cssClass) {
    return this.cssClasses.indexOf(cssClass) !== -1;
};

/**
 * Returns an array with all the classes of this.belongsTo
 * @return {Array}
 */
Style.prototype.getClasses = function () {
    return this.cssClasses;
};

/**
 * Serializes this instance
 * @return {Object}
 * @return {Array} return.cssClasses
 */
Style.prototype.stringify = function () {
    return {
        cssClasses: this.cssClasses
//        cssProperties: this.cssProperties
    };
};



/**
 * @class JCoreObject
 * This class contains the common behavior of the main families of classes
 * in the library
 * This class should never be instantiated since its just an abstraction of
 * properties that classes in the library share
 *
 *      //i.e.
 *      //We will set the properties defined in this class, to a custom shape
 *      var customShape = new CustomShape({
 *          id : "someid",
 *          canvas : someCanvas //assuming there is a canvas instance
 *          style: { //style options regarding the objects
 *              cssProperties: {}, //These are the style properties we want the
 *              //object to have
 *              cssClasses: ["someclass"] //css classes that will be applied
 *              to the object
 *          },
 *          //now we set the width and height
 *          width : 30,
 *          height : 50,
 *          //and the coordinates we want the shape to be positioned
 *          x : 10,
 *          y : 5,
 *          //z-index of the element
 *          zOrder : 1,
 *          //set to true if we want to make it visible
 *          visible : true,
 *
 *      });
 *
 * @constructor
 * Creates an instance of the class
 * @param {Object} options options for initializing the object
 * @cfg {String} id id that will be assigned to the element
 * @cfg {Object} [style={
 *     cssProperties: {},
 *     cssClasses: []
 * }] style properties and classes that we want to assign to the element
 * @cfg {Canvas} [canvas=null] canvas associated to the element
 * @cfg {number} [width=0] width of the element
 * @cfg {number} [height=0] height of the element
 * @cfg {number} [x=0] x coordinate of the element
 * @cfg {number} [y=0] y coordinate of the element
 * @cfg {number} [zOrder=1] z-Index applied to the element
 * @cfg {boolean} [visible=true] Determines whether an element will be visible
 */

JCoreObject = function (options) {
    /**
     * Object unique id
     * @property {String}
     */
    this.id = null;
//    console.log(this.id);
    /**
     * Reference to the canvas of the given object
     * @property {Canvas}
     */
    this.canvas = null;

    /**
     * HTMLNode of the object
     * @property {*}
     */
    this.html = null;
    /**
     * Style specifications for the object
     * @property {Style}
     */
    this.style = null;
    /** Width of the object
     * @property {number}
     */
    this.width = 0;
    /** Height of the object
     * @property {number}
     */
    this.height = 0;
    /**
     * previous width of the JCoreObject
     * @property {number}
     */
    this.oldWidth = 0;
    /**
     * previous height of the JCoreObject
     * @property {number}
     */
    this.oldHeight = 0;
    /** x coordinate of the object
     * @property {number}
     */
    this.x = 0;
    /** y coordinate of the object
     * @property {number}
     */
    this.y = 0;
    /**
     * previous x coordinate of the JCoreObject
     * @property {number}
     */
    this.oldX = 0;
    /**
     * previous y coordinate of the JCoreObject
     * @property {number}
     */
    this.oldY = 0;

    /**
     * The x coordinate relative to the canvas
     * @property {number}
     */
    this.absoluteX = 0;
    /**
     * The y coordinate relative to the canvas
     * @property {number}
     */
    this.absoluteY = 0;
    /**
     * Previous x coordinate relative to the canvas
     * @property {number}
     */
    this.oldAbsoluteX = 0;
    /**
     * Previous y coordinate relative to the canvas
     * @property {number}
     */
    this.oldAbsoluteY = 0;
    /**
     * Zoom in x
     * @property {number}
     */
    this.zoomX = 0;

    /**
     * Zoom in y
     * @property {number}
     */
    this.zoomY = 0;

    /**
     * Width after the zoom
     * @property {number}
     */
    this.zoomWidth = 0;

    /**
     * Height after the zoom
     * @property {number}
     */
    this.zoomHeight = 0;

    /** zOrder of the Canvas
     * @property {number}
     */
    this.zOrder = 1;
    /**
     * Denote whether the current object is visible or hidden
     * @property {boolean}
     */
    this.visible = true;
    /**
     * Property that encapsulates the drag behavior of the object
     * @property {DragBehavior}
     */
    this.dragBehavior = null;
    /**
     * Saved options is a copy of the default initializer extended
     * with the parameter <options>
     * @property {Object}
     */
    this.savedOptions = {};
    JCoreObject.prototype.initObject.call(this, options);

};

/**
 * Denotes the type of the object
 * @property {String}
 */
JCoreObject.prototype.type = "JCoreObject";
/**
 * Determines the family that an object is part of
 * @property {String}
 */
JCoreObject.prototype.family = "CoreObject";
/**
 * @abstract Method for applying the styles and preform tasks related to the
 * view of the object
 */
JCoreObject.prototype.paint = function () {
};

/**
 * @abstract Method for attaching listeners for a given set of events to the
 * object
 */
JCoreObject.prototype.attachListeners = function () {
};
/**
 * Initializes the element with the options given
 * @param {Object} options options for initializing the object
 */
JCoreObject.prototype.initObject = function (options) {
    var defaultOptions = {
        id : (options && options.id) || Utils.generateUniqueId(),
        style : {
            cssProperties: {},
            cssClasses: []
        },
        width : 0,
        height : 0,
        x : 0,
        y : 0,
        zOrder : 1,
        visible : true,
        canvas : null
    };
    $.extend(true, defaultOptions, options);
    this.setID(defaultOptions.id)
        .setStyle(new Style({
            belongsTo: this,
            cssProperties: defaultOptions.style.cssProperties,
            cssClasses: defaultOptions.style.cssClasses
        }))
        .setCanvas(defaultOptions.canvas)
        .setDimension(defaultOptions.width, defaultOptions.height)
        .setPosition(defaultOptions.x, defaultOptions.y)
        .setZOrder(defaultOptions.zOrder)
        .setVisible(defaultOptions.visible)
        .setSavedOptions(defaultOptions);
};

/**
 * Creates a div element for the jCore object
 * @return {HTMLElement}
 */
JCoreObject.prototype.createHTMLDiv = function () {
    return document.createElement("div");
};
/**
 * Creates the basic html node structure for the given object using its
 * previously defined properties
 * @return {HTMLElement}
 */
JCoreObject.prototype.createHTML = function () {

    if (!this.html) {
        this.html = this.createHTMLDiv();
        this.html.id = this.id;

        // if this shape had some style saved in the init
        // then call apply style first
        this.style.applyStyle();

        this.style.addProperties({
            position: "absolute",
            left: this.zoomX,
            top: this.zoomY,
            width: this.zoomWidth,
            height: this.zoomHeight,
            zIndex: this.zOrder
        });

    }
    return this.html;
};

/**
 * Sets the position of the JCoreObject to a given pair of coordinates
 * @param {Number} newX new x coordinate for the JCoreObject
 * @param {Number} newY new y coordinate for the JCoreObject
 * @chainable
 */
JCoreObject.prototype.setPosition = function (newX, newY) {
    this.setX(newX);
    this.setY(newY);
    return this;
};

/**
 * Sets the dimension of the JCoreObject to a given width and height
 * @param {Number} newWidth new width of the JCoreObject
 * @param {Number} newHeight new height of the JCoreObject
 * @chainable
 */
JCoreObject.prototype.setDimension = function (newWidth, newHeight) {
    this.setWidth(newWidth);
    this.setHeight(newHeight);
    return this;
};

/**
* Sets the x coordinate of the JCoreObject, returns true if successful
* @param {Number} newX
* @chainable
*/
JCoreObject.prototype.setX = function (newX) {
    if (typeof newX === "number") {
        newX = Math.round(newX);
        this.x = newX;
        if (this.canvas) {
            this.zoomX = this.x * this.canvas.zoomFactor;
        } else {
            this.zoomX = this.x;
        }
        this.setAbsoluteX();
        if (this.html) {
            this.style.addProperties({left: this.zoomX});
//            this.html.style.left = this.zoomX + "px";
        }
    } else {
        throw new Error("setX : parameter newX is not a number");
    }

    return this;
};
/**
 * Sets the y coordinate of the JCoreObject, returns true if successful
 * @param {Number} newY
 * @chainable
 */
JCoreObject.prototype.setY = function (newY) {
    if (typeof newY === "number") {
        newY = Math.round(newY);
        this.y = newY;
        if (this.canvas) {
            this.zoomY = this.y * this.canvas.zoomFactor;
        } else {
            this.zoomY = this.y;
        }
        this.setAbsoluteY();
        if (this.html) {
            this.style.addProperties({top: this.zoomY});
//            this.html.style.top = this.zoomY + "px";
        }
    }
    return this;
};

/**
 * Sets the x coordinate of the JCoreObject relative to the canvas
 * @chainable
 */
JCoreObject.prototype.setAbsoluteX = function () {
    if (!this.parent) {
        this.absoluteX = this.zoomX;
    } else {
        this.absoluteX = this.zoomX + this.parent.absoluteX;
    }
    return this;
};

/**
 * Sets the value to an old X reference
 * @param {Number} newX
 * @chainable
 */
JCoreObject.prototype.setOldX = function (newX) {
    if (typeof newX === "number") {
        this.oldX = newX;
    }
    return this;
};
/**
 * Sets the value to an old y reference
 * @param {Number} newY
 * @chainable
 */
JCoreObject.prototype.setOldY = function (newY) {
    if (typeof newY === "number") {
        this.oldY = newY;
    }
    return this;
};
/**
 * Sets the y coordinate of the JCoreObject relative to the canvas
 * @chainable
 */
JCoreObject.prototype.setAbsoluteY = function () {
    if (!this.parent) {
        this.absoluteY = this.zoomY;
    } else {
        this.absoluteY = this.zoomY + this.parent.absoluteY;
    }
    return this;
};

/**
 * Sets the width of the JCoreObject, returns true if successful
 * @param {Number} newWidth
 * @chainable
 */
JCoreObject.prototype.setWidth = function (newWidth) {
    var intPart;
    if (typeof newWidth === "number" && newWidth >= 0) {
        this.width = newWidth;
        if (this.canvas) {
            this.zoomWidth = this.width * this.canvas.zoomFactor;
            intPart = Math.floor(this.zoomWidth);
            this.zoomWidth = (intPart % 2 === 0) ? intPart + 1 : intPart;
        } else {
            this.zoomWidth = this.width;
        }
        if (this.html) {
            this.style.addProperties({width: this.zoomWidth});
//            this.html.style.width = this.zoomWidth + "px";
        }
    }
    return this;
};

/**
 * Sets the height of the JCoreObject, returns true if successful
 * @param {Number} newHeight
 * @chainable
 */
JCoreObject.prototype.setHeight = function (newHeight) {
    var intPart;
    if (typeof newHeight === "number" && newHeight >= 0) {
        this.height = newHeight;

        if (this.canvas) {
            this.zoomHeight = this.height * this.canvas.zoomFactor;
            intPart = Math.floor(this.zoomHeight);
            this.zoomHeight = (intPart % 2 === 0) ? intPart + 1 : intPart;
        } else {
            this.zoomHeight = this.height;
        }
        if (this.html) {
            this.style.addProperties({height: this.zoomHeight});
//            this.html.style.height = this.zoomHeight + "px";
        }
    }
    return this;
};

/**
 * Sets the zOrder of this element
 * @param {Number} newZOrder
 * @chainable
 */
JCoreObject.prototype.setZOrder = function (newZOrder) {
    if (typeof newZOrder === "number" && newZOrder > 0) {
        this.zOrder = newZOrder;
        if (this.html) {
            this.style.addProperties({zIndex: this.zOrder});
//            this.html.style.zIndex = this.zOrder;
        }
    }
    return this;
};

/**
 * Sets the canvas for the current object
 * @param {Canvas} newCanvas
 * @returns {JCoreObject}
 */
JCoreObject.prototype.setCanvas = function (newCanvas) {
    if (newCanvas && newCanvas.family === "Canvas") {
        this.canvas = newCanvas;
    }
    return this;
};

/**
 * Sets the style object for the current JCoreObject
 * @param {Style} newStyle
 * @chainable
 */
JCoreObject.prototype.setStyle = function (newStyle) {
    if (newStyle.type && newStyle.type === "Style") {
        this.style = newStyle;
    }
    return this;
};
/**
 * Sets this element to be visible or not if it has html, just sets the display
 * property to inline or none
 * @param {boolean} newVisible
 * @chainable
 */
JCoreObject.prototype.setVisible = function (newVisible) {

    if (typeof newVisible === "boolean") {
        this.visible = newVisible;
        if (this.html) {
            if (newVisible) {
                this.style.addProperties({display: "inline"});
//                this.html.style.display = "inline";
            } else {
                this.style.addProperties({display: "none"});
//                this.html.style.display = "none";
            }
        }
    }
    return this;
};
/**
 * Sets the id of this element and updates the html if there is such
 * @param {String} newID
 * @chainable
 */
JCoreObject.prototype.setID = function (newID) {
    this.id = newID;
    if (this.html) {
        this.html.id = this.id;
    }
    return this;
};
/**
 * Returns the ID of this JCoreObject
 * @returns {String}
 */
JCoreObject.prototype.getID = function () {
    return this.id;
};
/**
 * Returns the HTML Representation,  if there is none, then creates one with
 * the current properties of the object
 * @returns {HTMLElement}
 */
JCoreObject.prototype.getHTML = function () {
    if (this.html === null) {
        return this.createHTML();
    }
    return this.html;
};
/**
 * Returns the zOrder of this JCoreObject
 * @returns {Number}
 */
JCoreObject.prototype.getZOrder = function () {
    return this.zOrder;
};
/**
 * Returns the canvas related to this object
 * @returns {Canvas}
 */
JCoreObject.prototype.getCanvas = function () {
    return this.canvas;
};

/**
 * Returns the width of the JCoreObject
 * @returns {Number}
 */
JCoreObject.prototype.getWidth = function () {
    return this.width;
};

/**
 * Returns the height of the JCoreObject
 * @returns {Number}
 */
JCoreObject.prototype.getHeight = function () {
    return this.height;
};
/**
 * Returns the x coordinate of the JCoreObject
 * @returns {Number}
 */
JCoreObject.prototype.getX = function () {
    return this.x;
};
/**
 * Returns the y coordinate of the JCoreObject
 * @returns {Number}
 */
JCoreObject.prototype.getY = function () {
    return this.y;
};

/**
 * Returns the x coordinate relative to the canvas of this object
 * @return {Number}
 */
JCoreObject.prototype.getAbsoluteX = function () {
    return this.absoluteX;
};
/**
 * Returns the y coordinate relative to the canvas of this object
 * @return {Number}
 */
JCoreObject.prototype.getAbsoluteY = function () {
    return this.absoluteY;
};

/**
 * Returns the style of this JCoreObject
 * @return {Style}
 */
JCoreObject.prototype.getStyle = function () {
    return this.style;
};
/**
 * Returns if the object is visible or not
 * @return {Boolean}
 */
JCoreObject.prototype.getVisible = function () {
    return this.visible;
};
/**
 * Gets the x coordinate relative to the zoom scale
 * @return {Number}
 */
JCoreObject.prototype.getZoomX = function () {
    return this.zoomX;
};

/**
 * Gets the y coordinate relative to the zoom scale
 * @return {Number}
 */
JCoreObject.prototype.getZoomY = function () {
    return this.zoomY;
};

/**
 * Gets the width relative to the zoom scale
 * @return {Number}
 */
JCoreObject.prototype.getZoomWidth = function () {
    return this.zoomWidth;
};

/**
 * Gets the height relative to the zoom scale
 * @return {Number}
 */
JCoreObject.prototype.getZoomHeight = function () {
    return this.zoomHeight;
};

/**
 * Retrieves the previous value for coordinate x
 * @return {Number}
 */
JCoreObject.prototype.getOldX = function () {
    return this.oldX;
};

/**
 * Retrieves the previous value for coordinate y
 * @return {Number}
 */
JCoreObject.prototype.getOldY = function () {
    return this.oldY;
};

/**
 * Retrieves the previous value for width
 * @return {Number}
 */
JCoreObject.prototype.getOldWidth = function () {
    return this.oldWidth;
};

/**
 * Retrieves the previous value for height
 * @return {Number}
 */
JCoreObject.prototype.getOldHeight = function () {
    return this.oldHeight;
};

/**
 * Save the options (options is the defaults options extension with the
 * user parameter for default initialization)
 * @param {Object} options
 */
JCoreObject.prototype.setSavedOptions = function (options) {
    this.savedOptions = options;
    return this;
};

/**
 * Stringifies the basic data of this shape and the drag behavior of this shape
 * @return {Object}
 */
JCoreObject.prototype.stringify = function () {
    return {
        id: this.getID(),
        x: this.getX(),
        y: this.getY(),
        width: this.getWidth(),
        height: this.getHeight(),
//        family: this.family,
        type: this.type,
        style: this.getStyle().stringify(),
        drag: this.savedOptions.drag
    };
};
/**
 * JSON parser for creating JCoreObjects
 * @param {Object} json
 */
JCoreObject.prototype.parseJSON = function (json) {
    this.initObject(json);
};
/**
 * Number that represents the top direction
 * @property {number}
 */
JCoreObject.prototype.TOP = 0;
/**
 * Number that represents the right direction
 * @property {number}
 */
JCoreObject.prototype.RIGHT = 1;
/**
 * Number that represents the bottom direction
 * @property {Number}
 */
JCoreObject.prototype.BOTTOM = 2;
/**
 * Number that represents the left direction
 * @property {Number}
 */
JCoreObject.prototype.LEFT = 3;
/**
 * Number that represents horizontal direction
 * @property {Number}
 */
JCoreObject.prototype.HORIZONTAL = 0;
/**
 * Number that represents  vertical direction
 * @property {Number}
 */
JCoreObject.prototype.VERTICAL = 1;
/**
 * Number of zoom scales available
 * @property {Number}
 */
JCoreObject.prototype.ZOOMSCALES = 5;

/**
 * @abstract
 * @class Handler
 * Abstract class which provides methods to represent a handler.
 * @extends JCoreObject
 *
 * @constructor Creates an instance of the class Handler (for inheritance purposes only).
 * @param {Object} options Initialization options.
 */
Handler = function (options) {
    JCoreObject.call(this, options);

    /**
     * Representation of this handler.
     * @property {Object}
     */
    this.representation = null;

    /**
     * The parent of this handler.
     * @property {Shape}
     */
    this.parent = null;

    /**
     * Color of this handler.
     * @property {Color}
     */
    this.color = null;

    /**
     * The orientation of this handler.
     * @property {string}
     */
    this.orientation = null;
};

Handler.prototype = new JCoreObject();

/**
 * Sets the parent of this handler
 * @param newParent
 * @chainable
 */
Handler.prototype.setParent = function (newParent) {
    this.parent = newParent;
    return this;
};

/**
 * Gets the parent of this handler
 * @return {Shape}
 */
Handler.prototype.getParent = function () {
    return this.parent;
};

/**
 * Sets the representation of this handler
 * @param representation
 * @chainable
 */
Handler.prototype.setRepresentation = function (representation) {
    this.representation = representation;
    return this;
};

/**
 * Gets the representation of this handler
 * @return {Object}
 */
Handler.prototype.getRepresentation = function () {
    return this.representation;
};

/**
 * Sets the orientation of this handler
 * @param newOrientation
 * @chainable
 */
Handler.prototype.setOrientation = function (newOrientation) {
    this.orientation = newOrientation;
    return this;
};

/**
 * Gets the orientation of this handler
 * @return {string}
 */
Handler.prototype.getOrientation = function () {
    return this.orientation;
};

/**
 * Paint the handler method which will call `this.representation.paint()`
 * @chainable
 */
Handler.prototype.paint = function () {
    // paint the representation (by default a rectangle)
    this.representation.paint.call(this);

    // apply predefined style
    this.style.applyStyle();

    return this;
};

/**
 * The color representation of this object
 * @param {Color} newColor
 * @chainable
 */
Handler.prototype.setColor = function (newColor) {
    this.color = newColor;
    return this;
};

/**
 * Get the color representation of this object
 * @return {Color}
 */
Handler.prototype.getColor = function () {
    return this.color;
};

/**
 * @class ResizeHandler
 * Defines a class resize handler to represent handlers used with jQueryUI' resizable plugin, currently
 * it has only support for rectangle resize handler (oval resize handlers were implemented but apparently
 * jQueryUI won't accept a child of the designated HTMLElement to be used as the resize handler).
 *
 * An example of use:
 *
 *      // i.e.
 *      // let's assume that shape is an instance of the class Shape
 *      // let's assume that rectangle is an instance of the class Rectangle
 *
 *      var resizableStyle = {
 *              cssProperties: {
 *                  'background-color': "rgb(0, 255, 0)",
 *                  'border': '1px solid black'
 *              }
 *          },
 *          nonResizableStyle = {
 *              cssProperties: {
 *                  'background-color': "white",
 *                  'border': '1px solid black'
 *              }
 *          },
 *          resizeHandler;
 *
 *      resizeHandler = new ResizeHandler({
 *          width: 8,
 *          height: 8,
 *          parent: shape,
 *          orientation: 'nw'                   // see jQueryUI's resizable plugin 'handles' option
 *          representation: rectangle,
 *          resizableStyle: resizableStyle,
 *          nonResizableStyle: nonResizableStyle,
 *          zOrder: 2
 *      });
 *
 * @extend Handler
 * @constructor Creates an instance of resize handler.
 * @param {Object} options
 * @cfg {number} [width=4] The width of this resize handler.
 * @cfg {number} [height=4] The height of this resize handler.
 * @cfg {Shape} [parent=null] The parent of this resize handler.
 * @cfg {string} [orientation=null] The orientation of this resize handler.
 * @cfg {string} [representation=null] The representation of this resize handler.
 * @cfg {Object} [resizableStyle={}] The parameters to create an instance of the class Style used
 * when the object is resizable.
 * @cfg {Object} [nonResizableStyle={}] The parameters to create an instance of the class Style used
 * when the object is not resizable.
 * @cfg {number} [zOrder=2] The z-index of this resize handler.
 */
ResizeHandler = function (options) {

    Handler.call(this, options);

    /**
     * Category of this resize handler
     * @type {"resizable"/"nonresizable"}
     */
    this.category = null;

    /**
     * Denotes whether the resize handle is visible or not.
     * @property boolean
     */
    this.visible = false;

    /**
     * JSON used to create an instance of the class Style used when the object is resizable.
     * @property {Object}
     */
    this.resizableStyle = null;

    /**
     * JSON used to create an instance of the class Style used when the object is not resizable.
     * @property {Object}
     */
    this.nonResizableStyle = null;

    // set defaults
    ResizeHandler.prototype.initObject.call(this, options);
};

ResizeHandler.prototype = new Handler();

/**
 * The type of each instance of this class.
 * @property {String}
 */
ResizeHandler.prototype.type = "ResizeHandler";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
ResizeHandler.prototype.initObject = function (options) {

    var defaults = {
        width: 4,
        height: 4,
        parent: null,
        orientation: null,
        representation: null,
        resizableStyle: {},
        nonResizableStyle: {},
        zOrder: 2
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // add default zIndex to this handler
    if (defaults.resizableStyle.cssProperties) {
        defaults.resizableStyle.cssProperties.zIndex = defaults.zOrder;
    }
    if (defaults.nonResizableStyle.cssProperties) {
        defaults.nonResizableStyle.cssProperties.zIndex = defaults.zOrder;
    }

    // init
    this.setParent(defaults.parent)
        .setWidth(defaults.width)
        .setHeight(defaults.height)
        .setOrientation(defaults.orientation)
        .setRepresentation(defaults.representation)
        .setResizableStyle(defaults.resizableStyle)
        .setNonResizableStyle(defaults.nonResizableStyle);

    // create the id
    this.id = defaults.orientation + defaults.parent.id + "resizehandler";
};

/**
 * Sets the parent of this handler
 * @param {Shape} newParent
 * @chainable
 */
ResizeHandler.prototype.setParent = function (newParent) {
    this.parent = newParent;
    return this;
};

/**
 * Gets the parent of this handler.
 * @return {Shape}
 */
ResizeHandler.prototype.getParent = function () {
    return this.parent;
};

/**
 * Paints this resize handler by calling it's parent's `paint` and setting
 * the visibility of this resize handler
 * @chainable
 */
ResizeHandler.prototype.paint = function () {
    if (!this.html) {
        throw new Error("paint(): This handler has no html");
    }

    // this line paints the representation (by default a rectangle)
    Handler.prototype.paint.call(this);

    this.setVisible(this.visible);
    return this;
};

/**
 * Sets the category of the resizeHandler (also adds the needed class to
 * make the element resizable)
 * @param newCategory
 * @chainable
 */
ResizeHandler.prototype.setCategory = function (newCategory) {
    if (typeof newCategory === "string") {
        this.category = newCategory;
    }
    if (this.category === "resizable") {
        this.color = new Color(0, 255, 0);
        this.style.addClasses([
            "ui-resizable-handle", "ui-resizable-" + this.orientation
        ]);
    } else {
        this.color = new Color(255, 255, 255);
        this.style.removeClasses([
            "ui-resizable-handle", "ui-resizable-" + this.orientation
        ]);
    }
    return this;
};


/**
 * Sets the resizable style of this shape by creating an instance of the class Style
 * @param {Object} style
 * @chainable
 */
ResizeHandler.prototype.setResizableStyle = function (style) {
    this.resizableStyle = new Style({
        belongsTo: this,
        cssProperties: style.cssProperties,
        cssClasses: style.cssClasses
    });
    return this;
};

/**
 * Sets the non resizable style for this shape by creating an instance of the class Style
 * @param {Object} style
 * @chainable
 */
ResizeHandler.prototype.setNonResizableStyle = function (style) {
    this.nonResizableStyle = new Style({
        belongsTo: this,
        cssProperties: style.cssProperties,
        cssClasses: style.cssClasses
    });
    return this;
};

/**
 * @class SegmentMoveHandler
 * Represents the handler to move a segment (the handlers are visible when a decorator of the parent of this
 * segment is clicked on)
 *
 * An example of use:
 *
 *      // i.e.
 *      // let's assume that segment is an instance of the class Segment
 *      // let's assume that rectangle is an instance of the class Rectangle
 *
 *      segmentMoveHandler = new SegmentMoveHandler({
 *          width: 8,
 *          height: 8,
 *          parent: segment,
 *          orientation: 0                      // corresponds to a vertical segment
 *          representation: rectangle,
 *          color: new Color(255, 0, 0)         // red !!
 *      });
 * @extend Handler
 * @constructor Creates an instance of the class SegmentMoveHandler
 * @param {Object} options
 * @cfg {number} [width=4] The width of this segment move handler.
 * @cfg {number} [height=4] The height of this segment move handler.
 * @cfg {Shape} [parent=null] The parent of this segment move handler.
 * @cfg {number} [orientation=null] The orientation of this segment move handler.
 * @cfg {string} [representation=null] The representation of this segment move handler.
 * @cfg {number} [color=new Color(0, 255, 0)] The color of this segment move handler (green).
 */
SegmentMoveHandler = function (options) {

    Handler.call(this, options);

    /**
     * Orientation of this segment move handler (useful to do the drag).
     * @property {number}
     */
    this.orientation = null;

    /**
     * Denotes whether the SegmentMove point is visible or not.
     * @property {boolean} [visible=false]
     */
    this.visible = false;

    /**
     * The default zOrder of this handler.
     * @property {number} [zOrder=2]
     */
    this.zOrder = 2;

    // set defaults
    SegmentMoveHandler.prototype.initObject.call(this, options);
};

SegmentMoveHandler.prototype = new Handler();

/**
 * Type of each instance of this class
 * @property {String}
 */
SegmentMoveHandler.prototype.type = "SegmentMoveHandler";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
SegmentMoveHandler.prototype.initObject = function (options) {

    var defaults = {
        width: 4,
        height: 4,
        parent: null,
        orientation: null,
        representation : new Rectangle(),
        color: new Color(0, 255, 0)
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // init
    this.setWidth(defaults.width)
        .setHeight(defaults.height)
        .setParent(defaults.parent)
        .setColor(defaults.color)
        .setOrientation(defaults.orientation)
        .setRepresentation(defaults.representation);
};

/**
 * Paints this resize handler by calling it's parent's `paint` and setting
 * the visibility of this resize handler.
 * @chainable
 */
SegmentMoveHandler.prototype.paint = function () {
    // before it was: Rectangle.prototype.paint.call(this);
    Handler.prototype.paint.call(this);
    this.setVisible(this.visible);
    return this;
};

/**
 * Attaches listeners to the segmentMoveHandler, by default it creates the click,
 * mouseDown and draggable events.
 * @param {SegmentMoveHandler} handler
 * @chainable
 */
SegmentMoveHandler.prototype.attachListeners = function (handler) {
    var $handler = $(handler.html);
    $handler.on('click', handler.onClick(handler));
    $handler.on('mousedown', handler.onMouseDown(handler));
    $handler.draggable({
        start: handler.onDragStart(handler),
        drag: handler.onDrag(handler),
        stop: handler.onDragEnd(handler),
        axis: (handler.orientation === handler.HORIZONTAL) ? "y" : "x"
        //containment: handler.parent.parent.html
    });
    return this;
};

/**
 * @event mousedown
 * MouseDown callback fired when the user mouse downs on the `handler`
 * @param {SegmentMoveHandler} handler
 */
SegmentMoveHandler.prototype.onMouseDown = function (handler) {
    return function (e, ui) {
        // This is done to avoid the start of a selection in the canvas
        // handler > segment > connection > canvas
        handler.parent.parent.canvas.draggingASegmentHandler = true;
        //e.stopPropagation();
    };
};

/**
 * @event click
 * Click callback fired when the user clicks on the handler
 * @param {SegmentMoveHandler} handler
 */
SegmentMoveHandler.prototype.onClick = function (handler) {
    return function (e, ui) {
        e.stopPropagation();
    };
};

/**
 * @event dragStart
 * DragStart callback fired when the handler is dragged (it's executed only once).
 * It does the following:
 *
 * 1. Gather the connection by calling the handler's grandparent
 * 2. Save the state if the connection (for the undo-redo stack)
 * 3. Clear all the intersections of each segment of the connection
 *
 * @param {SegmentMoveHandler} handler
 */
SegmentMoveHandler.prototype.onDragStart = function (handler) {
    return function (e, ui) {
        var parentSegment = handler.parent,
            segment,
            connection = parentSegment.getParent(),
            i;

        // TESTING:
        // save values for the undo-redo stack
        connection.savePoints({
            saveToOldPoints: true
        });

        // clear all intersections that exists in
        // parentSegment.parent (connection)
        for (i = 0; i < parentSegment.parent.lineSegments.getSize(); i += 1) {
            segment = parentSegment.parent.lineSegments.get(i);
            segment.clearIntersections();
        }
        // clear all intersections that exists among other connections and
        // parentSegment (the ones that exists in the other connections)
        parentSegment.parent.clearAllIntersections();
        e.stopPropagation();
    };
};

/**
 * @event drag
 * Drag callback fired when the handler is being dragged.
 * It only moves the segment vertically or horizontally.
 *
 * @param {SegmentMoveHandler} handler
 */
SegmentMoveHandler.prototype.onDrag = function (handler) {
    return function (e, ui) {
        var parentSegment = handler.parent;
        parentSegment.moveSegment(ui.position.left, ui.position.top);
    };
};

/**
 * @event dragEnd
 * DragEnd callback fired when the handler stops being dragged.
 * It does the following:
 *
 * 1. Gather the connection by calling the handler's grandparent
 * 2. Save the state if the connection (for the undo-redo stack)
 * 3. Create a command for the undo-redo stack
 *
 * @param {SegmentMoveHandler} handler
 */
SegmentMoveHandler.prototype.onDragEnd = function (handler) {
    return function (e, ui) {
        var parentSegment = handler.parent,
            connection = parentSegment.getParent(),
            canvas = connection.canvas,
            command;

        canvas.draggingASegmentHandler = false;
        handler.onDrag(handler)(e, ui);

        // LOGIC: connection.points is an array of points that is not updated
        // automatically when a connection is painted, it must be
        // explicitly called as connection.savePoints()
        connection.savePoints();
        command = new CommandSegmentMove(connection, {
            oldPoints: connection.getOldPoints(),
            newPoints: connection.getPoints()
        });
        command.execute();
        canvas.commandStack.add(command);

    };
};

/**
 * @class Port
 * Class Port represent a special point in a shape where each point is one end point of a connection
 * (a customShape has many ports and each port has a reference to the connection it belongs to).
 *
 * The relation of this class with customShape and connections are described below:
 *
 * - Each port is one end point of a connection (the connection has links to the start port and the end port,
 *      the port has a link to the connection)
 * - A custom shape might have *n* ports (the parent of the port is the custom shape)
 *      so the custom shape has the HTML of the port on it.
 *
 * Some examples of usage:
 *
 *      // let's assume the connection is an instance of the class Connection
 *      // let's assume the customShape is an instance of the class CustomShape
 *      var port = new Port({
 *          width: 8,
 *          height: 8,
 *          visible: true,
 *          parent: customShape
 *      })
 *
 *      // after a port is created, it need to be added to the customShape
 *      // let's add it at position [100, 100]
 *      customShape.addPort(port, 100, 100)
 *
 *      // finally when a connection is created it needs to have links to the ports
 *      // let's assume that another port is an instance of the class Port
 *      // i.e
 *      connection = new Connection({
 *          srcPort: port,
 *          destPort: anotherPort,
 *          segmentColor: new Color(0, 200, 0),
 *          segmentStyle: "regular"
 *      });
 *
 * @extend JCoreObject
 *
 *
 * @param {Object} options Initialization options
 * @cfg {number} [width=4] The width of this port
 * @cfg {number} [height=4] The height of this port
 * @cfg {boolean} [visible=false] The visibility of this port
 * @cfg {CustomShape} [parent=null] The parent of this port
 *
 * @constructor Creates an instance of the class Port
 */
Port = function (options) {

    JCoreObject.call(this);

    /**
     * Connection to whom this port belongs to
     * @property {Connection}
     */
    this.connection = null;

    /**
     * Representation (Shape) of the port when it is connected (currently it's represented as an {@link Oval})
     * @property {Shape}
     */
    this.representation = null;

    /**
     * Parent of this port.
     * @property {CustomShape}
     */
    this.parent = null;

    /**
     * Old parent of this port.
     * @property {CustomShape}
     */
    this.oldParent = null;

    /**
     * Port direction respect to its parent (its parent is an instance of {@link CustomShape}).
     * @property {number}
     */
    this.direction = null;

    /**
     * The percentage relative to where the port is located regarding one of
     * the shape dimensions (useful to recalculate the ports position while resizing).
     * @property {number}
     */
    this.percentage = null;

    /**
     * Current zIndex of the port.
     * @property {number} [zOrder=1]
     */
    this.zOrder = 1;

    /**
     * Default zIndex of the ports.
     * @property {number} [defaultZOrder=1]
     */
    this.defaultZOrder = 1;

    /**
     * X coordinate sent to the database
     * @property {number} [realX=0]
     */
    this.realX = 0;
    /**
     * Y coordinate sent to the database
     * @property {number} [realY=0]
     */
    this.realY = 0;

    this.dragging = false;

    Port.prototype.initObject.call(this, options);
};

Port.prototype = new JCoreObject();

/**
 * The distance moved when a connection is selected (when a connection is
 * selected the ports move towards the center of the shape so that it's
 * easier to drag the ports)
 * @property {number} [TOWARDS_CENTER=5]
 */
Port.prototype.TOWARDS_CENTER = 5;

/**
 * Type of each instance of this class
 * @property {String}
 */
Port.prototype.type = "Port";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * @param {Object} options The object that contains the config
 * @private
 */
Port.prototype.initObject = function (options) {
    /**
     * Default options for the object
     * @property {Object}
     */
    var defaults = {
        width: 8,
        height: 8,
        visible: false,
        parent: null
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);
    $.extend(true, defaults, {
        // oval is initialized with default values
        representation: new Oval({
            width: defaults.width,
            height: defaults.height,
            center: new Point(0, 0),
            visible: true
        })
    });

    // call setters using the defaults object
    this.setVisible(defaults.visible)
        .setParent(defaults.parent)
        .setDimension(defaults.width, defaults.height)
        .setRepresentation(defaults.representation);
};

/**
 * Creates the HTML Representation of the Port
 * @returns {HTMLElement}
 */
Port.prototype.createHTML = function () {
    JCoreObject.prototype.createHTML.call(this);
    this.html.style.background = 'red';
    this.html.style.borderRadius = '1em'; // w3c
    this.html.style.MozBorderRadius = '1em'; // mozilla

    this.style.addClasses(["port"]);
    return this.html;
};

/**
 * Moves this port (considering the borders) after executing the zoom operation.
 * @param {number} positive
 * @chainable
 */
Port.prototype.applyBorderMargin = function (positive) {
    var factor = (positive) ? 1 : -1;
    this.x += factor * this.parent.border[this.direction].x;
    this.y += factor * this.parent.border[this.direction].y;
    this.zoomX = this.x;
    this.zoomY = this.y;
    this.setAbsoluteX();
    this.setAbsoluteY();

    if (this.html) {
        this.style.addProperties({
            left: this.zoomX,
            top: this.zoomY
        });
    }
    return this;
};

/**
 * Sets the x coordinate of this port
 * @param {number} newX
 * @chainable
 */
Port.prototype.setX = function (newX) {
    this.x = newX;
    this.zoomX = this.x;
    if (this.canvas) {
        this.realX = this.x / this.canvas.zoomFactor;
    } else {
        this.realX = this.x;
    }
    this.setAbsoluteX();
    if (this.html) {
        this.style.addProperties({left: this.zoomX});
//            this.html.style.top = this.zoomY + "px";
    }
    return this;
};

/**
 * Sets the y coordinate of this port
 * @param {number} newY
 * @chainable
 */
Port.prototype.setY = function (newY) {
    this.y = newY;
    this.zoomY = this.y;
    this.setAbsoluteY();
    if (this.canvas) {
        this.realY = this.y / this.canvas.zoomFactor;
    } else {
        this.realY = this.y;
    }
    if (this.html) {
        this.style.addProperties({top: this.zoomY});
//            this.html.style.top = this.zoomY + "px";
    }
    return this;
};

/**
 * Sets the width of this port
 * @param {number} newWidth
 * @chainable
 */
Port.prototype.setWidth = function (newWidth) {
    this.width = newWidth;
    this.zoomWidth = this.width;
    if (this.html) {
        this.style.addProperties({width: this.zoomWidth});
//            this.html.style.width = this.zoomWidth + "px";
    }
    return this;
};

/**
 * Sets the width of this port
 * @param {number} newHeight
 * @chainable
 */
Port.prototype.setHeight = function (newHeight) {
    this.height = newHeight;
    this.zoomHeight = this.height;
    if (this.html) {
        this.style.addProperties({height: this.zoomHeight});
//            this.html.style.width = this.zoomWidth + "px";
    }
    return this;
};

/**
 * Paint the port appending its `representation` HTML to `this` HTML.
 * @chainable
 */
Port.prototype.paint = function () {

    // this line is reworked:
    // original: Oval.prototype.paint.call(this);
    //this.html.appendChild(this.representation.getHTML());
    //this.representation.paint();

    // sets the visibility of this port
    this.setVisible(this.visible);

    // apply predefined style
    this.style.applyStyle();

    return this;
};

/**
 * Repaints the port re-applying its left and top position.
 * @param {Port} port
 * @chainable
 */
Port.prototype.repaint = function (port) {

    port.style.addProperties({
        left: port.x,
        top: port.y
    });
    port.connection.disconnect();
    port.connection.connect();
    port.connection.setSegmentMoveHandlers();
    port.connection.checkAndCreateIntersectionsWithAll();
    return this;
};

/**
 * @event dragStart
 * DragStart callback fired when the port is dragged (it's executed only once).
 * It does the following:
 *
 * 1. Moves the port away from the center
 * 2. Moves the otherPort away from the center
 * 3. Disconnects the connection
 *
 * @param {Port} port
 * @param {Port} otherPort
 */
Port.prototype.onDragStart = function (port, otherPort) {
    return function (e, ui) {

        // move the ports off the center, they'll be correctly repositioned
        // later (in "onDragEnd")
        //otherPort.moveTowardsTheCenter(true);
        //port.moveTowardsTheCenter(true);
        port.dragging = true;
        port.setColor('#40CA09');
        port.connection.disconnect();
        return true;
    };
};

/**
 * @event drag
 * Drag callback fired when the port is being dragged.
 * It makes a new segment from the other port to the current position of the mouse.
 *
 * @param {Port} port
 * @param {Point} endPoint
 * @param {Port} otherPort
 * @param {Canvas} canvas
 */
Port.prototype.onDrag = function (port, endPoint, otherPort, canvas) {
    return function (e, ui) {
        if (canvas.connectionSegment) {
            $(canvas.connectionSegment.getHTML()).remove();
        }

        endPoint.x = e.pageX - canvas.getX() + canvas.getLeftScroll();
        endPoint.y = e.pageY - canvas.getY() + canvas.getTopScroll();
        //make connection segment
        canvas.connectionSegment = new Segment({
            startPoint : otherPort.getPoint(false),
            endPoint : endPoint,
            parent : canvas
        });
        canvas.connectionSegment.pointsTo = port;
        canvas.connectionSegment.createHTML();
        canvas.connectionSegment.paint();
    };
};

/**
 * @event dragEnd
 * DragEnd callback fired when the port stops being dragged.
 * It does the following:
 *
 * 1. Repaints the port
 * 2. Moves otherPort towards the center of the shape
 * 3. Moves port towards the center of the shape
 * 4. Shows the handlers of the connection
 *
 * @param {Port} port
 * @param {Port} otherPort
 * @param {Canvas} canvas
 */
Port.prototype.onDragEnd = function (port, otherPort, canvas) {
    return function (e, ui) {

        if (canvas.connectionSegment) {
            $(canvas.connectionSegment.getHTML()).remove();
        }
        port.repaint(port);

        // move the ports towards the center of its parent
        // (they were moved off the center in "onDragStart")
        //otherPort.moveTowardsTheCenter();
        //port.moveTowardsTheCenter();

        // show the segmentMoveHandlers
        port.connection.showMoveHandlers();
        port.dragging = false;
        port.setColor('red');
    };
};

/**
 * Determine the percentage relative to the shape where the port is located.
 * The range of `this.percentage` is from 0 to 1 (inclusive).
 * @return {boolean}
 */
Port.prototype.determinePercentage = function () {
    //Shape and port dimension to consider, it can be either width or height
    var shapeDimension,
        portDimension;
    if (!this.parent) {
        return false;
    }
    if (this.direction === this.TOP || this.direction === this.BOTTOM) {
        shapeDimension = this.parent.getZoomWidth();
        portDimension = this.x;
    } else {
        shapeDimension = this.parent.getZoomHeight();
        portDimension = this.y;
    }

    this.percentage = Math.round((portDimension / shapeDimension) * 100.0);
    return true;
};

/**
 * Shows this port (moving it's HTML representation towards the center for easy dragging).
 * @chainable
 */
Port.prototype.show = function () {
    this.visible = true;

    this.paint();
    this.html.style.zIndex = 3;
    // move the ports towards the center
    //this.moveTowardsTheCenter();

    return this;
};

/**
 * Hides this port (moving it's HTML representation off the center of the shape).
 * @chainable
 */
Port.prototype.hide = function () {
    this.visible = false;

    this.paint();
    this.html.style.zIndex = 1;

    // move the ports off the center of the shape
    //this.moveTowardsTheCenter(true);  //reverse: true

    return this;
};

/**
 * Detaches the HTML of the port from the DOM (saving it in `this.html`), it also removes the port
 * from its parent.
 * @chainable
 */
Port.prototype.saveAndDestroy = function () {
    this.parent.removePort(this);  //remove from shape

    // save the html but detach it from the DOM
    this.html = $(this.html).detach()[0];
    return this;
};

/**
 * Attaches event listeners to this port, currently it has the draggable and mouse over events.
 * @param {Port} currPort
 * @return {Port}
 */
Port.prototype.attachListeners = function (currPort) {
    var otherPort,
        portDragOptions;
    otherPort = currPort.connection.srcPort.getPoint(false)
        .equals(currPort.getPoint(false)) ? currPort.connection.destPort :
                currPort.connection.srcPort;

    portDragOptions = {
        //containment : "parent"
        start : currPort.onDragStart(currPort, otherPort),
        drag : currPort.onDrag(currPort, currPort.getPoint(false),
            otherPort, currPort.parent.canvas),
        stop : currPort.onDragEnd(currPort, otherPort, currPort.parent.canvas)

        //revert: false,
        //revertDuration: 0

    };
    $(currPort.html).draggable(portDragOptions);

    $(currPort.html).mouseover(
        function () {
            currPort.setColor('#40CA09');
            $(currPort.html).css('cursor', 'Move');

        }
    );

    $(currPort.html).mouseleave(
        function () {
           if(!currPort.dragging) {
               currPort.setColor('red');
           }

        }
    );

    return currPort;
};
/**
 * Sets the Port color.
 * @param {String} newColor
 * @chainable
 */
Port.prototype.setColor = function (newColor) {
    this.html.style.background = newColor;
    return this;
};
/**
 * Moves a port towards or off the center (for easy dragging).
 * @param {boolean} reverse If it's set to true then it will move it off the center
 * @chainable
 */
Port.prototype.moveTowardsTheCenter = function (reverse) {
    var towardsCenterDistance = Port.prototype.TOWARDS_CENTER,
        dx = [0, -towardsCenterDistance, 0, towardsCenterDistance],
        dy = [towardsCenterDistance, 0, -towardsCenterDistance, 0],
        multiplier = 1;

    if (reverse) {
        multiplier = -1;
    }
    this.setPosition(this.x + dx[this.direction] * multiplier,
        this.y + dy[this.direction] * multiplier);
    return this;
};

/**
 * Sets the Direction to the port.
 * @param {number} newDirection
 * @chainable
 */
Port.prototype.setDirection = function (newDirection) {
    if (newDirection >= 0 && newDirection < 4) {
        this.direction = newDirection;
    } else {
        throw new Error("setDirection(): parameter '" + newDirection +
            "'is not valid");
    }
    return this;
};

/**
 * Get the direction to the port. (0 = TOP, 1 = RIGHT, 2 = BOTTOM, 3 = LEFT)
 * @returns {number}
 */
Port.prototype.getDirection = function () {
    return this.direction;
};

/**
 * Sets the parent of the port.
 * @param {Shape} newParent
 * @param {boolean} triggerChange If set to true it'll fire {@link Canvas#event-changeelement}
 * @chainable
 */
Port.prototype.setParent = function (newParent, triggerChange) {
    //if(newParent.type === "Shape" || newParent.type === "StartEvent" ||
    //newParent.type === "EndEvent")
    if (this.canvas && triggerChange) {
        this.canvas.updatedElement = {
            "id" : this.id,
            "type" : this.type,
            "fields" : [{
                "field" : "parent",
                "oldVal" : this.parent,
                "newVal" : newParent
            }]
        };
        $(this.canvas.html).trigger("changeelement");
    }
    this.parent = newParent;
    return this;
};

/**
 * Gets the parent of the port.
 * @return {Port}
 */
Port.prototype.getParent = function () {
    return this.parent;
};

/**
 * Sets the old parent of this port
 * @param {CustomShape} parent
 * @chainable
 */
Port.prototype.setOldParent = function (parent) {
    this.oldParent = parent;
    return this;
};
/**
 * Gets the old parent of this port.
 * @return {Port}
 */
Port.prototype.getOldParent = function () {
    return this.oldParent;
};

/**
 * Sets the connection associated with this port.
 * @param {Connection} newConn
 * @chainable
 */
Port.prototype.setConnection = function (newConn) {
    if (newConn && newConn.family === "Connection") {
        this.connection = newConn;
    } else {
        throw new Error("setConnection(): parameter is not valid");
    }
    return this;
};

/**
 * Gets the connection associated with this port
 * @returns {Connection}
 */
Port.prototype.getConnection = function () {
    return this.connection;
};

/**
 * Returns the representation of the port (currently an instance of the class {@link Oval})
 * @returns {Oval}
 */
Port.prototype.getRepresentation = function () {
    return this.representation;
};

/**
 * Sets the representation of this port (not supported yet)
 * @param {Shape} newRep
 * @chainable
 */
Port.prototype.setRepresentation = function (newRep) {
    if (newRep instanceof RegularShape) {
        this.representation = newRep;
    } else {
        throw new Error("setRepresentation(): parameter must be an instance" +
            " of any regularShape");
    }
    return this;
};

/**
 * Gets the ports position (if `relativeToShape` is set to true it'll return the position
 * respect to the shape, otherwise it'll return its position respect to the canvas)
 * @param {boolean} relativeToShape
 * @returns {Point}
 */
Port.prototype.getPoint = function (relativeToShape) {
    var border = parseInt(this.parent.style.getProperty('border'), 10) || 0;
    if (relativeToShape) {
        return new Point(this.getX() + Math.round(this.getWidth() / 2),
            this.getY() + Math.round(this.getHeight() / 2));
    }
//    console.log(this.getAbsoluteX());
//    console.log(this.getAbsoluteY());
//    console.log(new Point(this.getAbsoluteX() + Math.round(this.getWidth() / 2),
//        this.getAbsoluteY() + Math.round(this.getHeight() / 2)));
    return new Point(
        this.getAbsoluteX() + Math.round(this.getWidth() / 2),
        this.getAbsoluteY() + Math.round(this.getHeight() / 2)
    );

};

/**
 * Gets the percentage of this port relative to its parent.
 * @return {number}
 */
Port.prototype.getPercentage = function () {
    return this.percentage;
};

/**
 * Serializes this port.
 * @return {Object}
 * @return {number} return.x
 * @return {number} return.y
 * @return {number} return.realX
 * @return {number} return.realY
 * @return {string} return.parent The ID of its parent.
 */
Port.prototype.stringify = function () {
    var inheritedJSON = {},
        thisJSON = {
//            id: this.getID(),
            x: this.getX(),
            y: this.getY(),
            realX : this.realX,
            realY : this.realY,
//            direction: this.getDirection(),
//            percentage: this.getPercentage(),
            parent: this.getParent().getID()
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * @abstract
 * @class Router
 * Represents the router used to define the points for a connection.
 * @extend JCoreObject
 *
 * @constructor Creates an instance of the class Router
 */
Router = function () {
    JCoreObject.call(this);
};

Router.prototype = new JCoreObject();

/**
 * The type of each instance of this class
 * @property {String}
 */
Router.prototype.type = "Router";

/**
 * @abstract Abstract method to create a route (defined in other inherited classes)
 * @returns {boolean}
 */
Router.prototype.createRoute = function () {
    return true;
};

/**
 * @class ManhattanConnectionRouter
 * Class ManhattanConnectionRouter uses the 'ManhattanRouter' algorithm to define the points of the connection.
 * @extends Router
 *
 * @constructor Creates an instance of the class ManhattanConnectionRouter
 */
ManhattanConnectionRouter = function () {
    Router.call(this);
    /**
     * Minimum distance used in the algorithm
     * @property {number} [mindist=20]
     */
    this.mindist = 20;
};

ManhattanConnectionRouter.prototype = new Router();

/**
 * The type of each instance of this class
 * @property {String}
 */
ManhattanConnectionRouter.prototype.type = "ManhattanConnectionRouter";

/**
 * Creates the points of `connection` by calling the #route method and using
 * `connection.srcPort` and `connection.destPort` as the start and end points
 * @param {Connection} connection
 * @return {Array} An array of points that define the connection.
 */
ManhattanConnectionRouter.prototype.createRoute = function (connection) {
    var fromPt, fromDir, toPt, toDir, points = [];

    fromPt = connection.srcPort.getPoint(false);
    fromDir = connection.srcPort.direction;

    toPt = connection.destPort.getPoint(false);
    toDir = connection.destPort.direction;

    // draw a line between the two points.
    this.route(connection, toPt, toDir, fromPt, fromDir, points);
    return points;
};

/**
 * Implementation of the 'MahattanRouter' algorithm
 * @param {Connection} conn Instance of the class Connection
 * @param {Point} fromPt initial Point
 * @param {number} fromDir route using to begin line
 *        UP = 0; RIGHT= 1; DOWN = 2; LEFT = 3;
 * @param {Point} toPt final Point
 * @param {number} toDir route using to end line
 *        UP = 0; RIGHT= 1; DOWN = 2; LEFT = 3;
 * @param {Array} points array where points are saved
 */
ManhattanConnectionRouter.prototype.route = function (conn, fromPt, fromDir,
                                                      toPt, toDir, points) {
    var TOL,
        TOLxTOL,
        UP,
        RIGHT,
        DOWN,
        LEFT,
        xDiff,
        yDiff,
        nPoint,
        dir,
        pos;

    TOL = 0.1;
    TOLxTOL = 0.01;

    // fromPt is an x,y to start from.
    // fromDir is an angle that the first link must
    //
    UP = 0;
    RIGHT = 1;
    DOWN = 2;
    LEFT = 3;

    xDiff = fromPt.x - toPt.x;
    yDiff = fromPt.y - toPt.y;

    if (((xDiff * xDiff) < (TOLxTOL)) && ((yDiff * yDiff) < (TOLxTOL))) {
        points.push(toPt);
        return;
    }

    if (fromDir === LEFT) {
        if ((xDiff > 0) && ((yDiff * yDiff) < TOL) && (toDir === RIGHT)) {
            nPoint = toPt;
            dir = toDir;
        } else {
            if (xDiff < 0) {
                nPoint = new Point(fromPt.x - this.mindist, fromPt.y);
            } else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) &&
                (toDir === UP))) {
                nPoint = new Point(toPt.x, fromPt.y);
            } else if (fromDir === toDir) {
                pos = Math.min(fromPt.x, toPt.x) - this.mindist;
                nPoint = new Point(pos, fromPt.y);
            } else {
                nPoint = new Point(fromPt.x - (xDiff / 2), fromPt.y);
            }

            if (yDiff > 0) {
                dir = UP;
            } else {
                dir = DOWN;
            }
        }
    } else if (fromDir === RIGHT) {
        if ((xDiff < 0) && ((yDiff * yDiff) < TOL) && (toDir === LEFT)) {
            nPoint = toPt;
            dir = toDir;
        } else {
            if (xDiff > 0) {
                nPoint = new Point(fromPt.x + this.mindist, fromPt.y);
            } else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) &&
                (toDir === UP))) {
                nPoint = new Point(toPt.x, fromPt.y);
            } else if (fromDir === toDir) {
                pos = Math.max(fromPt.x, toPt.x) + this.mindist;
                nPoint = new Point(pos, fromPt.y);
            } else {
                nPoint = new Point(fromPt.x - (xDiff / 2), fromPt.y);
            }

            if (yDiff > 0) {
                dir = UP;
            } else {
                dir = DOWN;
            }
        }
    } else if (fromDir === DOWN) {
        if (((xDiff * xDiff) < TOL) && (yDiff < 0) && (toDir === UP)) {
            nPoint = toPt;
            dir = toDir;
        } else {
            if (yDiff > 0) {
                nPoint = new Point(fromPt.x, fromPt.y + this.mindist);
            } else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) &&
                (toDir === LEFT))) {
                nPoint = new Point(fromPt.x, toPt.y);
            } else if (fromDir === toDir) {
                pos = Math.max(fromPt.y, toPt.y) + this.mindist;
                nPoint = new Point(fromPt.x, pos);
            } else {
                nPoint = new Point(fromPt.x, fromPt.y - (yDiff / 2));
            }

            if (xDiff > 0) {
                dir = LEFT;
            } else {
                dir = RIGHT;
            }
        }
    } else if (fromDir ===   UP) {
        if (((xDiff * xDiff) < TOL) && (yDiff > 0) && (toDir === DOWN)) {
            nPoint = toPt;
            dir = toDir;
        } else {
            if (yDiff < 0) {
                nPoint = new Point(fromPt.x, fromPt.y - this.mindist);
            } else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) &&
                (toDir === LEFT))) {
                nPoint = new Point(fromPt.x, toPt.y);
            } else if (fromDir === toDir) {
                pos = Math.min(fromPt.y, toPt.y) - this.mindist;
                nPoint = new Point(fromPt.x, pos);
            } else {
                nPoint = new Point(fromPt.x, fromPt.y - (yDiff / 2));
            }

            if (xDiff > 0) {
                dir = LEFT;
            } else {
                dir = RIGHT;
            }
        }
    }

    this.route(conn, nPoint, dir, toPt, toDir, points);
    points.push(fromPt);
};

/**
 * @class ConnectionDecorator
 * Represents the decorator on each endpoint of a connection (represented as srcDecorator and destDecorator in
 * the class Connection).
 * The connection will be painted as follows:
 *
 * 1. Each connection decorator is painted with a CSS sprite
 * 2. The CSS class is built concatenating (with underscores) the following:
 *
 *      1. The prefix (passed as an argument in the config options)
 *      2. The zoom factor multiplied by 100
 *      3. The decorator type (passed as an argument in the config options)
 *      4. The direction of the decorator (which is the same as the direction of the port it corresponds to)
 *
 * Some examples:
 *
 *      // i.e.
 *      // let's assume that the zoom factor is 1
 *      // let's assume that connection is an instance of the class Connection
 *
 *      // To create a target decorator
 *      var connectionDecorator = new ConnectionDecorator({
 *          decoratorPrefix: 'con',
 *          decoratorType: 'target',
 *          style: {
 *              cssClasses: [],
 *              cssProperties: {}
 *          },
 *          parent: connection
 *      });
 *
 *      // assuming that the direction of the port is (1) TOP
 *      // paint() will build the class like this:
 *      // CSSClass = decoratorPrefix + "_" + zoomFactor * 100 + "_" + decoratorType + "_" + direction
 *      // CSSClass = "con_100_target_TOP"
 *
 *      // To create a source decorator
 *      var connectionDecorator = new ConnectionDecorator({
 *          decoratorPrefix: 'con',
 *          decoratorType: 'source',
 *          style: {
 *              cssClasses: [],
 *              cssProperties: {}
 *          },
 *          parent: connection
 *      });
 *
 *      // assuming that the direction of the port is (3) LEFT
 *      // paint() will build the class like this:
 *      // CSSClass = decoratorPrefix + "_" + zoomFactor * 100 + "_" + decoratorType + "_" + direction
 *      // CSSClass = "con_100_source_LEFT"
 *
 * @extends JCoreObject
 *
 * @constructor Creates an instance of the class ConnectionDecorator
 * @param {Object} options Initialization options
 * @cfg {Point} [decoratorPrefix=''] Decorator prefix used to reconstruct the css class for the sprite
 * @cfg {Connection} [parent=null] The parent of this decorator (must be an instance of the class Connection)
 * @cfg {Object} [style={cssClasses:[], cssProperties:{}}] CSS classes and properties
 */
ConnectionDecorator = function (options) {

    JCoreObject.call(this, options);

    /**
     * Parent of this decorator (must be a Connection)
     * @property {Connection}
     */
    this.parent = null;

    /**
     * The type of this decorator (either "source" or "target")
     * @property {"source" / "target"}
     */
    this.decoratorType = null;

    /**
     * Decorator prefix of this decorator to build the CSS class for the sprite
     * @property {String}
     */
    this.decoratorPrefix = null;

    /**
     * This parameter is an array to see if the end point
     * is UP, RIGHT, BOTTOM and LEFT
     * @property {Object} spriteDirection
     * @property {string} [spriteDirection.0="top"] Enum for "top"
     * @property {string} [spriteDirection.1="right"] Enum for "right"
     * @property {string} [spriteDirection.2="bottom"] Enum for "bottom"
     * @property {string} [spriteDirection.3="left"] Enum for "left"
     */
    this.spriteDirection = {'0' : 'top', '1' : 'right',
        '2' : 'bottom', '3' : 'left'};

    /**
     * Height of this decorator
     * @property {number} [height=11]
     */
    this.height = 11;

    /**
     * Width of this decorator
     * @property {number} [width=11]
     */
    this.width = 11;

    /**
     * Separator used to build the class
     * @type {String}
     */
    this.separator = null;

    /**
     * Sprite used to build the class
     * @type {String}
     */
    this.sprite = null;

    /**
     * The class that will be constructed using the parameters given in
     * the options object
     * @type {string}
     */
    this.cssClass = null;

    ConnectionDecorator.prototype.initObject.call(this, options);
};

ConnectionDecorator.prototype = new JCoreObject();

/**
 * Type of this connection decorator
 * @property {String}
 */
ConnectionDecorator.prototype.type = "ConnectionDecorator";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
ConnectionDecorator.prototype.initObject = function (options) {

    var defaults = {
        sprite: 'bpmn_zoom',
        decoratorPrefix: '',
        separator: '_',
        decoratorType: 'target',
        parent: null
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // init
    this.setDecoratorType(defaults.decoratorType)
        .setDecoratorPrefix(defaults.decoratorPrefix)
        .setSeparator(defaults.separator)
        .setSprite(defaults.sprite)
        .setParent(defaults.parent)
        .setCssClass('');       // cssClass defaults to empty
};

/**
 * Paints the connectionDecorator according to the parameters saved in `this.initObject`.
 * The steps to paint the decorator are:
 *
 * 1. Determine if this decorator belongs to the source or destination port
 * 2. Determine the direction of the decorator
 * 3. Build the class using the direction, decorator prefix, decorator type and zoom
 * 4. Determine the position of this decorator
 *
 * @chainable
 */
ConnectionDecorator.prototype.paint = function () {

    var point,
        canvas,
        direction,
        port,           // the port it "belongs to"
        topStyle,
        leftStyle;

    if (this.decoratorType === "source") {
        port = this.parent.getSrcPort();
    } else {
        port = this.parent.getDestPort();
    }

    point = port.getPoint(false);
    direction = port.getDirection();
    canvas = port.canvas;

    topStyle = [
        point.y - this.zoomHeight,
        point.y - Math.round(this.zoomHeight / 2),
        point.y,
        point.y - Math.round(this.zoomHeight / 2)
    ];
    leftStyle = [
        point.x - Math.round(this.zoomWidth / 2) + 1,
        point.x,
        point.x - Math.round(this.zoomWidth / 2) + 1,
        point.x - this.zoomWidth
    ];

    if (this.getHTML() === null) {
        this.createHTML();
    }

    if (this.decoratorType === null) {
        this.html = null;
        return this;
    }

    // remove the last class if possible
    this.style.removeClasses([this.cssClass]);

    // construct the new class to be applied
    this.setCssClass([this.prefix, parseInt(canvas.zoomFactor * 100, 10),
        this.decoratorType, this.spriteDirection[direction]].join(this.separator));

    this.style.addClasses([
        this.sprite,
        this.getCssClass()
    ]);

    // top and left position
    this.style.addProperties({
        top: topStyle[direction],
        left: leftStyle[direction]
    });

    this.parent.html.appendChild(this.html);
    return this;
};

/**
 * Creates the HTML Representation of the SourceSpriteConnectionDecorator
 * @returns {HTMLElement}
 */
ConnectionDecorator.prototype.createHTML = function () {
    this.html = document.createElement('div');
    this.html.id = this.id;
    this.style.applyStyle();
    this.style.addProperties({
        position: "absolute",
        left: 0,
        top: 0,
        height: this.zoomHeight,
        width: this.zoomWidth,
        zIndex: Style.MAX_ZINDEX    // (segments are 1) so this should be 2
    });

    return this.html;
};

/**
 * Attaches listeners to the connectionDecorator (currently it has click and mouseDown events)
 * @chainable
 */
ConnectionDecorator.prototype.attachListeners = function () {
    var $connectionDecorator;
    $connectionDecorator = $(this.getHTML()).click(this.onClick(this));
//    $connectionDecorator.on("contextmenu", this.onRightClick(this));
    $connectionDecorator.on("mousedown", this.onMouseDown(this));
    return this;
};

/**
 * Refresh the dimension and position of the decorator to apply the current
 * zoom scale
 * @chainable
 */
ConnectionDecorator.prototype.applyZoom = function () {
    this.setDimension(this.width, this.height);
    return this;
};
/**
 * @event mousedown
 * ConnectionDecorator mouse down callback fired when the mouse is down on it.
 * @param {ConnectionDecorator} decorator
 */
ConnectionDecorator.prototype.onMouseDown = function (decorator) {
    return function (e, ui) {
        e.preventDefault();
        if (e.which === 3) {    // right click
            decorator.parent.canvas.updatedElement = decorator.parent;
            $(decorator.parent.canvas.html).trigger("rightclick");
        }
        e.stopPropagation();
    };
};
// commented by mauricio on 17/12/12
// reason: it was an example on how to change the segment style of the connection
///**
// * XXX
// * @param decorator
// * @return {Function}
// */
//ConnectionDecorator.prototype.onRightClick = function (decorator) {
//    return function (e, ui) {
//        if (decorator.parent.canvas.currentConnection) {
//            var test = ["normal", "message", "association"],
//                style = ["regular", "dotted", "segmented", "segmentdot"],
//                connection = decorator.parent;
//            connection.getDestPort().moveTowardsTheCenter(true);
//            connection.getDestDecorator()
//                .setDecoratorPrefix("con_" + test[parseInt(Math.random() * 3, 10)]);
//            connection.getDestDecorator().paint();
//            connection.getDestPort().moveTowardsTheCenter();
//            connection.setSegmentStyle(style[parseInt(Math.random() *
//                style.length, 10)]);
//            e.preventDefault();
//        }
//    };
//};

/**
 * @event click
 * Click callback fired when the decorator is clicked on.
 * It hides the currentSelection if any and shows the ports and handlers of `decorator` parent
 * (which is a connection).
 * @param {ConnectionDecorator} decorator
 */
ConnectionDecorator.prototype.onClick = function (decorator) {
    return function (e, ui) {
        var connection = decorator.parent,
            oldConnection = decorator.parent.canvas.currentConnection,
            canvas = connection.canvas;

        // HIDE
        // if there were some shapes in the current selection then
        // empty the current selection
        canvas.emptyCurrentSelection();

        // if there was a connection previously select hide its ports
        // and its handlers
        if (oldConnection) {
            oldConnection.hidePortsAndHandlers();
        }

        // SHOW
        // show the ports and the handlers of the new connection
        connection.showPortsAndHandlers();

        // set the old connection as this connection
        canvas.currentConnection = connection;

        // TODO: zIndex
        e.stopPropagation();
    };
};

/**
 * Serializes this connection decorator.
 * @return {Object}
 * @return {"source" / "target"} return.decoratorType The decorator type to build the CSS class for the sprite
 * @return {string} return.decoratorPrefix The decorator prefix to build the CSS class for the sprite
 */
ConnectionDecorator.prototype.stringify = function () {
    var inheritedJSON = {},
        thisJSON = {
            decoratorType: this.getDecoratorType(),
            decoratorPrefix: this.getDecoratorPrefix()
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * Returns the decorator type
 * @returns {String}
 */
ConnectionDecorator.prototype.getDecoratorType = function () {
    return this.decoratorType;
};

/**
 * Sets the decoration type
 * @param {String} newType
 * @chainable
 */
ConnectionDecorator.prototype.setDecoratorType = function (newType) {
    this.decoratorType = newType;
    return this;
};

/**
 * Returns the decorator type
 * @returns {String}
 */
ConnectionDecorator.prototype.getDecoratorPrefix = function () {
    return this.prefix;
};

/**
 * Sets the decoration prefix
 * @param {String} newType
 * @chainable
 */
ConnectionDecorator.prototype.setDecoratorPrefix = function (newType) {
    this.prefix = newType;
    return this;
};

/**
 * Sets the parent of this connectionDecorator
 * @param {Connection} newParent
 * @chainable
 */
ConnectionDecorator.prototype.setParent = function (newParent) {
    this.parent = newParent;
    return this;
};

/**
 * Gets the parent of this connectionDecorator
 * @return {Connection}
 */
ConnectionDecorator.prototype.getParent = function () {
    return this.parent;
};

/**
 * Sets the separator of this connectionDecorator
 * @param {String} newSeparator
 * @chainable
 */
ConnectionDecorator.prototype.setSeparator = function (newSeparator) {
    this.separator = newSeparator;
    return this;
};

/**
 * Sets the sprite of this connectionDecorator
 * @param {String} newSprite
 * @chainable
 */
ConnectionDecorator.prototype.setSprite = function (newSprite) {
    this.sprite = newSprite;
    return this;
};

/**
 * Gets the separator of this connectionDecorator
 * @return {String}
 */
ConnectionDecorator.prototype.getSeparator = function () {
    return this.separator;
};

/**
 * Sets the cssClass of this connectionDecorator
 * @param {string} newCssClass
 * @chainable
 */
ConnectionDecorator.prototype.setCssClass = function (newCssClass) {
    this.cssClass = newCssClass;
    return this;
};

/**
 * Gets the cssClass of this connectionDecorator
 * @return {string}
 */
ConnectionDecorator.prototype.getCssClass = function () {
    return this.cssClass;
};

/**
 * @class Connection
 * Class that represents a connection between two elements in the diagram.
 *
 * A connection is defined with a set of points, there's a segment between two points i.e. `point[i]`
 * and `point[i + 1]` with `i >= 0` and `i < points.length - 1`, there are two ways to paint a connection:
 *
 * - given *2* {@link Port Ports}, use the algorithm 'ManhattanConnection' to define the points
 * - given *n* points, make the segments with the rule defined above (but first let's use the first and
 *      the last points to make them {@link Port Ports}).
 *
 * Some characteristics of the connection:
 *
 * - The connection has references to its source port and end port.
 * - The `state` of the connection is the set of points that define that connection.
 * - The connections can have a color, the color is an instance of the class Color.
 *
 * The connections can have the following types of segments:
 *
 * - regular (a complete segment)
 * - dotted
 * - segmented
 * - segmented and dotted (mixed)
 *
 * Some examples of the configuration:
 *
 *      // i.e.
 *      // let's assume that there are two shapes (sourceShape and destShape)
 *      // let's assume that srcPort is a port that is stored in sourceShape
 *      // let's assume that destPort is a port that is stored in destShape
 *      // to create an instance of Connection with regular light green segments
 *      var connectionGreen = new Connection({
 *          srcPort: srcPort,
 *          destPort: destPort,
 *          segmentColor: new Color(0, 200, 0),
 *          segmentStyle: "regular"
 *      });
 *      // to create an instance of Connection with dotted red segments
 *      var connectionRed = new Connection({
 *          srcPort: srcPort,
 *          destPort: destPort,
 *          segmentColor: new Color(255, 0, 0),
 *          segmentStyle: "dotted"
 *      });
 *
 * @extend JCoreObject
 *
 * @constructor Creates an instance of the class Connection
 * @param {Object} options Initialization options
 * @cfg {Point} [srcPort=new Port()] Source port of the connection
 * @cfg {Point} [destPort=new Port()] Destination port of the connection
 * @cfg {Color} [segmentColor=new Color(0, 0, 0)] Color of the connection (by default it's black)
 * @cfg {string} [segmentStyle="regular"] Type of segments as defined above
 */
Connection = function (options) {

    JCoreObject.call(this, options);

    /**
     * The source port of the connection
     * @property {Port}
     */
    this.srcPort = null;

    /**
     * The end port of the connection
     * @property {Port}
     */
    this.destPort = null;

    /**
     * The decorator of the source of the connection
     * @property {ConnectionDecorator}
     */
    this.srcDecorator = null;

    /**
     * The decorator of the target of the connection
     * @property {ConnectionDecorator}
     */
    this.destDecorator = null;

    /**
     * List of the lines that forms the connection
     * @property {ArrayList}
     */
    this.lineSegments = new ArrayList();

    /**
     * Saves a copy of the line segments' points when a flag is passed to the
     * disconnect method (NOTE: this array is used in the
     * userDefinedRoute method)
     * @property {ArrayList}
     */
    this.points = [];

    /**
     * Saves a copy of the line segments' points when a flag is passed to the
     * disconnect method (NOTE: this array is used while creating the object
     * updatedElement in Canvas.triggerConnectionStateChangeEvent)
     * @property {ArrayList}
     */
    this.oldPoints = [];

    /**
     * Current segment style
     * @property {"dotted" / "regular" / "segmented" / "segmentdot"}
     */
    this.segmentStyle = null;

    /**
     * This segment style ej. "dotted", "segmented", "segmentdot" (it's the
     * original style set in `this.initObject()`)
     * @property {"dotted" / "regular" / "segmented" / "segmentdot"}
     */
    this.originalSegmentStyle = null;

    /**
     * Actual color of all the segment in this connection
     * @property {Color}
     */
    this.segmentColor = null;

    /**
     * Original color of all the segments in this connection (set in `this.initObject()`)
     * @property {Color}
     */
    this.originalSegmentColor = null;

    /**
     * default zIndex of the connection
     * @property {number}
     */
    this.defaultZOrder = 2;

    /**
     * Current zIndex of the connection
     * @property {number}
     */
    this.zOrder = 2;

    /**
     * ArrayList which contains the ids of the Connections it has an
     * intersection with:
     *
     *      // i.e.
     *      // let's assume that there's an instance of the class Connection called anotherConnection
     *      intersectionWith = new ArrayList();
     *      intersectionWith.insert(anotherConnection);
     *
     * @property {ArrayList}
     */
    this.intersectionWith = new ArrayList();


    Connection.prototype.initObject.call(this, options);
};

Connection.prototype = new JCoreObject();

/**
 * The type of each instance of this class
 * @property {String}
 */
Connection.prototype.type = "Connection";

/**
 * The family of each instance of this class
 * @property {String}
 */
Connection.prototype.family = "Connection";

/**
 * Router associated with the connection
 * @property {Router}
 */
Connection.prototype.router = new ManhattanConnectionRouter();

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * @param {Object} options The object that contains the config
 * @private
 */
Connection.prototype.initObject = function (options) {
    var defaultOptions = {
        srcPort: new Port(),
        destPort: new Port(),
        segmentColor: new Color(0, 0, 0),
        segmentStyle: "regular"
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaultOptions, options);

    // init
    this.setSrcPort(defaultOptions.srcPort)
        .setDestPort(defaultOptions.destPort)
        .setSegmentStyle(defaultOptions.segmentStyle, false)
        .setSegmentColor(defaultOptions.segmentColor, false);

    // init originals
    this.originalSegmentStyle = defaultOptions.segmentStyle;
    this.originalSegmentColor = defaultOptions.segmentColor;

    // set the connections for each port as this
    this.getSrcPort().setConnection(this);
    this.getDestPort().setConnection(this);
};

/**
 * Creates the HTML Representation of the Connection.
 * @returns {HTMLElement}
 */
Connection.prototype.createHTML = function () {
    this.html = document.createElement('div');
    this.html.id = this.id;

    this.style.addProperties({
        position: "absolute",
        left: 0,
        top: 0,
        height: 0,
        width: 0,
        zIndex: this.zOrder
    });
    return this.html;
};

/**
 * Sets the handlers for each segment.
 * This method sets the handler for each segment, also sets a variable called hasMoveHandler on each segment to
 * either true or false (it'll be false if the current segment is either the first or the last segment of
 * the connection)
 * @chainable
 */
Connection.prototype.setSegmentMoveHandlers = function () {
    var i,
        currentSegment,
        orientationOptions = [this.HORIZONTAL, this.VERTICAL],
        segmentOrientation = (this.destPort.direction === this.TOP ||
            this.destPort.direction === this.BOTTOM) ? 1 : 0;
    for (i = this.lineSegments.getSize() - 1; i >= 0; i -= 1) {
        currentSegment = this.lineSegments.get(i);
        currentSegment.orientation =
            orientationOptions[segmentOrientation];
        currentSegment.hasMoveHandler = false;

        // set prev and next segments
        if (i < this.lineSegments.getSize() - 1 && i > 0) {
            currentSegment.nextNeighbor = this.lineSegments.get(i + 1);
            currentSegment.previousNeighbor = this.lineSegments.get(i - 1);
            currentSegment.hasMoveHandler = true;
            currentSegment.addSegmentMoveHandler();
        }
        segmentOrientation = 1 - segmentOrientation;
    }
    return this;
};

/**
 * Remove all the segmentHandlers of this connection
 * (removing its html)
 * @chainable
 */
Connection.prototype.removeAllSegmentHandlers = function () {
    // delete previous handlers
    var segment,
        i;
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        segment = this.lineSegments.get(i);
        if (segment.hasMoveHandler) {
            $(segment.moveHandler.html).remove();
        }
    }
    return this;
};

/**
 * Show the moveHandlers of the connections
 * @chainable
 */
Connection.prototype.showMoveHandlers = function () {
    var i,
        currentHandler;
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        currentHandler = this.lineSegments.get(i).moveHandler;
        if (currentHandler) {
            currentHandler.setVisible(true);
        }
    }
    return this;
};

/**
 * Hide the moveHandlers of the connection
 * @chainable
 */
Connection.prototype.hideMoveHandlers = function () {
    var i,
        currentHandler;
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        currentHandler = this.lineSegments.get(i).moveHandler;
        if (currentHandler) {
            currentHandler.setVisible(false);
        }
    }
    return this;
};

/**
 * Hides the ports and handlers of this connection.
 * @chainable
 */
Connection.prototype.hidePortsAndHandlers = function () {
    this.hidePorts();
    this.hideMoveHandlers();
    return this;
};

/**
 * Shows the ports and handlers of this connection.
 * @chainable
 */
Connection.prototype.showPortsAndHandlers = function () {
    this.showPorts();
    this.showMoveHandlers();
    return this;
};

/**
 * Paints the connection according to the parameters given as config options, this method `paint()`
 * unlike other similar `paint()` does not append the HTML to the DOM, this is done with a call
 * to `canvas.addConnection(connection)`.
 * @param {Object} options Configuration options
 * @param {string} [options.algorithm="manhattan"] The algorithm used to draw the connection
 * @param {Array} [options.points=[]] Points to be used if the algorithm is "user"
 * @param {number} [options.dx=0] Move the points dx
 * @param {number} [options.dy=0] Move the points dy
 * @chainable
 */
Connection.prototype.paint = function (options) {
    var defaults = {
        algorithm: 'manhattan',
        points: [],
        dx: 0,
        dy: 0
    };
    $.extend(true, defaults, options);
    try {
        if (this.html === null) {
            this.createHTML();
        }

        $(this.html).empty();
        this.oldPoint = null;

        switch (defaults.algorithm) {
        case 'manhattan':
            this.createManhattanRoute();
            break;
        case 'user':
            this.createUserDefinedRoute(defaults.points,
                defaults.dx, defaults.dy);
            break;
        default:
            throw new Error('Connection.paint(): the algorithm provided ' +
                'is not correct');
        }

        // apply predefined style
        this.style.applyStyle();

        // the inline style might have changed in this.move()
        // so restore the style to the original setting
        this.style.addProperties({
            top: 0,
            left: 0
        });

        // paint the decorator if any exists
        if (this.destDecorator !== null) {
            this.destDecorator.paint();
            this.destDecorator.attachListeners();
        }

        if (this.srcDecorator !== null) {
            this.srcDecorator.paint();
        }

        this.oldPoint = null;

    } catch (e) {
        console.log(e.message);
    }
    return this;
};

/**
 * Hides the connection and its intersections
 * @param {boolean} [savePoints] If set to true, the connection state will be saved in `this.points
 * (see the definition of {@link Connection#property-points} in the definition of the class).
 * @chainable
 */
Connection.prototype.disconnect = function (savePoints) {
    this.clearAllIntersections();

    // hide the segment handlers
    this.hideMoveHandlers();

    // save the line segments and use them in the createCustomRoute method
    if (savePoints) {
        this.savePoints();
    }
    this.lineSegments.clear();

    // empty the contents
    $(this.html).empty();

    return this;
};

/**
 * Connects two elements using options as a parameter (alias for `this.paint`)
 * @param {Object} options Configuration options
 * @param {string} [options.algorithm="manhattan"] The algorithm used to draw the connection
 * @param {Array} [options.points=[]] Points to be used if the algorithm is "user"
 * @param {number} [options.dx=0] Move the points dx
 * @param {number} [options.dy=0] Move the points dy
 * @chainable
 */
Connection.prototype.connect = function (options) {
    this.paint(options);
    return this;
};

/**
 * Hides the ports of the connection
 * @chainable
 */
Connection.prototype.hidePorts = function () {
    this.srcPort.hide();
    this.destPort.hide();
    return this;
};

/**
 * Shows the ports of the connection
 * @chainable
 */
Connection.prototype.showPorts = function () {
    this.srcPort.show();
    this.destPort.show();
    return this;
};

/**
 * Saves the state of the connection.
 * @param {Object} options
 * @param {boolean} [options.saveToOldPoints=false] If set to true then it will save the state
 * to `this.oldPoints` array
 * @chainable
 */
Connection.prototype.savePoints = function (options) {
    var i,
        segment,
        point,
        arrayChosen = 'points',
        defaults = {
            saveToOldPoints: false
        };

    $.extend(true, defaults, options);

    if (defaults.saveToOldPoints) {
        arrayChosen = "oldPoints";
    }

    this[arrayChosen] = [];
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        segment = this.lineSegments.get(i);
        if (i === 0) {
            // insert the startPoint only for the first segment
            this[arrayChosen].push(new Point(
                segment.startPoint.x,
                segment.startPoint.y
            ));
        }
        this[arrayChosen].push(new Point(
            segment.endPoint.x,
            segment.endPoint.y
        ));
    }
//    console.log(this[arrayChosen]);
    return this;
};

/**
 * Creates the segments of the connection using points and moving the segments dx and dy
 * @param {Array} points
 * @param {number} dx
 * @param {number} dy
 * @chainable
 */
Connection.prototype.createUserDefinedRoute = function (points, dx, dy) {
    var i,
        segment,
        diffPoint = new Point(dx, dy);
    for (i = 1; i < points.length; i += 1) {
        segment = new Segment({
            startPoint: new Point(
                parseInt(points[i - 1].x, 10),
                parseInt(points[i - 1].y, 10)
            ).add(diffPoint),
            endPoint: new Point(
                parseInt(points[i].x, 10),
                parseInt(points[i].y, 10)
            ).add(diffPoint),
            parent: this,
            canvas: this.canvas,
            color: this.segmentColor
        });
        this.addSegment(segment);
    }
    return this;
};

/**
 * Create the segments of the connection using the points defined by the algorithm "ManhattanConnection"
 * @chainable
 */
Connection.prototype.createManhattanRoute = function () {
    var points = this.router.createRoute(this),
        i,
        segment;
    // create the segments now that we have the points
    for (i = 1; i < points.length; i += 1) {
        segment = new Segment({
            startPoint: new Point(
                parseInt(points[i - 1].x, 10),
                parseInt(points[i - 1].y, 10)
            ),
            endPoint: new Point(
                parseInt(points[i].x, 10),
                parseInt(points[i].y, 10)
            ),
            parent: this,
            canvas: this.canvas,
            color: this.segmentColor
        });
        this.addSegment(segment);
    }
    return this;
};

/**
* Add a segment to the line segments arrayList (painting it first)
* @param {Segment} segment
* @chainable
*/
Connection.prototype.addSegment = function (segment) {
    segment.setStyle(this.segmentStyle);
    segment.paint();
    this.lineSegments.insert(segment);
    return this;
};

/**
 * Destroys the connection but saving its HTML first
 * @chainable
 */
Connection.prototype.saveAndDestroy = function () {

    if (this.canvas.currentConnection) {
        this.hidePortsAndHandlers();
        this.canvas.currentConnection = null;
    }

    // remove this from the canvas connections arrayList
    this.canvas.removeConnection(this);

    //this.canvas.removeFromList(this);
    this.srcPort.saveAndDestroy(); //destroy srcPort
    this.destPort.saveAndDestroy(); //destroy destPort

    // save the html but detach it from the DOM
    this.html = $(this.html).detach()[0];

    return this;
};

/**
 * Fixes the zIndex of the connection based on the parents of the connection ports (which are
 * shapes), the zIndex is defined as the maximum zIndex the ports parents + 2
 * @chainable
 */
Connection.prototype.fixZIndex = function () {
    var sourceShape = this.srcPort.parent,
        destShape = this.destPort.parent,
        sourceShapeParent,
        destShapeParent,
        sourceShapeParentZIndex,
        destShapeParentZIndex;

    if (sourceShape.parent) {
        sourceShapeParent = sourceShape.parent;
    } else {
        sourceShapeParent = sourceShape.canvas;
    }
    sourceShapeParentZIndex = Math.min(sourceShapeParent.getZOrder(),
        sourceShape.getZOrder() - 1);

    if (destShape.parent) {
        destShapeParent = destShape.parent;
    } else {
        destShapeParent = destShape.canvas;
    }
    destShapeParentZIndex = Math.min(destShapeParent.getZOrder(),
        destShape.getZOrder() - 1);

    this.setZOrder(Math.max(sourceShapeParentZIndex, destShapeParentZIndex) +
        2);
    return this;
};
/**
 * Checks and creates intersections of `this` connection with the `otherConnection`
 * @param {Connection} otherConnection
 * @return {boolean} True if there is at least one intersection
 */
Connection.prototype.checkAndCreateIntersections = function (otherConnection) {
    // iterate over all the segments of this connection
    var i,
        j,
        segment,
        testingSegment,
        hasAtLeastOneIntersection = false,
        ip; // intersectionPoint

    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        segment = this.lineSegments.get(i);
        for (j = 0; j < otherConnection.lineSegments.getSize(); j += 1) {
            testingSegment = otherConnection.lineSegments.get(j);

            // create the intersection of the segments if possible
            ip = Geometry.perpendicularSegmentIntersection(segment.startPoint,
                    segment.endPoint, testingSegment.startPoint,
                    testingSegment.endPoint);
            if (ip) {
                hasAtLeastOneIntersection = true;
                segment.createIntersectionWith(testingSegment, ip);
            }
        }
    }
    //console.log("There was an intersection? " + hasAtLeastOneIntersection);
    if (hasAtLeastOneIntersection) {
        if (!this.intersectionWith.find('id', otherConnection.getID())) {
            this.intersectionWith.insert(otherConnection);
        }
        if (!otherConnection.intersectionWith.find('id', this.getID())) {
            otherConnection.intersectionWith.insert(this);
        }
    }
    return hasAtLeastOneIntersection;
};

/**
 * Checks and creates intersections with all the other connections found in this canvas.
 * This method also repaints the segments that have intersections.
 * @chainable
 */
Connection.prototype.checkAndCreateIntersectionsWithAll = function () {
    var i,
        otherConnection,
        segment;
    // create the intersections of this connection
    // each segment of this connection saves the intersections it has with
    // other segments as an ArrayList of Intersections
//    console.log(this.canvas.connections.getSize());
    for (i = 0; i < this.canvas.connections.getSize(); i += 1) {
        otherConnection = this.canvas.connections.get(i);
        if (otherConnection.getID() !== this.getID()) {
            this.checkAndCreateIntersections(otherConnection);
        }
    }

    // after we've got all the intersections
    // paint the segments with their intersections
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        segment = this.lineSegments.get(i);
        if (segment.intersections.getSize()) {
            segment.paintWithIntersections();
        }
    }
    return this;
};

/**
 * Clears all the intersections with the otherConnection that exist in this connection
 * @param {Connection} otherConnection
 * @chainable
 */
Connection.prototype.clearIntersectionsWith = function (otherConnection) {
    var i,
        segment,
        intersectionObject,
        intersectionWasErased;
    for (i = 0; i < this.lineSegments.getSize(); i += 1) {
        intersectionWasErased = false;
        segment = this.lineSegments.get(i);
        while (true) {
            intersectionObject = segment.
                intersections.find('idOtherConnection',
                    otherConnection.getID());
            if (intersectionObject) {
                segment.intersections.remove(intersectionObject);
                intersectionObject.destroy();
            } else {
                break;
            }
            intersectionWasErased = true;
        }
        if (intersectionWasErased) {
            segment.paintWithIntersections();
        }
    }
    // remove other connection from this connection intersectionWith ArrayList
    this.intersectionWith.remove(otherConnection);
    otherConnection.intersectionWith.remove(this);
    return this;
};

/**
 * Clear all the intersections of this connection calling clearIntersectionsWith
 * many times (one for each connection that exists in the canvas)
 * @chainable
 */
Connection.prototype.clearAllIntersections = function () {
    var otherIntersection;
//    console.log("Clearing all: " + this.intersectionWith.getSize());
    while (this.intersectionWith.getSize() > 0) {
        otherIntersection = this.intersectionWith.get(0);
//        console.log(otherIntersection);
        otherIntersection.clearIntersectionsWith(this);
    }
    return this;
};

/**
 * Moves the connection [dx, dy]
 * @param {number} dx
 * @param {number} dy
 * @chainable
 */
Connection.prototype.move = function (dx, dy) {
    var top,
        left;

    // moving with inline style
    top = parseFloat(this.html.style.top);
    left = parseFloat(this.html.style.left);
    $(this.html).css({
        'top': top + dy,
        'left': left + dx
    });
    return this;
};

/**
 * Serializes this object (as a JavaScript object)
 * @return {Object}
 * @return {string} return.segmentStyle The style of each segment of this connection
 * @return {Object} return.srcPort The serialization of `this.srcPort`
 * @return {Object} return.destPort The serialization of `this.destPort`
 * @return {Array} return.state The array of points that represent this connection a.k.a. state
 * @return {string} return.srcDecoratorPrefix The source decorator prefix
 * @return {string} return.destDecoratorPrefix The destination decorator prefix
 */
Connection.prototype.stringify = function () {
    return {
//        id: this.getID(),
        segmentStyle: this.getSegmentStyle(),
        srcPort: this.getSrcPort().stringify(),
        destPort: this.getDestPort().stringify(),
        state: this.savePoints() && this.points,
        srcDecoratorPrefix: this.getSrcDecorator().getDecoratorPrefix(),
        destDecoratorPrefix: this.getDestDecorator().getDecoratorPrefix()
    };
};

/**
 * Sets the color of the segments of this connection
 * @param {Color} newColor
 * @param {boolean} [repaint] True if the segment are to be painted immediately
 * @chainable
 */
Connection.prototype.setSegmentColor = function (newColor, repaint) {
    var i,
        segment;
    this.segmentColor = newColor;
    if (this.html && repaint) {
        for (i = 0; i < this.lineSegments.getSize(); i += 1) {
            segment = this.lineSegments.get(i);
            segment.setColor(this.segmentColor);
            segment.paint();
        }
    }
    return this;
};

/**
 * Get the segment color of this connection
 * @return {Color}
 */
Connection.prototype.getSegmentColor = function () {
    return this.segmentColor;
};

/**
 * Sets the style of each segment of this connection
 * @param {string} newStyle
 * @param {boolean} [repaint] True if the segment are to be painted immediately
 * @chainable
 */
Connection.prototype.setSegmentStyle = function (newStyle, repaint) {
    var i,
        segment;
    this.segmentStyle = newStyle;
    if (this.html && repaint) {
        for (i = 0; i < this.lineSegments.getSize(); i += 1) {
            segment = this.lineSegments.get(i);
            segment.setStyle(this.segmentStyle);
            segment.paint();
        }
    }
    return this;
};

/**
 * Get the segment style of this connection
 * @return {string}
 */
Connection.prototype.getSegmentStyle = function () {
    return this.segmentStyle;
};

/**
 * Sets the source port
 * @param {Port} newSrcPort
 * @chainable
 */
Connection.prototype.setSrcPort = function (newSrcPort) {
    this.srcPort = newSrcPort;
    return this;
};

/**
 * Gets the source port
 * @return {Port}
 */
Connection.prototype.getSrcPort = function () {
    return this.srcPort;
};

/**
 * Sets the destination port
 * @param {Port} newDestPort
 * @chainable
 */
Connection.prototype.setDestPort = function (newDestPort) {
    this.destPort = newDestPort;
    return this;
};

/**
 * Gets the destination port
 * @return {Port}
 */
Connection.prototype.getDestPort = function () {
    return this.destPort;
};

/**
 * Returns the source decorator of the connection
 * @returns {ConnectionDecorator}
 */
Connection.prototype.getSrcDecorator = function () {
    return this.srcDecorator;
};
/**
 * Returns the target decorator of the connection
 * @returns {ConnectionDecorator}
 */
Connection.prototype.getDestDecorator = function () {
    return this.destDecorator;
};
/**
 * Returns a list of the lines associated with this connection
 * @returns {ArrayList}
 */
Connection.prototype.getLineSegments = function () {
    return this.lineSegments;
};

/**
 * Sets the source decorator of the connection
 * @param {ConnectionDecorator} newDecorator
 * @chainable
 */
Connection.prototype.setSrcDecorator = function (newDecorator) {
    if (newDecorator.type === 'ConnectionDecorator') {
        this.srcDecorator = newDecorator;
    }
    return this;
};

/**
 * Sets the destination decorator of the connection
 * @param {ConnectionDecorator} newDecorator
 * @chainable
 */
Connection.prototype.setDestDecorator = function (newDecorator) {
    if (newDecorator.type === 'ConnectionDecorator') {
        this.destDecorator = newDecorator;
    }
    return this;
};

/**
 * Gets the zOrder of the connection
 * @return {number}
 */
Connection.prototype.getZOrder = function () {
    return Shape.prototype.getZOrder.call(this);
};

/**
 * Gets the oldPoints of the connection
 * @return {Array}
 */
Connection.prototype.getOldPoints = function () {
    return this.oldPoints;
};

/**
 * Gets the points of the connection
 * @return {Array}
 */
Connection.prototype.getPoints = function () {
    return this.points;
};

/**
 * @class BehavioralElement
 * Class that encapsulates the behavior of all elements that have container and
 * drop behaviors attached to them.
 * since this class inherits from {@link JCoreObject}, then the common behaviors
 * and properties for all elements in the designer are also part of this class
 * The purpose of this class is to encapsulate behaviors related to drop and
 * containment of elements, so it shouldn't be instantiated, we should
 * instantiate the elements that inherit from this class instead.
 *          //i.e
 *          //we will set the behaviors that are related only to this class
 *          var shape = new CustomShape({
 *          //we can set different types of containers here and the factory
 *          //will do all the work
 *              container : "regular",
 *              drop : {
 *              //type specifies the drop behavior we want, again we just need
 *              // to pass a string
 *               type : "container",
 *                //selectors are the css selectors that this element will
 *                //accept to be dropped
 *               selectors : [".firstselector",".secondselector"],
 *              //overwrite is an option to override previous and default
 *              //selectors
 *               overwrite : false
 *              }
 *          });
 *
 * @extends JCoreObject
 *
 * @constructor Creates a new instance of this class
 * @param {Object} options
 * @cfg {String} [container="nocontainer"] the type of container behavior
 * we want for an object, it can be regular,or nocontainer, or any other class
 * that extends the {@link ContainerBehavior} class, but also note that we would
 * need to override the factory for container behaviors located in this class.
 * @cfg {Object} [drop={
 *     drop : "nodrop",
 *     selectors : [],
 *     overwrite : false
 * }] Object that contains the options for the drop behavior we want an object
 * to have, we can, assign type which can be container, connection,
 * connectioncontainer, or no drop. As with the container behavior we can extend
 * the behaviors and factory for this functionality.
 * We also have selectors that specify the selectors the drop behavior will
 * accept and the overwrite feature
 */
BehavioralElement = function (options) {
    JCoreObject.call(this, options);
    /**
     * Determines the container Behavior that this object has
     * @property {ContainerBehavior}
     * TODO Initialize default behavior
     */
    this.containerBehavior = null;
    /**
     * Determines the drop behavior that this object has
     * @property {DropBehavior}
     * TODO Initialize default behavior
     */
    this.dropBehavior = null;
    /**
     * List of the children
     * @property {*}
     */
    this.children = null;

    BehavioralElement.prototype.initObject.call(this, options);
};

BehavioralElement.prototype = new JCoreObject();
/**
 * Type of the all instances of this class
 * @property {String}
 */
BehavioralElement.prototype.type = "BehavioralElement";
/**
 * Static variable that will hold the behavior for all objects that implement
 * the nodrop behavior
 * @property {NoDropBehavior}
 */
BehavioralElement.prototype.noDropBehavior = null;
/**
 * Static variable that will hold the behavior for all objects that implement
 * the container drop behavior
 * @property {ContainerDropBehavior}
 */
BehavioralElement.prototype.containerDropBehavior = null;
/**
 * Static variable that will hold the behavior for all objects that implement
 * the connection drop behavior
 * @property {ConnectionDropBehavior}
 */
BehavioralElement.prototype.connectionDropBehavior = null;
/**
 * Static variable that will hold the behavior for all objects that implement
 * the connectioncontainer drop behavior
 * @property {ConnectionContainerDropBehavior}
 */
BehavioralElement.prototype.connectionContainerDropBehavior = null;
/**
 * Static variable that will hold the behavior for all objects that implement
 * the nocontainer behavior
 * @property {NoContainerBehavior}
 */
BehavioralElement.prototype.noContainerBehavior = null;
/**
 * Static variable that will hold the behavior for all objects that implement
 * the regularcontainer behavior
 * @property {RegularContainerBehavior}
 */
BehavioralElement.prototype.regularContainerBehavior = null;

/**
 * Instance initializer which uses options to extend the default config options.
 * The default options are container: nocontainer, and drop: nodrop
 * @param {Object} options
 */
BehavioralElement.prototype.initObject = function (options) {
    var defaults = {
        drop : {
            type : "nodrop",
            selectors : [],
            overwrite : false
        },
        container : "nocontainer"
    };
    $.extend(true, defaults, options);
    this.setDropBehavior(defaults.drop.type, defaults.drop.selectors,
        defaults.drop.overwrite);
    this.setContainerBehavior(defaults.container);


    this.children = new ArrayList();
};
/**
 * Factory of drop behaviors. It uses lazy instantiation to create instances of
 * the different drop behaviors
 * @param {String} type Type of drop behavior we want to assign to an object,
 * it can be nodrop, container, connection or connectioncontainer
 * @param {Array} selectors Array containing the css selectors that the drop
 * behavior will accept
 * @return {DropBehavior}
 */
BehavioralElement.prototype.dropBehaviorFactory = function (type, selectors) {
    if (type === "nodrop") {
        if (!this.noDropBehavior) {
            this.noDropBehavior = new NoDropBehavior(selectors);
        }
        return this.noDropBehavior;
    }
    if (type === "container") {
        if (!this.containerDropBehavior) {
            this.containerDropBehavior = new ContainerDropBehavior(selectors);
        }
        return this.containerDropBehavior;
    }
    if (type === "connection") {
        if (!this.connectionDropBehavior) {
            this.connectionDropBehavior = new ConnectionDropBehavior(selectors);
        }
        return this.connectionDropBehavior;
    }
    if (type === "connectioncontainer") {
        if (!this.connectionContainerDropBehavior) {
            this.connectionContainerDropBehavior =
                new ConnectionContainerDropBehavior(selectors);
        }
        return this.connectionContainerDropBehavior;
    }
};

/**
 * Factory of container behaviors. It uses lazy instantiation to create
 * instances of the different container behaviors
 * @param {String} type An string that specifies the container behavior we want
 * an instance to have, it can be regular or nocontainer
 * @return {ContainerBehavior}
 */
BehavioralElement.prototype.containerBehaviorFactory = function (type) {
    if (type === "regular") {
        if (!this.regularContainerBehavior) {
            this.regularContainerBehavior = new RegularContainerBehavior();
        }
        return this.regularContainerBehavior;

    }
    if (!this.noContainerBehavior) {
        this.noContainerBehavior = new NoContainerBehavior();
    }
    return this.noContainerBehavior;
};
/**
 * Updates the children positions of a container given the x and y difference
 * @param {Number} diffX x difference
 * @param {Number} diffY y difference
 * @chainable
 * // TODO make this method recursive
 */
BehavioralElement.prototype.updateChildrenPosition = function (diffX, diffY) {
    var children = this.getChildren(),
        child,
        i,
        updatedChildren = [],
        previousValues = [],
        newValues = [];

    for (i = 0; i < children.getSize(); i += 1) {
        child = children.get(i);
//        child.oldX = child.x;
//        child.oldY = child.y;
//        child.oldAbsoluteX = child.absoluteX;
//        child.oldAbsoluteY = child.absoluteY;
        if ((diffX !== 0 || diffY !== 0) &&
                !this.canvas.currentSelection.contains(child)) {
            updatedChildren.push(child);
            previousValues.push({
                x : child.x,
                y : child.y
            });
            newValues.push({
                x : child.x + diffX,
                y : child.y + diffY
            });
        }
        child.setPosition(child.x + diffX, child.y + diffY);
    }
    if (updatedChildren.length > 0) {
        this.canvas.triggerPositionChangeEvent(updatedChildren, previousValues,
            newValues);
    }
    return this;
};

/**
 * Returns whether the instance is a container or not
 * @return {Boolean}
 */
BehavioralElement.prototype.isContainer = function () {
    return this.containerBehavior &&
            this.containerBehavior.type !== "NoContainerBehavior";
};
/**
 * Sets the container behavior of an object, using the same options as
 * the factory
 * @param {String} behavior the container behavior we want the factory to
 * assign, it can be regular, or nocontainer
 * @chainable
 */
BehavioralElement.prototype.setContainerBehavior = function (behavior) {
    // update the saved object
    // added by mauricio to save the container behavior of this
    $.extend(true, this.savedOptions, {container: behavior});
    this.containerBehavior = this.containerBehaviorFactory(behavior);
    return this;
};
/**
 * Encapsulates the functionality of adding an element this element according
 * to its container behavior
 * @param {Shape} shape Shape we want to add to the element
 * @param {Number} x x coordinate where the shape will be positionated relative
 * to this element
 * @param {Number} y y coordinate where the shape will be positionated relative
 * to this element
 * @param {Boolean} topLeftCorner determines if the drop position should be
 * calculated from the top left corner of the shape or, from its center
 * @chainable
 */
BehavioralElement.prototype.addElement = function (shape, x, y,
                                                topLeftCorner) {
    this.containerBehavior.addToContainer(this, shape, x, y, topLeftCorner);
    return this;
};
/**
 * Encapsulates the functionality of removing an element this element according
 * to its container behavior
 * @param {Shape} shape shape to be removed from this element
 * @chainable
 */
BehavioralElement.prototype.removeElement = function (shape) {
    this.containerBehavior.removeFromContainer(shape);
    return this;
};
/**
 * Swaps a shape from this container to a different one
 * @param {Shape} shape shape to be swapped
 * @param {BehavioralElement} otherContainer the other container the shape will
 * be swapped to
 * @param {Number} x x coordinate where the shape will be positionated relative
 * to this element
 * @param {Number} y y coordinate where the shape will be positionated relative
 * to this element
 * @param {Boolean} topLeftCorner determines if the drop position should be
 * calculated from the top left corner of the shape or, from its center
 * @chainable
 */
BehavioralElement.prototype.swapElementContainer = function (shape,
                                                             otherContainer, x,
                                                             y, topLeftCorner) {
    var newX = !x ? shape.getX() : x,
        newY = !y ? shape.getY() : y;
    shape.changedContainer = true;
    this.removeElement(shape);
    otherContainer.addElement(shape, newX, newY, topLeftCorner);
    return this;
};


/**
 * Returns the list of children belonging to this shape
 * @returns {ArrayList}
 */
BehavioralElement.prototype.getChildren = function () {
    return this.children;
};

/**
 * Updates the dimensions and position of this shape (note: <this> is a shape)
 * @param {Number} margin the margin for this element to consider towards the
 * shapes near its borders
 * @chainable
 */
BehavioralElement.prototype.updateDimensions = function (margin) {
    // update its size (if an child grew out of the shape)
    // only if it's not the canvas
    if (this.family !== 'Canvas') {
        this.updateSize(margin);
        this.refreshConnections();
        // updates JQueryUI's options (minWidth and minHeight)
        ResizeBehavior.prototype.updateResizeMinimums(this);

        BehavioralElement.prototype.updateDimensions.call(this.parent, margin);

    }
    return this;
};
/**
 * Sets the container behavior of an object, using the same options as
 * the factory
 * @param {String} behavior the drop behavior we want the factory to assign,
 * it can be container, nodrop, connection, or connectioncontainer
 * @param {Array} selectors Array containing the css selectors that will be
 * accepted on drop
 * @param {Boolean} overwrite Determines whether the default selectors will
 * be erased
 * @chainable
 */
BehavioralElement.prototype.setDropBehavior = function (behavior, selectors,
                                                        overwrite) {
    this.dropBehavior = this.dropBehaviorFactory(behavior, selectors);
    this.dropBehavior.setSelectors(selectors, overwrite);
    if (this.html && this.dropBehavior) {
        this.dropBehavior.attachDropBehavior(this);

        // update the saved object
        // added by mauricio to save the drop behavior of this shape
        $.extend(true, this.savedOptions.drop, {
            type: behavior,
            overwrite: overwrite
        });

        if (selectors && selectors.hasOwnProperty('length')) {
            this.dropBehavior.updateSelectors(this, selectors, overwrite);
            // update the saved object
            // added by mauricio to save the drop behavior of this shape
            $.extend(true, this.savedOptions.drop, {
                selectors: selectors
            });
        }
    }
    return this;
};
/**
 * Sets the selectors of the current drop behavior
 * @param {Array} selectors new css selectors for the drop behavior
 * @param {Boolean} overwrite determines whether the default selectors will
 * be erased
 * @chainable
 */
BehavioralElement.prototype.setDropAcceptedSelectors = function (selectors,
                                                               overwrite) {
    if (selectors && selectors.hasOwnProperty('length')) {
        this.dropBehavior.updateSelectors(this, selectors, overwrite);
    }
    return this;
};
/**
 * Attach the drop behavior to the element, if there is such
 * @chainable
 */
BehavioralElement.prototype.updateBehaviors = function () {
    if (this.dropBehavior) {
        this.dropBehavior.attachDropBehavior(this);
        this.dropBehavior.updateSelectors(this);
    }
    return this;
};

/**
 * Stringifies the container and drop behavior of this object
 * @return {Object}
 */
BehavioralElement.prototype.stringify = function () {
    var inheritedJSON = JCoreObject.prototype.stringify.call(this),
        thisJSON = {
            container: this.savedOptions.container,
            drop: this.savedOptions.drop
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 *
 * @class Layer
 * Class that contains the properties of a layer for a shape we need
 * to have a shape already instantiated and added to the canvas in order for
 * this class to be effective
 *
 *          //i.e.
 *           var layer = new Layer({
 *                  //Determine the layer's parent
 *                  parent: customShape,
 *                  layerName: "first layer",
 *                  //the order in which the layers will be added in increasing
 *                  //order
 *                  priority: 0,
 *                  //determines if the layer will be hidden or visible
 *                  visible: true,
 *                  //sprites to be applied on the layers according to a zoom
 *                  //scale
 *                  zoomSprites : ["class50, class75, class100, class125,
 *                      class 150"]
 *           });
 * @extend JCoreObject
 *
 * @constructor
 * Initializes a layer, the constructor must be called with all its parameter
 * for the object to be meaningful, its is important to denote that the css
 * class must follow this structure
 * any word_zoomScale_anythingYouWantHere
 * @param {Object} options
 * @cfg {Object} parent, Parent of a corresponding layer, a layer may not exist
 * without a parent
 * @cfg {String} [layerName="defaultLayerName"] A name we want to label a layer
 * with
 * @cfg {number} [priority=0] The orders in which the layers will be added in
 * increasing order
 * @cfg {boolean} [visible=true] Determines whether a layer wll be visible or
 * hidden
 * @cfg {Array} [zoomSprites=["","","","",""]] Sprites to be applied to the
 * layer according to a zoom scale
 */
Layer = function (options) {

// TODO: check elementClass and bpmnClass removal impact on the layers
//Layer = function (parent, name, elementClass, priority, bpmnClass, visible) {

    JCoreObject.call(this, options);

    /**
     * The name of the layer
     * @property {String}
     */
    this.layerName = null;

    /**
     * The priority of the layer, determines which layer should be on top
     * @property {number}
     */
    this.priority = null;

    /**
     * The bpmnShape that this layer belongs too.
     * Extremely important since some data will be strictly drawn by its parent
     * @property {Object}
     */
    this.parent = null;

    /**
     * Determines when a layer is visible or not
     * @property boolean
     */
    this.visible = null;
    /**
     * The current Sprite applied in the zoom scale
     * @property {String}
     */
    this.currentZoomClass = "";
    /**
     * Sprites for the layer in each zoom scale
     * @property {Array}
     */
    this.zoomSprites = [];

    Layer.prototype.initObject.call(this, options);
};

Layer.prototype = new JCoreObject();

/**
 * Type of an instance of this class
 * @property {String}
 */
Layer.prototype.type = "Layer";

/**
 * Object init method (internal)
 * @param {Object} options
 */
Layer.prototype.initObject = function (options) {
    /**
     * Default options for the object
     * @property {Object}
     */
    var defaults = {
        x: 0,
        y: 0,
        parent: null,
        layerName: "defaultLayerName",
        priority: 0,
        visible: true,
        zoomSprites : ["", "", "", "", ""]
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // call setters using the defaults object
    this.setParent(defaults.parent)
        .setPosition(defaults.x, defaults.y)
        .setLayerName(defaults.layerName)
        .setPriority(defaults.priority)
        .setVisible(defaults.visible)
        .setZoomSprites(defaults.zoomSprites)
        .setProperties();

};
/**
 * Updates the properties in order to change zoom scales
 */
Layer.prototype.applyZoom = function () {
    this.setProperties();
};
/**
 * Comparison function for ordering layers according to priority
 * @param {Layer} layer1
 * @param {Layer} layer2
 * @returns {boolean}
 */
Layer.prototype.comparisonFunction = function (layer1, layer2) {
    return layer1.priority > layer2.priority;
};
/**
 * Creates the HTML representation of the layer
 * @returns {HTMLElement}
 */
Layer.prototype.createHTML = function (modifying) {
    this.setProperties();
    JCoreObject.prototype.createHTML.call(this, modifying);
    return this.html;
};
/**
 * Paints the corresponding layer, in this case adds the
 * corresponding css classes
 * @chainable
 */
Layer.prototype.paint = function () {

    var $layer = $(this.html),
        newSprite;
    this.style.removeClasses([this.currentZoomClass]);
    newSprite = this.zoomSprites[this.canvas.zoomPropertiesIndex];
    this.style.addClasses([newSprite]);
    this.currentZoomClass = newSprite;
    this.style.applyStyle();
    /*
    //The current position where the properties for the current zoom factor
    // are located
    var propertiesPosition;

    if (!this.html) {
        return this;
    }
    propertiesPosition = (this.canvas) ? this.canvas.getPropertyPosition() : 2;

    //determine the css classes that will be used
    this.bpmnClass = this.elementProperties[propertiesPosition].bpmnClass;
    this.elementClass = this.elementProperties[propertiesPosition].elementClass;

    //apply classes according to visibility
    if (this.visible) {
        this.html.className = this.bpmnClass + " " + this.elementClass;
    } else {
        this.html.className = "";
    }
    return this;*/
    return this;
};

/**
 * This method will set the parent necessary properties for the layer to work
 * @chainable
 */
Layer.prototype.setProperties = function () {

    if (!this.parent) {
        return this;
    }
    //generates an id for the layer
    this.id = this.parent.getID() + "Layer-" + this.layerName;
    //this.width =  this.parent.getWidth();
    //this.height = this.parent.getHeight();
    this.setDimension(this.parent.getWidth(), this.parent.getHeight());
    // DO NOT ASSUME THAT THE POSITION OF THE LAYER IS 0,0 BECAUSE OF THE
    // BORDERS IT MAY HAVE
//    this.setPosition(0, 0);
    this.canvas = this.parent.canvas;

    return this;
};
/**
 * Returns the layer name
 * @returns {String}
 */
Layer.prototype.getLayerName = function () {
    return this.layerName;
};

/**
 * Returns the priority of the layer
 * @returns {number}
 */
Layer.prototype.getPriority = function () {
    return this.priority;
};
///**
// * Returns if the layer is visible or not
// * @returns {boolean}
// */
//Layer.prototype.getVisible = function () {
//    return this.visible;
//};

/**
 * Sets the layer name
 * @param {String} newLayerName
 * @chainable
 */
Layer.prototype.setLayerName = function (newLayerName) {
    if (typeof newLayerName === "string" && newLayerName !== "") {
        this.layerName = newLayerName;
    }
    return this;
};

/**
 * Sets the priority of the layer
 * @param {number} newPriority
 * @chainable
 */
Layer.prototype.setPriority = function (newPriority) {
    if (typeof newPriority === "number") {
        this.priority = newPriority;
    }
    return this;
};

/**
 * Sets the parent of this layer
 * @param {CustomShape} newParent
 * @chainable
 */
Layer.prototype.setParent = function (newParent) {
    if (newParent) {
        this.parent = newParent;
    }
    return this;
};

/**
 * Gets the parent of this layer
 * @return {Shape}
 */
Layer.prototype.getParent = function () {
    return this.parent;
};

/**
 * Sets the css classes for the zoom scales
 * @param {Array} zoomSprites
 * @chainable
 */
Layer.prototype.setZoomSprites = function (zoomSprites) {
    var i;
    this.zoomSprites = ["", "", "", "", ""];
    for (i = 0; i < zoomSprites.length; i += 1) {
        this.zoomSprites[i] = zoomSprites[i];
    }
    return this;
};
/**
 * Serializes this object
 * @return {Object}
 */
Layer.prototype.stringify = function () {
    /**
     * inheritedJSON = {
     *     id: #
     *     x: #,
     *     y: #,
     *     width: #,
     *     height: #
     * }
     * @property {Object}
     */
    var inheritedJSON = {},
        thisJSON = {
            id: this.getID(),
            x: this.getX(),
            y: this.getY(),
            layerName: this.getLayerName(),
            priority: this.getPriority(),
            style: {
                cssClasses: this.style.getClasses()
            },
            zoomSprites : this.zoomSprites
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * @abstract
 * @class Shape
 * Represents a shape in the jCore framework, shapes can be:
 *
 * - **Regular shapes** (Ovals, rectangles, polygons)
 * - **Custom shapes** (these kind of shapes can have sprites)
 *
 * A shape has the following characteristics:
 *
 * - It has a dragBehavior (inherited from {@link JCoreObject})
 * - It has a dropBehavior (inherited from {@link BehavioralElement})
 * - It has a containerBehavior (inherited from {@link BehavioralElement})
 * - It has a resizeBehavior (instantiated in this class)
 *
 * This class cannot be instantiated.
 *
 * @extend BehavioralElement
 * @constructor Creates an instance of the class ConnectionDecorator
 * @param {Object} options Initialization options
 * @cfg {boolean} [topLeft=false] If set to true then when this shape is dragged from the toolbar it'll be created
 * and placed in its topLeft coordinate otherwise it'll use the center as its topLeft coordinate
 * @cfg {string} [resizeBehavior="no"] Default resize behavior used to create the correct instance in the factory
 * @cfg {Object} [resizeHandlers={
 *      type: "None",
 *      total: 4,
 *          resizableStyle: {
 *              cssProperties: {
 *                  'background-color': "rgb(0, 255, 0)",
 *                  'border': '1px solid black'
 *              }
 *          },
 *          nonResizableStyle: {
 *              cssProperties: {
 *                  'background-color': "white",
 *                  'border': '1px solid black'
 *              }
 *          }
 *      }] Default styles to create the instances of the class Style
 * @cfg {string} [drag="disabled"] Default drag behavior used to create the correct instance in the factory
 */
Shape = function (options) {
    /**
     * Array built when setting the dimension of the shape to store the
     * x coordinate of the div corners in clockwise order starting at top left
     * @property {Array}
     */
    this.xCorners = [0, 0, 0, 0];
    /**
     * Array built when setting the dimension of the shape to store the
     * y coordinate of the div corners in clockwise order starting at top left
     * @property {Array}
     */
    this.yCorners = [0, 0, 0, 0];
    /**
     * Array built when setting the dimension of the shape to store the
     * x coordinate of the midpoints of each div border in clockwise order
     * starting at the top border
     * @property {Array}
     */
    this.xMidPoints = [0, 0, 0, 0];
    /**
     * Array built when setting the dimension of the shape to store the
     * y coordinate of the midpoints of each div border in clockwise order
     * starting at the top border
     * @property {Array}
     */
    this.yMidPoints = [0, 0, 0, 0];
    /**
     * List containing the resize Points located in the corner of a div
     * @property {ArrayList}
     */
    this.cornerResizeHandlers = new ArrayList();
    /**
     * List containing the resize Points located in the middle of a border
     * @property {ArrayList}
     */
    this.midResizeHandlers = new ArrayList();

    BehavioralElement.call(this, options);

    /**
     * Center point of the shape (in the case of a polygon).
     * @property {Point}
     */
    this.center = null;
    /**
     * The parent of this shape.
     * @property {Shape}
     */
    this.parent = null;
    /**
     * Old parent of this shape (useful to check the previous
     * container of this shape).
     * @property {Shape}
     */
    this.oldParent = null;
    /**
     * Default zOrder of the shape.
     * @property {number} [defaultZOrder=1]
     */
    this.defaultZOrder = 1;
    /**
     * Denotes whether this shape is being dragged.
     * @property {boolean} [dragging=false]
     */
    this.dragging = false;
    /**
     * Denotes whether this shape was dragged.
     * @property {boolean} [wasDragged=false]
     */
    this.wasDragged = false;
    /**
     * Denotes whether this shape was entered by a draggable element.
     * @property {boolean} [entered=false]
     */
    this.entered = false;
    /**
     * Determines the resizeBehavior that this object has.
     * @property {ResizeBehavior}
     */
    this.resizeBehavior = null;
    /**
     * Determines whether the shape is being resized or not.
     * @property {boolean} [resizing=false]
     */
    this.resizing = false;
    /**
     * This shape was repainted.
     * @property {boolean}
     */
    this.repainted = false;
    /**
     * Determines whether a shape has fixed Dimensions or not
     * @property boolean
     */
    this.fixed  = true;
    /**
     * Determines if the shape's been dropped to a different container
     * @property {boolean}
     */
    this.changedContainer = false;
    /**
     * Determines whether this shape will be created considering its top-left
     * coordinates or its center
     * @property {boolean}
     */
    this.topLeftOnCreation = false;

    // set defaults
    Shape.prototype.initObject.call(this, options);
};

// inherits from JCoreObject
Shape.prototype = new BehavioralElement();

/**
 * Type of each instance of this class
 * @property {String}
 */
Shape.prototype.type = "Shape";

/**
 * Family of each instance of this class
 * @property {String}
 */
Shape.prototype.family = "Shape";

/**
 * Instance of RegularDragBehavior (avoiding the creation of multiple same instances)
 * @property {DragBehavior} [noDragBehavior=null]
 */
Shape.prototype.noDragBehavior = null;

/**
 * Instance of RegularDragBehavior (avoiding the creation of multiple same instances)
 * @property {DragBehavior} [regularDragBehavior=null]
 */
Shape.prototype.regularDragBehavior = null;

/**
 * Instance of ConnectionDragBehavior (avoiding the creation of multiple same instances)
 * @property {ConnectionDragBehavior} [connectionDragBehavior=null]
 */
Shape.prototype.connectionDragBehavior = null;

/**
 * Instance of CustomShapeDragBehavior (avoiding the creation of multiple same instances)
 * @property {CustomShapeDragBehavior} [customShapeDragBehavior=null]
 */
Shape.prototype.customShapeDragBehavior = null;

/**
 * Corner resize identifiers (for jQueryUI Resizable handles)
 * @property {Array} [cornersIdentifiers=['nw', 'ne', 'se', 'sw']]
 */
Shape.prototype.cornersIdentifiers = ['nw', 'ne', 'se', 'sw'];

/**
 * Mid resize identifiers (for jQueryUI Resizable handles)
 * @property {Array} [midPointIdentifiers=['n', 'e', 's', 'w']]
 */
Shape.prototype.midPointIdentifiers = ['n', 'e', 's', 'w'];

/**
 * Constant for the maximum z-index
 * @property {number} [MAX_ZINDEX=100]
 */
Shape.prototype.MAX_ZINDEX = 100;

/**
 * Constant for the default radius used in the class Arc
 * @property {number} [DEFAULT_RADIUS=6]
 */
Shape.prototype.DEFAULT_RADIUS = 6;

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains old points and new points
 * @private
 */
Shape.prototype.initObject = function (options) {
    var defaults = {
        topLeft : false,
        resizeBehavior: "no",
        resizeHandlers: {
            type: "None",
            total: 4,
            resizableStyle: {
                cssProperties: {
                    'background-color': "rgb(0, 255, 0)",
                    'border': '1px solid black'
                }
            },
            nonResizableStyle: {
                cssProperties: {
                    'background-color': "white",
                    'border': '1px solid black'
                }
            }
        },
        drag : "disabled"
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    this.resizeBehavior = this.resizeBehaviorFactory(defaults.resizeBehavior);
//    this.midResizeHandlers = new ArrayList();
//    this.cornerResizeHandlers = new ArrayList();
    if (defaults.drag !== "disabled") {
        this.setDragBehavior(defaults.drag);
    }
    this.createHandlers(defaults.resizeHandlers.type,
                defaults.resizeHandlers.total,
                defaults.resizeHandlers.resizableStyle,
                defaults.resizeHandlers.nonResizableStyle);
    this.topLeftOnCreation = defaults.topLeft;
};

/**
 * Creates handlers according to the `number` of handlers, the `type` of handlers (currently only Rectangle
 * is supported), the `resizableStyle` (created in `this.initObject`) and the `nonResizableStyle`
 * (created in `this.initObject`).
 * @param {string} type
 * @param {number} number
 * @param {Object} resizableStyle
 * @param {Object} nonResizableStyle
 * @chainable
 */
Shape.prototype.createHandlers = function (type, number, resizableStyle,
                                           nonResizableStyle) {
    if (type === "Rectangle") {

        var i;

        //First determine how many ResizeHandlers we are to create
        if (!number || (number !== 8 &&
            number !== 4 && number !== 0)) {
            number = 4;
        }
        //Then insert the corners first
        for (i = 0; i < number && i < 4; i += 1) {
            this.cornerResizeHandlers.insert(
                new ResizeHandler({
                    parent: this,
                    zOrder: Style.MAX_ZINDEX + 3,
                    representation: new Rectangle(),
                    orientation: this.cornersIdentifiers[i],
                    resizableStyle: resizableStyle,
                    nonResizableStyle: nonResizableStyle
                })
            );
        }
        //subtract 4 just added resize points to the total
        number -= 4;
        //add the rest to the mid list
        for (i = 0; i < number; i += 1) {
            this.midResizeHandlers.insert(
                new ResizeHandler({
                    parent: this,
                    zOrder: Style.MAX_ZINDEX + 3,
                    representation: new Rectangle(),
                    orientation: this.midPointIdentifiers[i],
                    resizableStyle: resizableStyle,
                    nonResizableStyle: nonResizableStyle
                })
            );
        }
    }
    return this;
    //console.log(this.cornerResizeHandlers.asArray());
    //console.log(this.midResizeHandlers.asArray());
};

/**
 * Updates the position of the handlers using `this.cornerResizeHandlers` and `this.midResizeHandlers`.
 * NOTE: There's a prerequisite to call this method, `this.setDimensions` must be called first
 * because it updated the arrays used by this method.
 * @chainable
 */
Shape.prototype.updateHandlers = function () {
    var handler,
        i;
    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        handler = this.cornerResizeHandlers.get(i);
        handler.setPosition(this.xCorners[i] -
            Math.round(handler.width / 2) - 1,
            this.yCorners[i] - Math.round(handler.height / 2) - 1);
    }
    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        handler = this.midResizeHandlers.get(i);
        handler.setPosition(this.xMidPoints[i] -
            Math.round(handler.width / 2) - 1,
            this.yMidPoints[i] - Math.round(handler.height / 2) - 1);
    }
    return this;
};

/**
 * Sets the visibility of the resize handlers
 * @param {boolean} visible
 * @chainable
 */
Shape.prototype.showOrHideResizeHandlers = function (visible) {

    var i;
    if (!visible) {
        visible = false;
    }
    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        this.cornerResizeHandlers.get(i).setVisible(visible);
    }

    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        this.midResizeHandlers.get(i).setVisible(visible);
    }
    return this;
};

/**
 * Applies a predefined style to its handlers (which can be resizable style or non resizable style)
 * @param {string} styleType
 * @chainable
 */
Shape.prototype.applyStyleToHandlers = function (styleType) {
    var i;
    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        this.cornerResizeHandlers.get(i)[styleType].applyStyle();
    }

    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        this.midResizeHandlers.get(i)[styleType].applyStyle();
    }
    return this;
};

/**
 * Attaches events to this shape (currently mousedown, mouseup and click events).
 *
 * This method also instantiates the behaviors defined in the configuration options of the object,
 * the behaviors instantiated are:
 *
 * - drag behavior
 * - drop behavior
 * - resize behavior
 *
 * @chainable
 */
Shape.prototype.attachListeners = function () {
    var $shape = $(this.html);
    $shape.on("mousedown", this.onMouseDown(this));
    $shape.on("mouseup", this.onMouseUp(this));
    $shape.on("click", this.onClick(this));
    this.updateBehaviors();
    return this;
};

/**
 * @event mousedown
 * Moused down callback fired when the user mouse downs on the `shape`
 * @param shape
 */
Shape.prototype.onMouseDown = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event mouseup
 * Moused up callback fired when the user mouse ups on the `shape`
 * @param shape
 */
Shape.prototype.onMouseUp = function (shape) {
    return function (e, ui) {
    };
};

/**
 * @event click
 * Click callback fired when the user clicks on the `shape`
 * @param shape
 */
Shape.prototype.onClick = function (shape) {
    return function (e, ui) {
    };
};

/**
 * Creates the HTML representation of the shape, besides calling the method `createHTML` of
 * the method of its parent, it also adds the resize handlers to the DOM.
 * @returns {HTMLElement}
 */
Shape.prototype.createHTML = function () {
    var i;

    // call the prototype's createHTML
    BehavioralElement.prototype.createHTML.call(this);

    // add the handlers
    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        this.addResizeHandler(this.cornerResizeHandlers.get(i),
            this.xCorners[i], this.yCorners[i]);
    }
    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        this.addResizeHandler(this.midResizeHandlers.get(i),
            this.xMidPoints[i], this.yMidPoints[i]);
    }
    return this.html;
};

/**
 * Creates an instance of one inherited class of dragBehavior according to the `type` (the instantiation
 * occurs only once per type).
 *
 * Here's the relation between `type` and the new instances created:
 *
 * - regular => {@link RegularDragBehavior}
 * - connection => {@link ConnectionDragBehavior}
 * - customshapedrag => {@link CustomShapeDragBehavior}
 * - any other string (including 'nodrag') => {@link NoDragBehavior}
 *
 * @param {string} type
 * @return {DragBehavior}
 */
Shape.prototype.dragBehaviorFactory = function (type) {
    if (type === "regular") {
        if (!this.regularDragBehavior) {
            this.regularDragBehavior = new RegularDragBehavior();
        }
        return this.regularDragBehavior;
    }
    if (type === "connection") {
        if (!this.connectionDragBehavior) {
            this.connectionDragBehavior = new ConnectionDragBehavior();
        }
        return this.connectionDragBehavior;
    }
    if (type === "customshapedrag") {
        if (!this.customShapeDragBehavior) {
            this.customShapeDragBehavior = new CustomShapeDragBehavior();
        }
        return this.customShapeDragBehavior;
    }
    if (!this.noDragBehavior) {
        this.noDragBehavior = new NoDragBehavior();
    }
    return this.noDragBehavior;
};

/**
 * Returns true if this object is draggable
 * @return {boolean}
 */
Shape.prototype.isDraggable = function () {
    return this.dragBehavior &&
        this.dragBehavior.type !== "NoDragBehavior";
};

/**
 * Sets the determined drag behavior to `this` by calling `this.dragBehaviorFactory` (which creates or returns
 * the instance according to `behavior`) and attaches the drag events to `this`.
 * @param {String} behavior
 * @chainable
 */
Shape.prototype.setDragBehavior = function (behavior) {
    this.dragBehavior = this.dragBehaviorFactory(behavior);
    if (this.html && this.dragBehavior) {
        // can't extend this.savedOptions with this behavior because it changes
        // dynamically to connect or nodrag
        this.dragBehavior.attachDragBehavior(this);
    }
    return this;
};

/**
 * Updates the behaviors of this shape (this method is called from `this.attachListeners`).
 * This is the method that actually initializes jQueryUI's plugins (during the creation of the
 * instance of this shapes, the shape's behaviors are initialized but the init that they do
 * initialize jQuery's UI plugins is done through `[behavior].init`).
 * @chainable
 */
Shape.prototype.updateBehaviors = function () {
    BehavioralElement.prototype.updateBehaviors.call(this);
    if (this.dragBehavior) {
        this.dragBehavior.attachDragBehavior(this);
    }
    if (this.resizeBehavior) {
        this.resizeBehavior.init(this);
    }
    return this;
};

/**
 * Adds a `resizeHandler` to the shape at `[x, y]`
 * @param {ResizeHandler} resizeHandler
 * @param {number} x
 * @param {number} y
 * @chainable
 */
Shape.prototype.addResizeHandler = function (resizeHandler, x, y) {
    if (!this.html) {
        return;
    }
    //console.log(resizeHandler.getHTML());
    this.html.appendChild(resizeHandler.getHTML());

    resizeHandler.setPosition(x - Math.round(resizeHandler.width / 2) - 1,
        y - Math.round(resizeHandler.height / 2) - 1);
    resizeHandler.setCategory("resizable");
    return this;
};


/**
 * Paints the shape performing the following actions:
 *
 * - Paints its resize handlers
 * - Applies the predefined style according to the resize behavior it has
 *
 * @chainable
 */
Shape.prototype.paint = function () {
    var i,
        styleToApply;

//    // apply predefined style
//    this.style.applyStyle();

    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        this.cornerResizeHandlers.get(i).paint();
    }
    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        this.midResizeHandlers.get(i).paint();
    }

    // apply style to the handlers
    if (this.resizeBehavior) {
        styleToApply = this.resizeBehavior.type === "NoResizeBehavior" ?
                "nonResizableStyle" : "resizableStyle";
        this.applyStyleToHandlers(styleToApply);
    }

    return this;
};

Shape.prototype.updateHTML = function () {
    return this;
};

/**
 * Detaches `this` HTML from the DOM (also removing it from `canvas.customShapes` or `canvas.regularShapes`)
 * @chainable
 */
Shape.prototype.saveAndDestroy = function () {
    // save the html but detach it from the DOM
    this.html = $(this.html).detach()[0];
    this.canvas.removeFromList(this);
    return this;
};

/**
 * Updates the dimensions of this shape according to the dimensions and
 * positions of its children
 * @param {number} newMargin Padding to be added when a children is near the edge
 * @chainable
 */
Shape.prototype.updateSize = function (newMargin) {
    var children = this.children,
        limits = children.getDimensionLimit(),
        left = limits[3],
        top = limits[0],
        right = limits[1],
        bottom = limits[2],
        newLeft = this.getX(),
        newTop = this.getY(),
        newWidth = this.getWidth(),
        newHeight = this.getHeight(),
        margin,
        diffX = 0,
        diffY = 0,
        positionShift = false,
        dimensionIncrement = false;

    if (newMargin !== "undefined") {
        margin = newMargin;
    } else {
        margin = 15;
    }

    if (left < 0) {
        diffX = margin - left;
        positionShift = true;
        this.oldX = this.x;
        this.oldAbsoluteX = this.x;
        this.oldY = this.y;
        this.oldAbsoluteY = this.absoluteY;
    }

    if (top < 0) {
        diffY = margin - top;
        positionShift = true;
        this.oldX = this.x;
        this.oldAbsoluteX = this.x;
        this.oldY = this.y;
        this.oldAbsoluteY = this.absoluteY;
    }

    newLeft -= diffX;
    newTop -=  diffY;
    newWidth += diffX;
    newHeight += diffY;

    if (right > this.width) {
        newWidth += right - this.width + margin;
        dimensionIncrement = true;
        this.oldWidth = this.width;
    }
    if (bottom > this.height) {
        newHeight += bottom - this.height + margin;
        dimensionIncrement = true;
        this.oldHeight = this.height;
    }

    // move the shape to the new coordinates
    this.setPosition(newLeft, newTop);

    // TODO: CHECK WHERE THIS FUNCTION MUST GO
    // update the positions of its ports
    //this.updatePortsPosition(newWidth - this.width, newHeight - this.height);

    // update the shape's dimension
    this.setDimension(newWidth, newHeight);

    // custom triggers
    if (positionShift) {
        this.changePosition(this.oldX, this.oldY,
            this.absoluteX, this.absoluteY);
    }
    if (dimensionIncrement) {
        this.changeSize(this.oldWidth, this.oldHeight);
    }

    // move the children
    this.updateChildrenPosition(diffX, diffY);

    return this;
};

/**
 * Applies the actual zoom scale to the corresponding shape
 * @chainable
 */
Shape.prototype.applyZoom = function () {
//    var zoomFactor = this.canvas.getZoomFactor(),
//        zoomIndex = this.canvas.getZoomPropertiesIndex();

    this.refreshShape();
    return this;
};

/**
 * Sets the dimension of this shape, it also updates the arrays `this.xCorners, this.yCorners, this.xMidPoints
 * and this.yMidPoints`
 * @param {number} width
 * @param {number} height
 * @chainable
 */
Shape.prototype.setDimension = function (width, height) {
    BehavioralElement.prototype.setDimension.call(this, width, height);
    if (this.xCorners) {
        this.xCorners = [0, Math.round(this.zoomWidth), Math.round(this.zoomWidth), 0];
        this.yCorners = [0, 0, Math.round(this.zoomHeight), Math.round(this.zoomHeight)];
        this.xMidPoints = [Math.round(this.zoomWidth / 2), Math.round(this.zoomWidth),
            Math.round(this.zoomWidth / 2), 0];
        this.yMidPoints = [0, Math.round(this.zoomHeight / 2), Math.round(this.zoomHeight),
            Math.round(this.zoomHeight / 2)];
        this.updateHandlers();
    }
    return this;
};

/**
 * Sets some variables that store what changed during the process of changing the parent and also
 * triggers `changeElement` using those variables.
 *
 * The variables saved in {@link Canvas#updatedElement} are:
 *
 * - x (old x and new x)
 * - y (old y and new y)
 * - absoluteX (old absoluteX and new absoluteX)
 * - absoluteY (old absoluteY and new absoluteY)
 * - parent (old parent and new parent)
 *
 * @param {number} oldX
 * @param {number} oldY
 * @param {number} oldAbsoluteX
 * @param {number} oldAbsoluteY
 * @param {Object} oldParent
 * @param {Canvas} canvas
 * @chainable
 */
Shape.prototype.changeParent = function (oldX, oldY,
                                         oldAbsoluteX, oldAbsoluteY,
                                         oldParent, canvas) {
    var fields = [
        {
            "field" : "x",
            "oldVal" : oldX,
            "newVal" : this.x
        },
        {
            "field" : "y",
            "oldVal" : oldY,
            "newVal" : this.y
        },
        {
            "field" : "absoluteX",
            "oldVal" : oldAbsoluteX,
            "newVal" : this.absoluteX
        },
        {
            "field" : "absoluteY",
            "oldVal" : oldAbsoluteY,
            "newVal" : this.absoluteY
        },
        {
            "field" : "parent",
            "oldVal" : oldParent,
            "newVal" : this.parent
        }
    ];
    canvas.updatedElement = {
        "id" : this.id,
        "type" : this.type,
        "fields" : fields,
        "relatedObject" : this
    };
    $(canvas.html).trigger("changeelement");
    return this;
};

/**
 * Sets some variables that store what changed during the process of resizing and also
 * triggers `changeElement` using those variables.
 *
 * The variables saved in {@link Canvas#updatedElement} are:
 *
 * - width (old width and new width)
 * - height (old height and new height)
 *
 * @param {number} oldWidth
 * @param {number} oldHeight
 * @chainable
 */
Shape.prototype.changeSize = function (oldWidth, oldHeight) {
    var canvas = this.canvas,
        fields = [
            {
                "field" : "width",
                "oldVal" : oldWidth,
                "newVal" : this.width
            },
            {
                "field" : "height",
                "oldVal" : oldHeight,
                "newVal" : this.height
            }
        ];
    canvas.updatedElement = {
        "id" : this.id,
        "type" : this.type,
        "fields" : fields,
        "relatedObject" : this
    };
    $(canvas.html).trigger("changeelement");
    return this;
};

/**
 * Sets some variables that store what changed during the process of changing its position and also
 * triggers `changeElement` using those variables.
 *
 * The variables saved in {@link Canvas#updatedElement} are:
 *
 * - x (old x and new x)
 * - y (old y and new y)
 * - absoluteX (old absoluteX and new absoluteX)
 * - absoluteY (old absoluteY and new absoluteY)
 *
 * @param {number} oldX
 * @param {number} oldY
 * @param {number} oldAbsoluteX
 * @param {number} oldAbsoluteY
 * @chainable
 */
Shape.prototype.changePosition = function (oldX, oldY, oldAbsoluteX,
                                           oldAbsoluteY) {
    //TODO REVIEW WITH ZOOM OPTIONS
    var canvas = this.canvas,
        fields = [
            {
                "field" : "x",
                "oldVal" : oldX,
                "newVal" : this.x
            },
            {
                "field" : "y",
                "oldVal" : oldY,
                "newVal" : this.y
            }
//            {
//                "field" : "absoluteX",
//                "oldVal" : oldAbsoluteX,
//                "newVal" : this.absoluteX
//            },
//            {
//                "field" : "absoluteY",
//                "oldVal" : oldAbsoluteY,
//                "newVal" : this.absoluteY
//            }

        ];
    canvas.updatedElement = [{
        "id" : this.id,
        "type" : this.type,
        "fields" : fields,
        "relatedObject" : this
    }];
    $(canvas.html).trigger("changeelement");
    return this;
};

/**
 * Sets whether the dimensions are fixed or not
 * @param {boolean} fixed
 * @chainable
 */
Shape.prototype.setFixed = function (fixed) {
    if (typeof fixed === "boolean") {
        this.fixed = fixed;
    }
    return this;
};

/**
 * Adds `value` to the z-index of the shape (considering the z-index of its parent), since a shape might have
 * children, this method must increase the z-index of each child recursively.
 * @param {Shape} shape
 * @param {number} value
 * @chainable
 */
Shape.prototype.fixZIndex = function (shape, value) {

    var i,
        anotherShape,
        port,
        srcShape,
        destShape,
        srcShapeZIndex,
        destShapeZIndex,
        parentZIndex;

    parentZIndex = shape.parent.html.style.zIndex;
    shape.setZOrder(
        parseInt(parentZIndex, 10) + value + parseInt(shape.defaultZOrder, 10)
    );

    // fix children zIndex
    for (i = 0; i < shape.children.getSize(); i += 1) {
        anotherShape = shape.children.get(i);
        anotherShape.fixZIndex(anotherShape, 0);
    }

    // fix connection zIndex
    // only if it has ports
    if (shape.ports) {
        for (i = 0; i < shape.ports.getSize(); i += 1) {
            port = shape.ports.get(i);
            srcShape = port.connection.srcPort.parent;
            destShape = port.connection.destPort.parent;
            srcShapeZIndex = parseInt(srcShape.html.style.zIndex, 10);
            destShapeZIndex = parseInt(destShape.html.style.zIndex, 10);
            port.connection.style.addProperties({
                zIndex: Math.max(srcShapeZIndex + 1, destShapeZIndex + 1)
            });
        }
    }
    return this;
};

/**
 * Increases the zIndex of this shape by Style.MAX_ZINDEX
 * @chainable
 */
Shape.prototype.increaseZIndex = function () {
    this.fixZIndex(this, Style.MAX_ZINDEX);
    return this;
};

/**
 * Decreases the zIndex of this shape back to normal
 * @chainable
 */
Shape.prototype.decreaseZIndex = function () {
    this.fixZIndex(this, 0);
    return this;
};

/**
 * Increases the z-index of `shapes`'s ancestors by one
 * @param shape
 * @chainable
 */
Shape.prototype.increaseParentZIndex = function (shape) {
    if (shape.family !== "Canvas") {
        shape.style.addProperties({
            zIndex: parseInt(shape.html.style.zIndex, 10) + 1
        });
        shape.increaseParentZIndex(shape.parent);
    }
    return this;
};

/**
 * Decreases the zIndex of `shapes`'s ancestors by one by one
 * @param shape
 * @chainable
 */
Shape.prototype.decreaseParentZIndex = function (shape) {
    if (shape && shape.family !== "Canvas") {
        shape.style.addProperties({
            zIndex: parseInt(shape.html.style.zIndex, 10) - 1
        });
        shape.decreaseParentZIndex(shape.parent);
    }
    return this;
};

/**
 * Creates an resizeBehavior instance according to the type
 * @param {string} type
 * @return {ResizeBehavior}
 * @throws {Error} Throws an error if the parameter is not valid
 */
Shape.prototype.resizeBehaviorFactory = function (type) {
    if (type === "NoResize" || type === "no") {
        return new NoResizeBehavior();
    }
    if (type === "Resize" || type === "yes") {
        return new RegularResizeBehavior();
    }
    throw new Error("resizeBehaviorFactory(): parameter is not valid");
};

/**
 * Sets the determined resize behavior to `this` by calling `this.resizeBehaviorFactory` (which creates or returns
 * the instance according to `behavior`) and attaches the drag events to `this`.
 * @param {String} behavior
 * @chainable
 */
Shape.prototype.setResizeBehavior = function (behavior) {
    if (this.html && behavior) {
        this.resizeBehavior = this.resizeBehaviorFactory(behavior);
        this.resizeBehavior.init(this);
    }
    return this;
};

/**
 * Returns whether the shape is resizable or not
 * @return {boolean}
 */
Shape.prototype.isResizable = function () {
    return this.resizeBehavior &&
        this.resizeBehavior.type !== "NoResizeBehavior";
};

/**
 * Updates the position and dimensions of the shape (useful when the parent of this shape
 * has changed positions or dimensions).
 * @chainable
 */
Shape.prototype.refreshShape = function () {
    this.setPosition(this.x, this.y)
        .setDimension(this.width, this.height);
    return this;
};

/**
 * Abstract method intended to refresh the connections of a shapes
 * @abstract
 * @chainable
 */
Shape.prototype.refreshConnections = function () {
    return this;
};

/**
 * Updates the positions of the children of this shape recursively
 * @param {boolean} onCommand
 * @chainable
 */
Shape.prototype.refreshChildrenPositions = function (onCommand) {
    var i,
        children = this.children,
        child,
        relatedShapes = [],
        coordinates = [];
    for (i = 0; i < children.getSize(); i += 1) {
        child = children.get(i);
        child.setPosition(child.getX(), child.getY());
        if (onCommand) {
            child.refreshConnections(false);
        }
        relatedShapes.push(child);
        coordinates.push({
            x : child.getX(),
            y:  child.getY()
        });
        child.refreshChildrenPositions(onCommand);
    }
    this.canvas.triggerPositionChangeEvent(relatedShapes, coordinates,
        coordinates);
    return this;
};

/**
 * Fix connections ports on resize (a container must call this method on resize to reposition its
 * ports on resize and the ports of its children)
 * @param {boolean} resizing
 * @param {boolean} root The currentShape is root?
 * @chainable
 */
Shape.prototype.fixConnectionsOnResize = function (resizing, root) {

    var i,
        port,
        child,
        connection,
        zoomFactor = this.canvas.zoomFactor;

    if (root) {
        if (this.ports) {
            // connections
            for (i = 0; i < this.ports.getSize(); i += 1) {
                port = this.ports.get(i);
                connection = port.connection;
                this.recalculatePortPosition(port);

                connection.disconnect().connect();
                if (!this.resizing) {
                    connection.setSegmentMoveHandlers();
                    connection.checkAndCreateIntersectionsWithAll();
                }
            }
        }
    } else {
        if (this.ports) {
            // connections
            for (i = 0; i < this.ports.getSize(); i += 1) {
                // for each port update its absolute position and
                // repaint its connections
                port = this.ports.get(i);
                connection = port.connection;
                port.setPosition(port.x, port.y);

                connection.disconnect().connect();
                if (!this.resizing) {
                    connection.setSegmentMoveHandlers();
                    connection.checkAndCreateIntersectionsWithAll();
                }
            }
        }
    }

    // children
    for (i = 0; i < this.children.getSize(); i += 1) {
        child = this.children.get(i);
        child.setPosition(child.x, child.y);
        child.fixConnectionsOnResize(child.resizing, false);
    }
    return this;
};

/**
 * Serializes this object.
 *
 * This method adds the following to the object retrieved from {@link BehavioralElement#stringify}:
 *
 * - resizeBehavior
 * - resizeHandlers (as defined in the config options)
 *
 * @return {Object}
 */
Shape.prototype.stringify = function () {
    var inheritedJSON = BehavioralElement.prototype.stringify.call(this),
        type = (this.savedOptions.resizeHandlers &&
            this.savedOptions.resizeHandlers.type) || 'Rectangle',
        total = (this.savedOptions.resizeHandlers &&
            this.savedOptions.resizeHandlers.total) || 4,
        thisJSON = {
            resizeBehavior: this.savedOptions.resizeBehavior,
            resizeHandlers: {
                type: type,
                total: total
            }
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * Sets the center of the shape
 * @param {number} newCenter
 * @throws {Error} parameter newCenter is not an instance of points
 * @chainable
 */
Shape.prototype.setCenter = function (newCenter) {
    if (newCenter instanceof Point) {
        this.center = newCenter;
    } else {
        throw new Error("setCenter(): argument is not an instance of Point");
    }
    return this;
};

/**
 * Sets the Parent of the shape (might also trigger the custom event change element if the parameter
 * triggerChange is set to true)
 * @chainable
 * @param {Shape} newParent
 * @param {boolean} triggerChange
 */
Shape.prototype.setParent = function (newParent, triggerChange) {
    //if(newParent.type === "Shape" || newParent.type === "StartEvent" ||
    //newParent.type === "EndEvent")
    if (newParent) {

        if (this.canvas && triggerChange) {
            this.canvas.updatedElement = {
                "id" : this.id,
                "type" : this.type,
                "fields" : [{
                    "field" : "parent",
                    "oldVal" : this.parent,
                    "newVal" : newParent
                }]
            };
            $(this.canvas.html).trigger("changeelement");
        }
        this.parent = newParent;
    }
// else {
//        throw new Error("setParent() : paramater newParent is null");
//    }
    return this;
};

/**
 * Sets the oldParent of the shape.
 * @chainable
 * @param {Shape} oldParent
 */
Shape.prototype.setOldParent = function (oldParent) {
    this.oldParent = oldParent;
    return this;
};

/**
 * Gets the center of the shape.
 * @return {Point}
 */
Shape.prototype.getCenter = function () {
    return this.center;
};

/**
 * Gets the parent of the shape.
 * @return {Shape / Canvas}
 */
Shape.prototype.getParent = function () {
    return this.parent;
};

/**
 * Gets the oldParent of the shape
 * @return {Shape / Canvas}
 */
Shape.prototype.getOldParent = function () {
    return this.oldParent;
};

/**
 * Gets the handles IDs used to initialize jQueryUI's resizable plugin
 * @return {Object}
 */
Shape.prototype.getHandlesIDs = function () {
    var handlesObject = {},     // the handles of the shape
        i;                      // iterator

    for (i = 0; i < this.midPointIdentifiers.length; i += 1) {
        handlesObject[this.midPointIdentifiers[i]] = '#' +
            this.midPointIdentifiers[i] + this.id +
            'resizehandler';
    }
    for (i = 0; i < this.cornersIdentifiers.length; i += 1) {
        handlesObject[this.cornersIdentifiers[i]] = '#' +
            this.cornersIdentifiers[i] + this.id +
            'resizehandler';
    }
    return handlesObject;
};

/**
 * @class Label
 * Creates a an object that can in order to illustrate text in the HTML it can
 * be inside a shape or by its own directly in the canvas
 *
 *              //i.e.
 *              var label = new Label({
 *                  //message that the label will display
 *                  message: "This is a label",
 *                  //orientation of the text, can be vertical or horizontal
 *                  orientation: "horizontal",
 *                  //font-family
 *                  fontFamily: "arial",
 *                  //size of the label object not the text
 *                  size: 80,
 *                  //position where it will be located relative to its
 *                  //container
 *                  position: {
 *                  //location can be center, top, bottom among others,
 *                  //relative to its container
 *                      location: "center",
 *                  //How many pixels in the x coordinate and y coordinate
 *                  //we want to move it from its location
 *                      diffX: 2,
 *                      diffY: -1
 *                  },
 *                  //option that determines if the label should update its
 *                  //parent size when it grows
 *                  updateParent: false,
 *                  //label's parent
 *                  parent: canvas
 *
 *              });
 * @extends Shape
 *
 * @constructor
 * Creates an instance of the class
 * @param {Object} options configuration options for the label object
 * @cfg {String} [message=""] Message to be displayed
 * @cfg {String} [orientation="horizontal"] Orientation of the text, can be
 * vertical or horizontal
 * @cfg {String} [fontFamily="arial"] Font family we want the message to be
 * displayed with
 * @cfg {number} [size=0] Size of the label object
 * @cfg {Object} [position={
 *     location: "none",
 *     diffX: 0,
 *     diffY: 0
 * }] Location where we want the label to be positioned relative to its parent
 * @cfg {boolean} [updateParent=false] Determines whether the parent's size
 * should be updated when the label increases its size
 * @cfg {Object} [parent=null] Label's parent
 */
Label = function (options) {
    Shape.call(this, options);
    /**
     * The percentage of this label respect to the width of the shape
     * in the range(0, 1)
     * @property {number}
     */
    this.xPercentage = 0;
    /**
     * The percentage of this label respect to the height of the shape
     * in the range(0, 1)
     * @property {number}
     */
    this.yPercentage = 0;
    /**
     * Message that the label will display
     * @property {String}
     */
    this.message = "";
    /**
     * Orientation of the label
     * @property {String}
     */
    this.orientation = "";
    /**
     * HTML span that holds the text display
     * @property {HTMLElement}
     */
    this.text = null;
    /**
     * Determines whether a label's parent should be updated when a label
     * increases its size
     * @property {boolean}
     */
    this.updateParent = false;
    /**
     * Determines the type of overflow this label should have
     * @property {boolean}
     */
    this.overflow = false;
    /**
     * XXX
     * @property {boolean}
     */
    this.onFocus = false;
    /**
     * Determines the location relative to its parent where this label will be
     * positioned
     * @property {String}
     */
    this.location = "";
    /**
     * x direction pixels that the label will be moved from its location
     * @property {number}
     */
    this.diffX = 0;
    /**
     * y direction pixels that the label will be moved from its location
     * @property {number}
     */
    this.diffY = 0;
    /**
     * Determines the font-size to be used in each zoom scale
     * @property {Array}
     */
    this.fontSizeOnZoom = [];
    /**
     * The font-size that this label will use to display the message
     * @property {number}
     */
    this.fontSize = 0;
    /**
     * html text field for text editing
     * @property {HTMLElement}
     */
    this.textField = null;

    Label.prototype.initObject.call(this, options);
};


Label.prototype = new Shape();
/**
 * Type of all label instances
 * @property {String}
 */
Label.prototype.type = "Label";
/**
 * Line height to be considered in the label's message
 * @type {number}
 */
Label.prototype.lineHeight = 20;


/**
 * Initializer of the object will all the given configuration options
 * @param {Object} options
 */
Label.prototype.initObject = function (options) {
    var defaults = {
        message : "New Label",
        orientation : "horizontal",
        fontFamily : "arial",
        size : 0,
        position : {
            location : "none",
            diffX : 0,
            diffY : 0
        },
        overflow : false,
        updateParent : false,
        parent : null
    };
    this.fontSizeOnZoom = [6, 8, 10, 13, 15];
    $.extend(true, defaults, options);
    this.setMessage(defaults.message)
        .setOverflow(defaults.overflow)
        .setUpdateParent(defaults.updateParent)
        .setOrientation(defaults.orientation)
        .setFontFamily(defaults.fontFamily)
        .setFontSize(defaults.size)
        .setParent(defaults.parent)
        .updateDimension()
        .setLabelPosition(defaults.position.location, defaults.position.diffX,
                        defaults.position.diffY);

};
/**
 * Attach the corresponding listeners to this label
 * @chainable
 */
Label.prototype.attachListeners = function () {
    var $label = $(this.html);
    if (!this.html) {
        return this;
    }
    Shape.prototype.attachListeners.call(this);
    $label.on("dblclick", this.onDblClick(this));
    return this;
};
/**
 * Creates the HTML of the label, the input text and the span for displaying the
 * message
 * @return {HTMLElement}
 */
Label.prototype.createHTML = function () {
    Shape.prototype.createHTML.call(this);
    this.html.style.textAlign = "center";
    this.html.style.align = "center";
    this.html.style.fontFamily = this.fontFamily;
    this.html.style.fontSize = this.fontSize + "pt";
    this.textField = document.createElement("input");
    this.textField.style.width = "200px";
    this.textField.style.position = "absolute";
    this.textField.style.display = "none";
    this.text = document.createElement("span");
    this.text.style.width = "auto";
    this.text.style.height = "auto";
    this.text.style.lineHeight = this.lineHeight * this.canvas.zoomFactor + "px";
    this.text.innerHTML = this.message;
    this.html.appendChild(this.text);
    this.html.appendChild(this.textField);
    this.html.style.zIndex = 2;
    return this.html;
};
/**
 * Displays the style of the label and adds the corresponding classes for
 * rotation
 * @chainable
 */
Label.prototype.paint = function () {
    var $label = $(this.text);

    this.text.style.lineHeight = this.lineHeight * this.canvas.zoomFactor + "px";
    this.textField.value = this.message;
    this.text.innerHTML = this.message;

    this.html.style.verticalAlign = "middle";
    if (this.overflow) {
        this.html.style.overflow = "hidden";
    } else {
        this.html.style.overflow = "none";
    }

    this.displayText(true);
    if (this.orientation === "vertical") {
        $label.addClass('rotateText');
    } else {
        $label.removeClass('rotateText');
    }

    return this;

};
/**
 * Displays the label's message in its current orientation or the input text
 * @param {boolean} display true if we want to display the label's message or
 * false for the input text
 * @chainable
 */
Label.prototype.displayText = function (display) {

    if (display) {
        this.text.style.display = "block";
        this.textField.style.display = "none";
        if (this.orientation === "vertical") {
            this.textField.style.left = "0px";
        }
    } else {
        this.textField.style.display = "block";
        if (this.orientation === "vertical") {
            this.textField.style.left = this.width / 2 - 100 + "px";
        }
        this.text.style.display = "none";
    }
    return this;
};
/**
 * Sets the message of this label
 * @param {String} newMessage
 * @chainable
 */
Label.prototype.setMessage = function (newMessage) {
    this.message = newMessage;
    if (this.text) {
        this.text.innerHTML = this.message;
    }
    return this;
};
/**
 * Retrieves the message that this label is displaying
 * @return {String}
 */
Label.prototype.getMessage = function () {
    return this.message;
};
/**
 * Sets the orientation of the text
 * @param {String} newOrientation It can be vertical or horizontal by default
 * @chainable
 */
Label.prototype.setOrientation = function (newOrientation) {
    var $label;
    this.orientation = newOrientation;
    if (!this.html) {
        return this;
    }
    $label = $(this.text);
    if (newOrientation === "vertical") {
        $label.addClass("rotateText");
        //this.setPosition(this.x - 30, this.y - 30);
    } else {
        $label.removeClass("rotateText");
    }
    return this;
};
/**
 * Retrieves the orientation of this label's text
 * @return {String}
 */
Label.prototype.getOrientation = function () {
    return this.orientation;
};
/**
 * Sets the font family of this label's displayed text
 * @param {String} newFontFamily
 * @chainable
 */
Label.prototype.setFontFamily = function (newFontFamily) {
    this.fontFamily = newFontFamily;
    if (this.html) {
        this.html.style.fontFamily = this.fontFamily;
    }
    return this;
};

/**
 * Sets the font-size of this label's displayed text
 * @param {String} newFontSize
 * @chainable
 */
Label.prototype.setFontSize = function (newFontSize) {
    if (newFontSize === 0) {
        this.fontSize = this.getZoomFontSize();
    } else {
        this.fontSize = newFontSize;
    }
    if (this.html) {
        this.html.style.fontSize = this.fontSize + "pt";
    }
    return this;
};
/**
 * Sets the property to determine if a label should update its parent
 * @param {boolean} newUpdateParent
 * @chainable
 */
Label.prototype.setUpdateParent = function (newUpdateParent) {
    this.updateParent = newUpdateParent;
    return this;
};
/**
 * Sets the overflow property of this label
 * @param {boolean} newOverflow
 * @chainable
 */
Label.prototype.setOverflow = function (newOverflow) {
    this.overflow = newOverflow;
    return this;
};
/**
 * Sets the position of the label regarding its parent, considering the location
 * and x and y differentials
 * @param {String} position location where we want to put the label relative to,
 * its parent, it can be top-left, top, top-right, center-left, center,
 * center-right, bottom-left, bottom, bottom-right
 * @param {number} diffX x coordinate pixels to move from its location
 * @param {number} diffY y coordinate pixels to move from its location
 * @chainable
 */
Label.prototype.setLabelPosition = function (position, diffX, diffY) {
    var x,
        y,
        i,
        width = this.zoomWidth,
        height = this.zoomHeight,
        parent = this.parent,
        parentWidth,
        parentHeight,
        zoomFactor = this.canvas.zoomFactor,
        bottomHeightFactor = 4 * zoomFactor,
        positionString = [
            'top-left',
            'top',
            'top-right',
            'center-left',
            'center',
            'center-right',
            'bottom-left',
            'bottom',
            'bottom-right'
        ],
        orientation,
        orientationIndex = (this.orientation === "vertical") ? 1 : 0,
        positionCoordinates;
    if (!position || position === "") {
        position = "top-left";
    }
    if (diffX === undefined || diffX === null) {
        diffX = 0;
    }
    if (diffY === undefined || diffY === null) {
        diffY = 0;
    }
    if (parent && parent.family !== "Canvas") {
        parentWidth = parent.getZoomWidth();
        parentHeight = parent.getZoomHeight();
        orientation = [
            {x : width / 2, y : 0},
            {x : 0, y : height / 2}
        ];
        positionCoordinates = [
            {
                x : -width / 2,
                y : 0
            },
            {
                x : parentWidth / 2 - width / 2,
                y:  0
            },
            {
                x : parentWidth - width / 2,
                y : 0
            },
            {
                x : -width / 2,
                y : parentHeight / 2 - height / 2
            },
            {
                x : parentWidth / 2 - width / 2,
                y : parentHeight / 2 - height / 2
            },
            {
                x : parentWidth - width,
                y : parentHeight / 2 - height / 2
            },
            {
                x : -width / 2,
                y : parentHeight - bottomHeightFactor
            },
            {
                x : parentWidth / 2 - width / 2,
                y : parentHeight - bottomHeightFactor
            },
            {
                x : parentWidth - width / 2,
                y : parentHeight - bottomHeightFactor
            }
        ];
        for (i  = 0; i < 9; i += 1) {
            if (position === positionString[i]) {
                this.setPosition(
                    positionCoordinates[i].x / zoomFactor + diffX,
                    positionCoordinates[i].y / zoomFactor + diffY
                );
                break;
            }
        }

    }
    this.location = position;
    this.diffX = diffX;
    this.diffY = diffY;
    return this;
};
/**
 * Hides the span showing the label's message and display the input text ready
 * to be edited
 * @chainable
 */
Label.prototype.getFocus = function () {
    var $textField = $(this.textField.html);
    this.displayText(false);
    this.canvas.currentLabel = this;
    $($textField).select();
    this.onFocus = true;
    return this;
};
/**
 * Hides the input text and display the label's message, and if the message's
 * changed, then it executes the editlabel command
 * @chainable
 */
Label.prototype.loseFocus = function () {
    var command;
    this.canvas.currentLabel = null;
    if (this.textField.value !== this.message) {
        command = new CommandEditLabel(this, this.textField.value);
        command.execute();
        this.canvas.commandStack.add(command);
        this.setLabelPosition(this.location, this.diffX, this.diffY);
    }
    this.paint();
    this.onFocus = false;
    return this;
};
/**
 * On Mouse down hander, used to stop propagation when the label's parent is the
 * canvas
 * @param {Label} label
 * @return {Function}
 */
Label.prototype.onMouseDown = function (label) {
    return function (e, ui) {
        if (label.parent.family === "Canvas") {
            e.stopPropagation();
        }
    };
};
/**
 * On Click handler, used to stop propagation when a label is being edited or
 * its parent is the canvas
 * @param {Label} label
 * @return {Function}
 */
Label.prototype.onClick = function (label) {
    return function (e, ui) {
        if (label.parent.family === "Canvas") {
            e.stopPropagation();
        }
        if (label.onFocus) {
            e.stopPropagation();
        }
    };
};
/**
 * Double Click handler, used in order for this label to get focus and being
 * edited
 * @param {Label} label
 * @return {Function}
 */
Label.prototype.onDblClick = function (label) {
    return function (e, ui) {
        var canvas = label.getCanvas(),
            $label = $(label.html);
        if (canvas.currentLabel) {
            canvas.currentLabel.loseFocus();
        }
        label.getFocus();

    };
};
/**
 * Returns the font-size according to the current zoom scale
 * @return {number}
 */
Label.prototype.getZoomFontSize = function () {
    var canvas = this.canvas;
    this.fontSize = this.fontSizeOnZoom[canvas.zoomPropertiesIndex];
    return this.fontSize;
};
/**
 * Parse the messages in words length.
 * It returns an array with the length of all the words in the message
 * @return {Array}
 */
Label.prototype.parseMessage = function () {
    var i,
        start = 0,
        result = [],
        word;
    while (this.message.charAt(start) === ' ') {
        start += 1;
    }
    word = 0;
    for (i = start; i < this.message.length; i += 1) {

        if (this.message.charAt(i) === ' ') {
            result.push(word);
            word = 0;
        } else {
            word += 1;
        }
    }
    result.push(word);
    return result;
};
/**
 * Updates the dimension of the label, according to its message, and if the
 * updateParent property is true then it will call the corresponding method to
 * update its parent according to the label's size
 * @chainable
 */
Label.prototype.updateDimension = function (firstTime) {
//    var characterLimit,
//        characterCount,
//        words = [],
//        lines = 0,
//        i = 0,
//        maxWidth = 0,
//        totalCharacters = 0,
//        canvas = this.canvas,
//        characterOnZoom = [3.3, 5, 7, 9.3, 10.5],
//        characterMaxWidth = [4, 6, 8, 10, 12],
//        characterFactor = characterOnZoom[canvas.zoomPropertiesIndex],
//        characterWidth = characterMaxWidth[canvas.zoomPropertiesIndex],
//        zoomFactor = canvas.zoomFactor;
//
//    words = this.parseMessage();
//    for (i = 0; i < words.length; i += 1) {
//        if (maxWidth < words[i]) {
//            maxWidth = words[i];
//        }
//        totalCharacters += words[i] + 1;
//    }
//    totalCharacters -= 1;
//    if (this.orientation === 'vertical') {
//        if (totalCharacters > 0) {
//            this.setDimension((totalCharacters * characterWidth) / zoomFactor,
//                    20);
//        }
//    } else {
//        maxWidth = Math.max(Math.floor((maxWidth * characterWidth)),
//                this.zoomWidth);
//        characterLimit = Math.ceil((maxWidth / characterFactor));
//        i = 0;
//        while (i < words.length) {
//            lines += 1;
//            characterCount = 0;
//            while (characterCount <= characterLimit && i < words.length) {
//                if (words[i] + characterCount > characterLimit) {
//                    if (characterCount !== 0) {
//                        break;
//                    }
//                }
//                characterCount += words[i] + 1;
//                i += 1;
//            }
//        }
//        this.setDimension(maxWidth / zoomFactor, (lines * 20));
//    }
    var divWidth = $(this.text).width(),
        newWidth,
        newHeight;

    newWidth = Math.max(divWidth, this.zoomWidth);
    newHeight = $(this.text).height();

    this.setDimension(newWidth / this.canvas.zoomFactor,
            newHeight / this.canvas.zoomFactor);
    if (this.updateParent) {
        this.updateParentDimension();
    }
    return this;
};
/**
 * Apply all properties necessary for this label in a given zoom scale
 * @chainable
 */
Label.prototype.applyZoom = function () {
    var canvas = this.canvas;
    this.setFontSize(0);
//    this.fontSize = this.fontSizeOnZoom[canvas.zoomPropertiesIndex];
//    this.setDimension(this.width, this.height);
//    this.updateDimension();
    this.paint();
    return this;
};
/**
 * Calls the method to update the label's parent dimension according to the
 * label's orientation
 * @chainable
 */
Label.prototype.updateParentDimension = function () {

    if (this.orientation === "vertical") {
        this.updateVertically();
    } else {
        this.updateHorizontally();
    }
    if (this.parent.html) {
        this.parent.paint();
    }
    return this;
};
/**
 * Updates its parent height according to the size of the label
 * @chainable
 */
Label.prototype.updateVertically = function () {
    var margin = 5,
        parent = this.parent,
        labelWidth = this.zoomWidth,
        newHeight,
        zoomFactor = this.canvas.zoomFactor;
    if (labelWidth > parent.zoomHeight - margin * 2) {
        newHeight = labelWidth + margin * 2;
    } else {
        newHeight = parent.zoomHeight;
    }
    parent.setDimension(parent.width, newHeight / zoomFactor);
    parent.updateChildrenPosition(0, 0);
    parent.refreshConnections();
    this.setLabelPosition(this.location, this.diffX, this.diffY);
    return this;
};
/**
 * Updates its parent width and height according to the new label's dimension
 * @chainable
 */
Label.prototype.updateHorizontally = function () {
    var margin = 5,
        parent = this.parent,
        labelWidth = this.zoomWidth,
        labelHeight = this.zoomHeight,
        newWidth,
        newHeight,
        zoomFactor = this.canvas.zoomFactor;
    if (labelWidth > parent.zoomWidth - margin * 2) {
        newWidth = labelWidth + margin * 2;
    } else {
        newWidth = parent.zoomWidth;
    }
    if (labelHeight > parent.zoomHeight - margin * 2) {
        newHeight = labelHeight + margin * 2;
    } else {
        newHeight = parent.zoomHeight;
    }
    parent.setDimension(newWidth / zoomFactor, newHeight / zoomFactor);
//    parent.updateChildrenPosition();
    parent.fixConnectionsOnResize(parent.resizing, true);
    parent.refreshConnections();
    this.setLabelPosition(this.location, this.diffX, this.diffY);
    return this;
};
/**
 * Serializes this object
 * @return {Object}
 */
Label.prototype.stringify = function () {
    // TODO: USE CLASS STYLE IN THE METHODS OF THIS CLASS
    // TODO: COMPLETE THE JSON
    /**
     * inheritedJSON = {
     *     id: #
     *     x: #,
     *     y: #,
     *     width: #,
     *     height: #
     * }
     * @property {Object}
     */
    var inheritedJSON = {},
        thisJSON = {
            id: this.getID(),
            message: this.getMessage(),
            orientation: this.getOrientation(),
            position : {
                location : this.location,
                diffX : this.diffX,
                diffY : this.diffY
            }
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;

};

/**
 * @class CustomShape
 * This is a custom shape, where there can be applied styles, sprites and
 * decoration, it can have connections associated to it by ports, different
 * layers and labels as well
 *              //i.e.
 *              var customShape = new CustomShape({
 *                  //Determines whether the shape will be connected only in its
 *                  //middle points
 *                  connectAtMiddlePoints : true,
 *                  //The layers that will be instantiated with this shape
 *                  layers: [
 *                      {
 *                                                          {
 *                        layerName : "first-layer",
 *                        priority: 2,
 *                        visible: true,
 *                        style: {
 *                        cssClasses: ['bpmn_zoom']
 *                      },
 *                        zoomSprites : ['img_50_start',
 *                        'img_75_start', 'img_100_start',
 *                        'img_125_start', 'img_150_start']
 *                        }, {
 *                        layerName: "second-layer",
 *                        priority: 3,
 *                        visible: true
 *                        }
 *
 *                  ],
 *                  //Labels that belong to this shape
 *                  labels : [
 *                      {
 *                          message: "this is one label",
 *                          position: {
 *                              location : "bottom",
 *                              diffX: 0,
 *                              diffY: 5
 *                          }
 *                      }
 *                  ],
 *                  //The type of connections that are made with this shape,
 *                  //Each type differs of one another for the type of lines
 *                  //used in the connection
 *                  connectionType: "regular"
 *
 *              });
 * @extends Shape
 *
 * @constructor
 * Creates an instance of a CustomShape
 * @param {Object} options configuration options used in a custom shape
 * @cfg {Boolean} [connectAtMiddlePoints=true] Determines whether shape's,
 * connections should be created only in the middle points of its sides
 * @cfg {Array} [layers=[]] Configuration options of all layers that will be,
 * instantiated with this shape
 * @cfg {Array} [labels=[]] Configuration options of all labels that will be
 * instantiated with this shape
 * @cfg {String} [connectionType="regular"] Type of lines that will be used in
 * all connections involving this shape
 */
CustomShape = function (options) {
    /**
     * List of all the layers associated to this shape
     * @property {ArrayList}
     */
    this.layers = new ArrayList();

    Shape.call(this, options);
    /**
     * List of all the ports associated to this shape
     * @property {ArrayList}
     */
    this.ports = new ArrayList();

    /**
     * List of all the labels associated to this shape
     * @property {ArrayList}
     */
    this.labels = new ArrayList();
    /**
     * List of all the zoom properties in different zoom scales
     * @property {ArrayList}
     */
    this.zoomProperties = new ArrayList();

    /**
     * Inner figure for drawing connection limits
     * @property {Array}
     */
    this.limits = [0, 0, 0, 0];
    /**
     * Border to be added to determine the new position of the port
     * @property {Array}
     */
    this.border = [
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0}
    ];
    /**
     * Determines which type of drag behavior should be assigned
     * @property {number}
     */
    this.dragType = this.CANCEL;
    /**
     * Reference to the point where a connection drag is being started
     * @property {Point}
     */
    this.startConnectionPoint = null;
    /**
     * if set to true, a port will only be added at its middle points
     * @property {Boolean}
     */
    this.connectAtMiddlePoints = null;
    /**
     * Auxiliary property for saving the previous x coordinate in the dragging
     * procedure for multiple drag
     * @property {Number}
     */
    this.previousXDragPosition = 0;
    /**
     * Auxiliary property for saving the previous y coordinate in the dragging
     * procedure for multiple drag
     * @property {Number}
     */
    this.previousYDragPosition = 0;
    /**
     * The type of lines for connections made with this shape
     * @property {String}
     */
    this.connectionType = null;
    // init the custom shape
    CustomShape.prototype.initObject.call(this, options);
};


CustomShape.prototype = new Shape();
/**
 * Type the instances of this class
 * @property {String}
 */
CustomShape.prototype.type  = "CustomShape";
/**
 * Family where this class and all its subclasses belong
 * @property {String}
 * @readonly
 */
CustomShape.prototype.family = "CustomShape";
/**
 * Reference to a drop behaviors for containers
 * @property {ContainerDropBehavior}
 */
CustomShape.prototype.containerDropBehavior = null;
/**
 * Reference to a drop behavior that allows us to make connections
 * @property {ConnectionDropBehavior}
 */
CustomShape.prototype.connectionDropBehavior = null;
/**
 * Reference to a drop behavior that has no acceptable droppables
 * @property {NoDropBehavior}
 */
CustomShape.prototype.noDropBehavior = null;
/**
 * Constant that represents that a drag behavior for making connections should
 * be used
 * @property {Number}
 */
CustomShape.prototype.CONNECT = 1;
/**
 * Constant that represents that a drag behavior for moving the shape should be
 * used
 * @property {Number}
 */
CustomShape.prototype.DRAG = 2;
/**
 * Constant that represents that no drag behavior should be used
 * @property {Number}
 */
CustomShape.prototype.CANCEL = 0;

/**
 * Initializes the basic attributes for the custom shape, and also the
 * particular objects the shape needs to instantiate
 * //TODO Base limits on zoom
 * @param options
 */
CustomShape.prototype.initObject = function (options) {

    var defaults = {
        connectAtMiddlePoints: true,
        layers : [],
        labels: [],
        connectionType : "regular"
    },
        i;

    // init the object with NO configurable options
    this.limits = [5, 5, 5, 5, 5];
    this.setStartConnectionPoint(new Point(0, 0));
        //.setDragBehavior(new RegularDragBehavior());

    // init the object with configurable options
    $.extend(true, defaults, options);
    for (i = 0; i < defaults.layers.length; i += 1) {
        this.createLayer(defaults.layers[i]);
    }
    for (i = 0; i < defaults.labels.length; i += 1) {
        this.createLabel(defaults.labels[i]);
    }
    this.setConnectAtMiddlePoints(defaults.connectAtMiddlePoints)
        .setConnectionType(defaults.connectionType);

};
/**
 * Creates a layer given its configuration options
 * @param {Object} options configuration options
 * @return {Layer}
 */
CustomShape.prototype.createLayer = function (options) {

    var layer;
    options.parent = this;
    layer = new Layer(options);
    this.addLayer(layer);
    return layer;
};
/**
 * Creates a label given its configuration options
 * @param {Object} options configuration options for instantiating a label
 * @return {Label}
 */
CustomShape.prototype.createLabel = function (options) {
    var label;
    options.canvas = this.canvas;
    options.parent = this;
    if (options.width === 0) {
        options.width = this.width * 0.9;
    }
    label = new Label(options);
    this.addLabel(label);
    return label;
};

/**
 * Adds a label to the array of labels and also appends its html
 * @param {Label}
 */
CustomShape.prototype.addLabel = function (label) {
    if (this.html) {
        //so we just append it to the parent
        label.parent = this;
        this.html.appendChild(label.getHTML());
    }
    if (!this.labels.contains(label)) {
        this.labels.insert(label);
    }
};
/**
 * Creates the html for the shape, its layers and labels
 * @returns {HTMLElement}
 */
CustomShape.prototype.createHTML = function () {
    var i,
        label;
    Shape.prototype.createHTML.call(this);

    // this line: this.html.className = "custom_shape"
    // replaced with:
    this.style.addClasses(["custom_shape"]);

    this.layers.sort(Layer.prototype.comparisonFunction);

    for (i = 0; i < this.layers.getSize(); i += 1) {
        this.html.appendChild(this.layers.get(i).getHTML());

    }
    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        this.addLabel(label);
        label.attachListeners();

    }
    return this.html;
};

/**
 * This function will attach all the listeners corresponding to the CustomShape
 * @chainable
 */
CustomShape.prototype.attachListeners = function () {
    if (this.html === null) {
        return this;
    }

    var $customShape = $(this.html)
        .click(this.onClick(this));
    //drag options for the added shapes
    $customShape.on("mousedown", this.onMouseDown(this));
    $customShape.mousemove(this.onMouseMove(this));
    $customShape.mouseup(this.onMouseUp(this));
    $customShape.on("contextmenu", function (e) {
        e.preventDefault();
    });

    this.updateBehaviors();
    return this;

};

/**
 * Apply the styles related to the shape, its layers and labels
 * @chainable
 */
CustomShape.prototype.paint = function () {
    var i,
        label;

    Shape.prototype.paint.call(this);

    // apply predefined style
//    console.log(this.style.cssProperties);
//    this.style.applyStyle();

    //TODO Apply the style of the given shape
    for (i = 0; i < this.layers.getSize(); i += 1) {
        this.layers.get(i).paint();
    }
    for (i = 0; i < this.ports.getSize(); i += 1) {
        this.ports.get(i).paint();
    }
    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        label.paint();
    }
    return this;
};

/**
 * Updates properties obtained when the HTML is on the DOM
 * @chainable
 */
CustomShape.prototype.updateHTML = function () {
    var i,
        label;
    this.setDimension(this.width, this.height);
    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        label.paint();
        label.updateDimension();
    }
    return this;
};
/**
 * Repaints connections related to this shape
 * @param {Boolean} inContainer Determines if the points of a connection should
 * be saved for its reconstruction
 * @chainable
 */
CustomShape.prototype.refreshConnections = function (inContainer, isDragged,
                                                     isZoomed) {
    var i,
        connection,
        ports = this.ports,
        port;
    for (i = 0; i < ports.getSize(); i += 1) {
        port = ports.get(i);
        port.setPosition(port.getX(), port.getY());
        connection = port.connection;
        if (!isDragged) {
            connection.disconnect(inContainer)
                .connect(inContainer);
        }

        connection.setSegmentMoveHandlers()
            .checkAndCreateIntersectionsWithAll();
        if (!isZoomed) {
            this.canvas.triggerConnectionStateChangeEvent(connection);
        }
    }
    return this;
};
/**
 * Updates the properties of this shape layers according to the shape itself
 * @chainable
 */
CustomShape.prototype.updateLayers = function () {
    var i, j,
        layer;
    for (i = 0; i < this.getLayers().getSize(); i += 1) {
        layer = this.getLayers().get(i);
        layer.setProperties();
    }
    return this;
};
/**
 * Returns what it should be the next layer if there is such in the DOM tree
 * or null otherwise
 * @param {Layer} layer
 * @returns {Layer}
 */
CustomShape.prototype.findLayerPosition = function (layer) {
    var nextLayer = null,//holds the next layer regarding the position where
    // the new layer should be inserted
        minVal = 10000000, //holds the minimum value of all the values greater
    // than the newLayer priority
        i,
        currLayer,
        currPriority;
    //iterate through all the layers and find the minimum priority of all
    // the priorities that are greater than the priority of the current layer
    for (i = 0; i < this.layers.getSize(); i += 1) {
        currLayer = this.layers.get(i);
        currPriority = currLayer.getPriority();
        if (currPriority > layer.getPriority()) {
            if (minVal > currPriority) {
                minVal = currPriority;
                nextLayer = currLayer;
            }
        }
    }
    return nextLayer;
};

/**
 * Adds a new layer to the corresponding shape
 * @param {Layer} newLayer
 * @chainable
 */
CustomShape.prototype.addLayer = function (newLayer) {
    //gets the layer that would come next the new one
    var nextLayer = this.findLayerPosition(newLayer);
    //if there is none it means that the new layer has the highest priority
    // of all
    if (this.html) {
        if (!nextLayer) {
            //so we just append it to the parent
            this.html.appendChild(newLayer.getHTML());
        } else {
            //otherwise we append it before nextLayer
            this.html.insertBefore(newLayer.getHTML(), nextLayer.getHTML());
        }
        newLayer.paint();
    }
    this.layers.insert(newLayer);

    return this;
};

/**
 * Finds a given layer by ID or null of it doesn't exist
 * @param {String} layerID
 * @returns {Layer}
 */
CustomShape.prototype.findLayer = function (layerID) {

    var currLayer,
        i;
    currLayer = this.layers.find('id', layerID);
    return currLayer;
};
/**
 * Set the dimension of the customShape
 * @param {Number} newWidth
 * @param {Number} newHeight
 */
CustomShape.prototype.setDimension = function (newWidth, newHeight) {
    Shape.prototype.setDimension.call(this, newWidth, newHeight);
    this.updateLabels();
    this.updateLayers();
    return this;
};
/**
 * Updates the labels properties if necessary
 * @abstract
 * @template
 * @protected
 */
CustomShape.prototype.updateLabels = function () {

};
/**
 * Makes a layer non-visible
 * @param {String} layerID
 * @returns {CustomShape}
 */
CustomShape.prototype.hideLayer = function (layerID) {
    var currLayer;
    if (!layerID || typeof layerID !== "string") {
        return this;
    }
    currLayer = this.findLayer(layerID);
    if (!currLayer) {
        return this;
    }

    currLayer.setVisible(false);
    return this;

};
/**
 * Makes a layer visible
 * @param {String} layerID
 * @returns {CustomShape}
 */
CustomShape.prototype.showLayer = function (layerID) {
    var currLayer;
    if (!layerID || typeof layerID !== "string") {
        return this;
    }

    currLayer = this.findLayer(layerID);
    if (!currLayer) {
        return this;
    }
    currLayer.setVisible(true);


    return this;
};


/**
 * Adds a port to the Shape
 * @param {Port} port
 * @param {Number} xPortCoord
 * @param {Number} yPortCoord
 * @chainable
 */
CustomShape.prototype.addPort = function (port, xPortCoord, yPortCoord,
                                        triggerChange, sourcePort) {


    //where the user is attempting to create the port
    //TODO Fix trowing custom events by using properties of the objects
    var position = new Point(xPortCoord, yPortCoord);
//        oldX = port.x,
//        oldY = port.y,
//        oldAbsoluteX = port.absoluteX,
//        oldAbsoluteY = port.absoluteY,
//        oldParent = port.parent;
    //set the corresponding shape where the port would be created

    port.setParent(this);
    port.setCanvas(this.canvas);

    //set the port dimension
//    port.setDimension(8, 8);

    //validate the position of the port in order to positionate it in one of
    // the corners of the shape, this is applied to all but activities

    //port.validatePosition(position);
    this.definePortPosition(port, position, sourcePort);

    //append the html to the DOM and paint the port
    this.html.appendChild(port.getHTML());

    port.paint();
//    port.setColor(new Color(255, 0, 0));
    //insert the port to the ports array of the shape
    this.ports.insert(port);
//    if (triggerChange) {
//        port.changeParent(oldX, oldY, oldAbsoluteX,
//            oldAbsoluteY, oldParent, port.canvas);
//    }
    return this;
};
/**
 *
 * Removes a port from the Shape
 * @param {Port} port
 * @chainable
 */
CustomShape.prototype.removePort = function (port) {
    this.ports.remove(port);
    return this;
};
/**
 * Determines the position where the port will be located
 * @param {Port} port
 * @param {Point} point
 * @param {Port} sourcePort
 * @chainable
 */
CustomShape.prototype.definePortPosition = function (port, point,
                                                     sourcePort) {
    var canvas = this.canvas,
        directionArray = [this.TOP, this.RIGHT, this.BOTTOM, this.LEFT],
        // midPointArray is used when connectAtMiddlePoints is set to TRUE
        midPointArray = [
            new Point(Math.round(this.zoomWidth / 2), 0),               // TOP
            new Point(this.zoomWidth, Math.round(this.zoomHeight / 2)),// RIGHT
            new Point(Math.round(this.zoomWidth / 2), this.zoomHeight),// BOTTOM
            new Point(0, Math.round(this.zoomHeight / 2))               // LEFT
        ],
        // sideArray is used when connectAtMiddlePoints is set to FALSE
        sideArray = [
            new Point(point.x, 0),                          // TOP
            new Point(this.getZoomWidth(), point.y),            // RIGHT
            new Point(point.x, this.getZoomHeight()),           // BOTTOM
            new Point(0, point.y)                           // LEFT
        ],
        usedArray,  // selects either the midPointArray or the side array
        direction,
        i,
        candidateDistance,
        minDistance,
        option,
        border,
        directionBorderMultiplier = [-1, 1, 1, -1],
        rightBorderMultiplier = [0, 0, -2, 0],
        bottomBorderMultiplier = [0, -2, 0, 0];

    // if the shape has the connectAtMiddlePoints flag on then use the midPoints
    usedArray = this.connectAtMiddlePoints ? midPointArray : sideArray;

    // if the shape has a source port available then use manhattan distance
    // instead of squaredDistance
    option = "getSquaredDistance";
    if (sourcePort && this.connectAtMiddlePoints) {
        option = "getManhattanDistance";
//        point = new Point(sourcePort.x + sourcePort.parent.absoluteX,
//            sourcePort.y + sourcePort.parent.absoluteY);
    }
    direction = undefined;  //obtain location of the port
    minDistance = Infinity;
    // get the minimum distance between 2 points;
    for (i = 0; i < usedArray.length; i += 1) {
//        if (sourcePort && this.connectAtMiddlePoints) {
//            // use manhattan distance
//            // logic: manhattan_distance(
//            //      new Point(srcPort.x + srcShape.x, srcPort.y + srcShape.y),
//            //      new Point(destPort.x + destShape.x, destPort.y +
//            //                  destShape.y)
//            // )
////            candidateDistance = point[option](usedArray[i].
////                add(new Point(port.parent.absoluteX,
//                                  port.parent.absoluteY)));
//            candidateDistance = point[option](usedArray[i]);
//        } else {
            // use squared distance
        candidateDistance = point[option](usedArray[i]);
//        }
        if (minDistance > candidateDistance) {
            minDistance = candidateDistance;
            direction = directionArray[i];
        }
    }

    border = this.getBorderConsideringLayers();
    for (i = 0; i < 4; i += 1) {
        this.border[i].x =
            (border * directionBorderMultiplier[i] +
                border * rightBorderMultiplier[i]);
        this.border[i].y =
            (border * directionBorderMultiplier[i] +
                border * bottomBorderMultiplier[i]);
    }
    // because of the zIndex problem move the ports towards the center
    // of the shape (this is done when the destDecorator is selected)
    port.setDirection(direction);
    // setPosition logic:
    // since the port must face the border of the shape (or the shape if it
    // doesn't have a border) first let's move the port according to the
    // direction of the port (up -> -1 * border, right -> 1 * border, bottom ->
    // 1 * border, left -> -1 * border)
    // after the port will be right in the edge of the shape but now the
    // multiplier has also affected the positioning of the port if it's located
    // in the right or in the bottom (the port will move 2 * border in the
    // y-axis or x-axis) so let's reverse that movement using another array
    port.setPosition(
        (
//            this.border[direction].x +
            usedArray[direction].x
             - port.getWidth() / 2
        ),
        (
//            this.border[direction].y +
            usedArray[direction].y
             - port.getHeight() / 2
        )
    );


    port.applyBorderMargin(true);

    // determines the percentage of port in relation with the shape's width or
    // height (useful to determine the new position of the port while resizing)
    port.determinePercentage();

    return this;
};

/**
 * Returns the border of this shape or the border of its layers (max)
 * @return {Number}
 */
CustomShape.prototype.getBorderConsideringLayers = function () {
    var border = parseInt(this.style.getProperty('borderTopWidth') || 0, 10),
        layer,
        i;
    for (i = 0; i < this.getLayers().getSize(); i += 1) {
        layer = this.getLayers().get(i);
        border = Math.max(border, parseInt(
            layer.style.getProperty('borderTopWidth') || 0,
            10
        ));
    }
    return border;
};

/**
 * Show  all the ports of the Shape
 * @chainable
 */
CustomShape.prototype.showPorts = function () {
    var i;
    for (i = 0; i < this.ports.getSize(); i += 1) {
        this.ports.get(i).show();
    }
    return this;
};

/**
 * hide  all the ports of the Shape
 * @chainable
 */
CustomShape.prototype.hidePorts = function () {
    var i;
    for (i = 0; i < this.ports.getSize(); i += 1) {
        this.ports.get(i).hide();
    }
    return this;
};

/**
 * Updates the position of the ports regarding the CustomShape and two
 * differentials
 * TODO Improve triggering of events with ports own properties
 * @param {Number} xDiff
 * @param {Number} yDiff
 * @chainable
 */
CustomShape.prototype.updatePortsPosition = function (xDiff, yDiff) {
    var i,
        port,
        ports = this.ports;
    for (i = 0; i < ports.getSize(); i += 1) {
        port = ports.get(i);
        if (port.direction === this.RIGHT || port.direction === this.BOTTOM) {
            port.oldX = port.x;
            port.oldY = port.y;
            port.oldAbsoluteX = port.absoluteX;
            port.oldAbsoluteY = port.absoluteY;
            port.setPosition(port.x + xDiff, port.y + yDiff, true);
            port.changePosition(port.oldX, port.oldY, port.oldAbsoluteX,
                port.oldAbsoluteY);
        } else {
            port.setPosition(port.x, port.y, true);
        }
        port.connection.disconnect().connect();
        port.connection.setSegmentMoveHandlers();
    }
    return this;
};

/**
 * Recalculates a port position given the port
 * TODO Determine if this method is necessary
 * @param {Port} port
 * @chainable
 */
CustomShape.prototype.recalculatePortPosition = function (port) {
//    console.log(port.percentage);
    var xPercentage = Math.round((port.percentage *
            port.parent.getZoomWidth()) / 100),
        yPercentage = Math.round((port.percentage *
            port.parent.getZoomHeight()) / 100),
        xCoordinate = [xPercentage, port.parent.getZoomWidth(), xPercentage, 0],
        yCoordinate = [0, yPercentage,
                port.parent.getZoomHeight(), yPercentage];
//    console.log(xPercentage + " " + yPercentage);
    port.setPosition(
        this.border[port.direction].x + xCoordinate[port.direction] -
            Math.round(port.width / 2),
        this.border[port.direction].y + yCoordinate[port.direction] -
            Math.round(port.height / 2)
    );
    return this;
};

/**
 * Initializes properties to to save the current position of the ports
 * @chainable
 */
CustomShape.prototype.initPortsChange = function () {
    var i,
        ports = this.ports,
        port;
    for (i = 0; i  < ports.getSize(); i += 1) {
        port = ports.get(i);
        port.oldX = port.x;
        port.oldY = port.y;
        port.oldAbsoluteX = port.absoluteX;
        port.oldAbsoluteY = port.absoluteY;
    }
    return this;
};

/**
 * Trigger to save the port changes
 * @chainable
 */
CustomShape.prototype.firePortsChange = function () {
    var i,
        ports = this.ports,
        port;
    for (i = 0; i < ports.getSize(); i += 1) {
        port = ports.get(i);
        // port is not a shape so use call
        Shape.prototype.changePosition.call(this, port.oldX, port.oldY,
            port.oldAbsoluteX, port.oldAbsoluteY);
    }
    return this;
};
/**
 * Updates ports and connections of the current shape
 * @chainable
 */
CustomShape.prototype.refreshShape = function () {
    Shape.prototype.refreshShape.call(this);
    this.updatePortsOnZoom()
        .refreshConnections(false, false, true);
    this.paint();
    return this;
};
/**
 * Updates the position of the ports after applying a zoom scale
 * @chainable
 */
CustomShape.prototype.updatePortsOnZoom = function () {
    var i,
        ports = this.ports,
        port,
        zoomFactor = this.canvas.zoomFactor,
        prevZoomFactor = (this.canvas.prevZoom * 25 + 50) / 100,
        portFactor = (ports.getSize() > 0) ? ports.get(0).width / 2 : 0,
        srcDecorator,
        destDecorator,
        xCoords = [
            this.zoomWidth / 2 - portFactor,
            this.zoomWidth - portFactor,
            this.zoomWidth / 2 - portFactor,
            -portFactor
        ],
        yCoords = [
            -portFactor,
            this.zoomHeight / 2 - portFactor,
            this.zoomHeight - portFactor,
            this.zoomHeight / 2 - portFactor
        ];

    for (i = 0; i < ports.getSize(); i += 1) {
        port = ports.get(i);
        port.applyBorderMargin(false);
        if (this.connectAtMiddlePoints) {
            port.setPosition(Math.round(xCoords[port.direction]),
                Math.round(yCoords[port.direction]));
        } else {
            xCoords = [
                port.x / prevZoomFactor * zoomFactor,
                this.getZoomWidth() - port.getZoomWidth() / 2,
                port.x / prevZoomFactor * zoomFactor,
                port.x
            ];
            yCoords = [
                port.y,
                port.y / prevZoomFactor * zoomFactor,
                this.getZoomHeight() - port.getZoomHeight() / 2,
                port.y / prevZoomFactor * zoomFactor
            ];
            port.setPosition(Math.round(xCoords[port.direction]),
                Math.round(yCoords[port.direction]));
        }
        port.applyBorderMargin(true);
        srcDecorator = port.connection.srcDecorator;
        destDecorator = port.connection.destDecorator;
        if (srcDecorator) {
            srcDecorator.applyZoom();
        }
        if (destDecorator) {
            destDecorator.applyZoom();
        }


//        port.connection.disconnect().connect();
//        port.connection.setSegmentMoveHandlers();
//        port.connection.checkAndCreateIntersectionsWithAll();
    }
    return this;
};
/**
 * TODO Determine if this method is necessary
 */
CustomShape.prototype.calculateLabelsPercentage = function () {
    var i, label;
    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        label.xPercentage = label.getX() / this.getWidth();
        label.yPercentage = label.getY() / this.getHeight();
    }

};

/**
 * Updates the labels position according to its configuration properties
 * @chainable
 */
CustomShape.prototype.updateLabelsPosition = function () {
    var i,
        label;
    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        label.setLabelPosition(label.location, label.diffX, label.diffY);
    }
    return this;
};

/**
 * Returns the respective drag behavior according to a given point
 * @return {Number}
 */
CustomShape.prototype.determineDragBehavior = function (point) {
    // limit to consider inside the shape
    var limit = this.limits[this.canvas.zoomPropertiesIndex],

        border = parseInt(this.style.getProperty('border') || 0, 10);

    // if the point is inside the rectangle determine the behavior
    // (drag or connect)
    if (Geometry.pointInRectangle(point, new Point(0, 0),
            new Point(this.zoomWidth + 2 * border,
                    this.zoomHeight + 2 * border))) {
        // if the shape is inside the inner rectangle then drag
        if (Geometry.pointInRectangle(point,
                new Point(border + limit, border + limit),
                new Point(this.zoomWidth + border - limit,
                    this.zoomHeight + border - limit))) {
            return this.DRAG;
        }
        return this.CONNECT;
    }

    // if the mouse pointer is outside then return cancel
    return this.CANCEL;
};
/**
 * Creates a drag helper for drag and drop operations for the helper property
 * in jquery ui draggable
 * TODO Create a singleton object for this purpose
 * @returns {String} html
 */
CustomShape.prototype.createDragHelper = function () {
    var html = document.createElement("div");

    // can't use class style here
    html.style.width = 8 + "px";
    html.style.height = 8 + "px";
    html.style.backgroundColor = "black";
    html.style.zIndex = 2 * Shape.prototype.MAX_ZINDEX;
    html.id = "drag-helper";
    html.className = "drag-helper";
    // html.style.display = "none";
    return html;
};

/**
 * Handler for the onmousedown event, changes the draggable properties
 * according to the drag behavior that is being applied
 * @param {CustomShape} CustomShape
 * @returns {Function}
 */
CustomShape.prototype.onMouseDown = function (customShape) {
    return function (e, ui) {
        var canvas = customShape.canvas;
        if (e.which === 3) {
            $(canvas.html).trigger("rightclick", [e, customShape]);
        } else {

            if (customShape.dragType === customShape.DRAG) {
                customShape.setDragBehavior("customshapedrag");

            } else if (customShape.dragType === customShape.CONNECT) {
                customShape.setDragBehavior("connection");
            } else {
                customShape.setDragBehavior("nodrag");
            }
            customShape.dragging = true;
        }

        e.stopPropagation();
    };
};


/**
 * On Mouse Up handler it allows the shape to recalculate drag behavior
 * whenever there was a mouse down event but no drag involved
 * @param {CustomShape} customShape
 * @return {Function}
 */
CustomShape.prototype.onMouseUp = function (customShape) {
    return function (e, ui) {
        customShape.dragging = false;

    };
};

/**
 * Handler for the onmousemove event, determines the drag behavior that is
 * being applied, the coordinates where the mouse is currently located and
 * changes the mouse cursor
 * @param {CustomShape} customShape
 * @returns {Function}
 */

CustomShape.prototype.onMouseMove = function (customShape) {
    return function (e, ui) {
        var $customShape,
            canvas;

        if (customShape.dragging || customShape.entered) {
            return;
        }
//TODO ADD TO UTILS A FUNCTION TO RETRIEVE A POINT RESPECTING THE SHAPE
        $customShape = $(customShape.html);
        canvas = customShape.getCanvas();

        customShape.startConnectionPoint.x = e.pageX - canvas.getX() -
            customShape.absoluteX + canvas.getLeftScroll();
        customShape.startConnectionPoint.y = e.pageY - canvas.getY() -
            customShape.absoluteY + canvas.getTopScroll();

        customShape.dragType = customShape
            .determineDragBehavior(customShape.startConnectionPoint);

        if (customShape.dragType === customShape.DRAG) {
            $customShape.css('cursor', 'move');
        } else if (customShape.dragType === customShape.CONNECT) {
            $customShape.css('cursor', 'crosshair');

        } else {
            $customShape.css('cursor', 'default');
        }
        //e.stopPropagation();
    };
};

/**
 * Handler of the onClick Event hides the selected ports and resize Handlers if
 * any and show its corresponding resize handler
 * @param {CustomShape} customShape
 * @returns {Function}
 */
CustomShape.prototype.onClick = function (customShape) {
    return function (e, ui) {
        var isCtrl = false,
            canvas = customShape.canvas,
            currentSelection = canvas.currentSelection,
            currentLabel = canvas.currentLabel;

        if (e.ctrlKey) { // Ctrl is also pressed
            isCtrl = true;
        }

        // hide the current connection if there was one
        customShape.canvas.hideCurrentConnection();

        if (e.which === 3) {        // right click
            e.preventDefault();
            // trigger right click
            customShape.canvas.triggerRightClickEvent(customShape);
        } else {
            if (!customShape.wasDragged) {
                // if the custom shape was not dragged (this var is set to true
                // in custom_shape_drag_behavior >> onDragEnd)
                if (isCtrl) {
                    if (currentSelection.contains(customShape)) {
                        // remove from the current selection
                        canvas.removeFromSelection(customShape);
                    } else {
                        // add to the current selection
                        canvas.addToSelection(customShape);
                    }

                } else {
                    canvas.emptyCurrentSelection();
                    canvas.addToSelection(customShape);
                }
            }
            if (!currentSelection.isEmpty()) {
                canvas.triggerSelectEvent(currentSelection.asArray());
            }
        }

        if (this.helper) {
            $(this.helper.html).remove();
        }

        if (currentLabel) {
            currentLabel.loseFocus();
            $(currentLabel.textField).focusout();
        }
        customShape.wasDragged = false;
//        customShape.canvas.setCurrentShape(customShape);
        e.stopPropagation();
    };
};

/**
 * Empty function to perform some actions when parsing a diagram (called
 * from Canvas.parse)
 */
CustomShape.prototype.parseHook = function () {
};

/**
 * Returns a list of ports related to the shape
 * @returns {ArrayList}
 */
CustomShape.prototype.getPorts = function () {
    return this.ports;
};
/**
 * Returns a list of Layers related to the shape
 * @returns {ArrayList}
 */
CustomShape.prototype.getLayers = function () {
    return this.layers;
};

/**
 * Returns the labels associated to the current shape
 * @return {ArrayList}
 */
CustomShape.prototype.getLabels = function () {
    return this.labels;
};

/**
 * Applies the current zoom to the corresponding shape its layers and labels
 * @chainable
 */
CustomShape.prototype.applyZoom = function () {
    var i,
        label;

    Shape.prototype.applyZoom.call(this);

    for (i = 0; i < this.layers.getSize(); i += 1) {
        this.layers.get(i).applyZoom();
    }

    for (i = 0; i < this.labels.getSize(); i += 1) {
        label = this.labels.get(i);
        label.applyZoom();
        label.setLabelPosition(label.location, label.diffX, label.diffY);
        //label.setPosition(label.x, label.y);
    }

    return this;
};

/**
 * Sets the start point of a connection corresponding to this shape
 * @param {Point} point
 * @chainable
 */
CustomShape.prototype.setStartConnectionPoint = function (point) {
    this.startConnectionPoint = point;
    return this;
};
/**
 * Sets the connectAtMiddlePoints property
 * @param  {Boolean} connect
 * @chainable
 */
CustomShape.prototype.setConnectAtMiddlePoints = function (connect) {
    this.connectAtMiddlePoints = connect;
    return this;
};
/**
 * Returns whether a shape connections will be done only in the middle points of
 * its sides or not
 * @return {Boolean}
 */
CustomShape.prototype.getConnectAtMiddlePoints = function () {
    return this.connectAtMiddlePoints;
};
/**
 * Sets the connection type of the shape
 * @param {String} newConnType
 * @chainable
 */
CustomShape.prototype.setConnectionType = function (newConnType) {
    this.connectionType = newConnType;
    return this;
};
/**
 * Returns the connection type of the shape
 * @return {String}
 */
CustomShape.prototype.getConnectionType = function () {
    return this.connectionType;
};
/**
 * Serializes this object
 * @return {Object}
 */
CustomShape.prototype.stringify = function () {
    /**
     * inheritedJSON = {
     *     id: #
     *     x: #,
     *     y: #,
     *     width: #,
     *     height: #
     * }
     * @property {Object}
     */
    var sLayers = [],
        labels = [],
        i,
        inheritedJSON,
        thisJSON;

    // serialize layers
    for (i = 0; i < this.layers.getSize(); i += 1) {
        sLayers.push(this.layers.get(i).stringify());
    }

    // serialize labels
    for (i = 0; i < this.labels.getSize(); i += 1) {
        labels.push(this.labels.get(i).stringify());
    }

    inheritedJSON = Shape.prototype.stringify.call(this);
    thisJSON = {
        canvas: this.canvas.getID(),
        layers: sLayers,
        labels: labels,
        connectAtMiddlePoints: this.getConnectAtMiddlePoints(),
        connectionType: this.getConnectionType(),
        parent: this.parent.getID()
    };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * Builds a custom shape based on the parameter <json>
 * @param {String} json
 * @chainable
 */
CustomShape.prototype.parseJSON = function (json) {
    this.initObject(json);
    return this;
};

/**
 * @class Segment
 * A class that represents a segment, a segment is defined with two points (`startPoint` and `enPoint`).
 * In the jCore library a segment is used as a the key part of connections, it has also the following characteristics:
 *
 * - Since a segment is used as part of a connection, it has neighbors (`previousNeighbor` and `nextNeighbor`).
 * - A segment is parallel to an axis if it forms part of a connection.
 * - A segment has a move handler to move the segment.
 * - A segment has info of other connections it has intersections with
 *
 * Some examples of usage:
 *
 *      // let's assume that we want to connect two shapes, the shapes are connected
 *      // through the creation of a segment (the start point is the mouse position where
 *      // the user fired the mouse down event and the end point is the mouse position where the user
 *      // fired the mouse up event)
 *      // let's assume that canvas is an instance of the class Canvas and it's creating the segment
 *      var redSegment = new Segment({
 *          startPoint: new Point(100, 100),        // a random point
 *          endPoint: new Point(200, 200),          // a random point
 *          parent: canvas,
 *          color: new Color(255, 0, 0)             // red !!
 *      });
 *
 * @extend JCoreObject
 *
 * @constructor Creates an instance of the class Segment
 * @param {Object} options Initialization options
 * @cfg {Point} [startPoint=new Point(0, 0)] The start point of the segment
 * @cfg {Point} [endPoint=new Point(0, 0)] The end point of the segment
 * @cfg {Canvas / Connection} [parent=null] The parent of the segment
 * @cfg {Color} [color=new Color(0, 0, 0)] The color of this segment
 */
Segment = function (options) {
    JCoreObject.call(this, options);

    /**
     * The parent of the segment.
     * @property {Canvas / Connection} [parent=null]
     */
    this.parent = null;
    /**
     * The start point of the segment.
     * @property {Point} [startPoint=null]
     */
    this.startPoint = null;

    /**
     * The end point of the segment.
     * @property {Point} [endPoint=null]
     */
    this.endPoint = null;

    /**
     * zOrder of the segment.
     * @property {number} [zOrder=Shape.prototype.MAX_ZINDEX]
     */
    this.zOrder = Shape.prototype.MAX_ZINDEX;

    /**
     * The segment to the left of this segment.
     * @property {Segment} [previousNeighbor=null]
     */
    this.previousNeighbor = null;

    /**
     * The segment to the right of this segment.
     * @property {Segment} [nextNeighbor=null]
     */
    this.nextNeighbor = null;

    /**
     * Orientation of the segment, the possible values are:
     *
     * - Vertical
     * - Horizontal
     *
     * @property {String} [orientation=""]
     */
    this.orientation = "";

    /**
     * The width of the segment.
     * @property {number} [width=1]
     */
    this.width = 1;

    /**
     * Graphics object
     * @property {Graphics} [graphics=null]
     */
    this.graphics = null;

    /**
     * This segment style, the possible values are:
     *
     * - "dotted"
     * - "segmented"
     * - "segmentdot"
     * @property {string} [segmentStyle=null]
     */
    this.segmentStyle = null;

    /**
     * This segment color.
     * @property {Color} [segmentColor=null]
     */
    this.segmentColor = null;

    /**
     * The move handler is the segment move handler of this segment.
     * @property {SegmentMoveHandler} [moveHandler=null]
     */
    this.moveHandler = null;

    /**
     * Creates an ArrayList of the intersections with other connections.
     *
     *      // the structure is like:
     *      //intersections = [
     *      //    {
     *      //        center: point of intersection,
     *      //        IdOtherConnection: id of the other connection
     *      //    }
     *      //]
     * @property {ArrayList} [intersections=new ArrayList()]
     */
    this.intersections = new ArrayList();

    /**
     * True if this segment has a move handler.
     * @property {boolean} [hasMoveHandler=false]
     */
    this.hasMoveHandler = false;

    // set defaults
    Segment.prototype.initObject.call(this, options);
};

Segment.prototype = new JCoreObject();

/**
 * The type of each instance of this class
 * @property {String}
 */
Segment.prototype.type = "Segment";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * @param {Object} options The object that contains the config
 * @private
 */
Segment.prototype.initObject = function (options) {
    /**
     * Default options for the constructor
     * @property {Object}
     */
    var defaults = {
        startPoint: new Point(0, 0),
        endPoint: new Point(0, 0),
        parent: null,
        color: new Color(0, 0, 0)
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // init
    this.setStartPoint(defaults.startPoint)
        .setEndPoint(defaults.endPoint)
        .setColor(defaults.color)
        .setParent(defaults.parent);
};

/**
 * Creates the HTML Representation of the Segment.
 * @returns {HTMLElement}
 */
Segment.prototype.createHTML = function () {
    this.html = document.createElement('div');
    this.html.id = this.id;
    this.html.style.position = "absolute";
    this.html.style.left = "0px";
    this.html.style.top = "0px";
    this.html.style.height = "0px";
    this.html.style.width = "0px";
    this.html.style.zIndex = this.zOrder;
    return this.html;
};

/**
 * Paints a segment by creating an instance of the class {@link Graphics} and
 * calling {@link Graphics#drawLine}, it also append it's HTML to its parent's HTML.
 * @chainable
 */
Segment.prototype.paint = function () {
    if (this.getHTML() === null) {
        return this;
    }
    if (this.graphics === null) {
        this.graphics = new Graphics(this.html);
    }
    //dibujas linea llamar a drawLine de la clase graphics con los puntos
    this.graphics.drawLine(this.startPoint.x, this.startPoint.y,
        this.endPoint.x, this.endPoint.y, this.segmentStyle, this.segmentColor);
    this.parent.html.appendChild(this.html);
    return this;
};

/**
 * Removes its HTML from the DOM.
 * @chainable
 */
Segment.prototype.destroy = function () {
    $(this.html).remove();
    return this;
};

/**
 * Paint this segment with the intersections it has stored (this method is called from
 * {@link Connection#checkAndCreateIntersectionsWithAll}), it also append it's HTML to its parent's HTML.
 * @chainable
 */
Segment.prototype.paintWithIntersections = function () {

    // we have to paint the segment again so destroy the previous one
    this.destroy();

    var startPoint,
        endPoint,
        diff,
        i,
        reverse = false;

    if (this.getHTML() === null) {
        return this;
    }
    if (this.graphics === null) {
        this.graphics = new Graphics(this.html);
    }

    //console.log(this.hasMoveHandler);
    if (this.hasMoveHandler) {
        $(this.moveHandler.html).remove();
        this.addSegmentMoveHandler();
    }


    // default differentials to split the segment
    if (this.orientation === this.HORIZONTAL) {
        diff = new Point(Shape.prototype.DEFAULT_RADIUS, 0);
        if (this.startPoint.x > this.endPoint.x) {
            reverse = true;
        }

        // for this to work we need to sort the intersections
        this.intersections.sort(function (i, j) {
            return i.center.x >= j.center.x;
        });

    } else {
        diff = new Point(0, Shape.prototype.DEFAULT_RADIUS);
        if (this.startPoint.y > this.endPoint.y) {
            reverse = true;
        }

        // for this to work we need to sort the intersections
        this.intersections.sort(function (i, j) {
            return i.center.y >= j.center.y;
        });
    }
    this.graphics.graphics.clear();

    startPoint = this.startPoint.clone();
    for (i = 0; i < this.intersections.getSize(); i += 1) {
        // if the direction is reverse then we get the
        // inverse position for i in the array
        if (reverse) {
            endPoint = this.intersections
                .get(this.intersections.getSize() - i - 1).center;
        } else {
            endPoint = this.intersections.get(i).center;
        }

        if (reverse) {
            endPoint = endPoint.add(diff);
        } else {
            endPoint = endPoint.subtract(diff);
        }
        this.graphics.drawLine(startPoint.x, startPoint.y,
            endPoint.x, endPoint.y, this.segmentStyle,
            this.segmentColor, 0, 0, true);
        if (reverse) {
            startPoint = endPoint.subtract(diff.multiply(2));
        } else {
            startPoint = endPoint.add(diff.multiply(2));
        }
    }

    // draw last segment
    endPoint = this.endPoint.clone();
    this.graphics.drawLine(startPoint.x, startPoint.y,
        endPoint.x, endPoint.y, this.segmentStyle, this.segmentColor,
        0, 0, true);
    this.parent.html.appendChild(this.html);
    return this;
};

/**
 * Adds a segmentMoveHandler to this segment, it also append the segmentMoveHandler instance HTML to this HTML
 * @chainable
 */
Segment.prototype.addSegmentMoveHandler = function () {
    var midX = (this.startPoint.x + this.endPoint.x) / 2,
        midY = (this.startPoint.y + this.endPoint.y) / 2;
    this.moveHandler = new SegmentMoveHandler({
        parent: this,
        orientation: this.orientation,
        style: {
            cssProperties: {
                border: "1px solid black"
            }
        }
    });
    midX -= this.moveHandler.width / 2;
    midY -= this.moveHandler.height / 2;
    this.moveHandler.setPosition(midX, midY);
    this.html.appendChild(this.moveHandler.getHTML());
    this.moveHandler.paint();
    this.moveHandler.attachListeners(this.moveHandler);
    return this;
};

/**
* Returns the parent of the segment
* @returns {Canvas / Connection}
*/
Segment.prototype.getParent = function () {
    return this.parent;
};

/**
 * Returns the start point of the segment.
 * @returns {Point}
 */
Segment.prototype.getStartPoint = function () {
    return this.startPoint;
};

/**
 * Returns the end point of the segment.
 * @returns {Point}
 */
Segment.prototype.getEndPoint = function () {
    return this.endPoint;
};

/**
* Sets the parent of the segment.
* @param {Object} newParent
* @chainable
*/
Segment.prototype.setParent = function (newParent) {
    this.parent = newParent;
    return this;
};

/**
* Sets the start point of the segment.
* @param {Point} newPoint
* @chainable
*/
Segment.prototype.setStartPoint = function (newPoint) {
    this.startPoint = newPoint;
    return this;
};

/**
 * Sets the end point of the segment.
 * @param {Point} newPoint
 * @chainable
 */
Segment.prototype.setEndPoint = function (newPoint) {
    this.endPoint = newPoint;
    return this;
};

/**
 * Sets the segmentStyle of this segment
 * @param {string} newStyle
 * @chainable
 *
 */
Segment.prototype.setStyle = function (newStyle) {
    this.segmentStyle = newStyle;
    return this;
};

/**
 * Sets the color of this segment
 * @param {Color} newColor
 * @chainable
 */
Segment.prototype.setColor = function (newColor) {
    this.segmentColor = newColor;
    return this;
};

/**
 * Creates an intersection with `otherSegment` and saves it in `this.intersections`.
 * If it doesn't have an intersection point passed as a parameter it will determine the
 * intersection point and add it to `this.intersections` (`this.intersections` considers only unique points)
 * @param {Segment} otherSegment
 * @param {Point} [ip] Intersection Point
 * @chainable
 */
Segment.prototype.createIntersectionWith = function (otherSegment, ip) {
    var intersectionObject,
        intersectionPoint,
        i,
        goodToInsert = true;
    if (ip) {
        intersectionPoint = ip;
    } else {
        intersectionPoint = Geometry.segmentIntersectionPoint(this.startPoint,
            this.endPoint, otherSegment.startPoint, otherSegment.endPoint);
    }

    // let's consider the case when an intersection point is the same i.e. when a segment crosses two
    // other segments in the same point
    for (i = 0; i < this.intersections.getSize(); i += 1) {
        if (ip.equals(this.intersections.get(i).center)) {
            goodToInsert = false;
        }
    }

    if (goodToInsert) {
        intersectionObject = new Intersection(intersectionPoint,
            otherSegment.parent.getID(), this);
        this.html.appendChild(intersectionObject.getHTML());
        intersectionObject.paint();
        this.intersections.insert(intersectionObject);
    }

    //console.log(intersectionObject);
    //console.log(this.intersections);
    return this;
};

/**
 * Clear all the intersections in this segment.
 * @chainable
 */
Segment.prototype.clearIntersections = function () {
    var i,
        intersection,
        size = this.intersections.getSize();
    while (size > 0) {
        intersection = this.intersections.get(size - 1);
        $(intersection.html).remove();
        this.intersections.popLast();
        size -= 1;
    }
    return this;
};

/**
 * Moves the segment either to x or y but not both (this method is called from {@link SegmentMoveHandler#event-drag}).
 * @param {number} x new x coordinate of the segment in the canvas
 * @param {number} y new y coordinate of the segment in the canvas
 */
Segment.prototype.moveSegment = function (x, y) {
    var handler = this.moveHandler,
        prevNeighbor = this.previousNeighbor,
        nextNeighbor = this.nextNeighbor,
        midX,
        midY;

    if (handler.orientation === handler.VERTICAL) {
        this.startPoint.x = x
            + handler.width / 2;
        this.endPoint.x = x
            + handler.width / 2;
        prevNeighbor.endPoint.x =
            this.startPoint.x;
        nextNeighbor.startPoint.x =
            this.endPoint.x;
    } else {
        this.startPoint.y = y
            + handler.height / 2;
        this.endPoint.y = y
            + handler.height / 2;
        prevNeighbor.endPoint.y =
            this.startPoint.y;
        nextNeighbor.startPoint.y =
            this.endPoint.y;
    }

    // fix handler for the this segment
    if (this.moveHandler) {     // of course yes!
        midX = (this.startPoint.x + this.endPoint.x) / 2
            - this.moveHandler.width / 2;
        midY = (this.startPoint.y + this.endPoint.y) / 2
            - this.moveHandler.height / 2;
        this.moveHandler.setPosition(midX, midY);
    }

    // paint the previous segment
    prevNeighbor.paint();
    // fix handler for the prev segment if possible
    if (prevNeighbor.moveHandler) {
        midX = (prevNeighbor.startPoint.x + prevNeighbor.endPoint.x) / 2
            - prevNeighbor.moveHandler.width / 2;
        midY = (prevNeighbor.startPoint.y + prevNeighbor.endPoint.y) / 2
            - prevNeighbor.moveHandler.height / 2;
        prevNeighbor.moveHandler.setPosition(midX, midY);
    }

    // paint the next segment
    nextNeighbor.paint();
    // fix moveHandler for the next segment if possible
    if (nextNeighbor.moveHandler) {
        midX = (nextNeighbor.startPoint.x + nextNeighbor.endPoint.x) / 2
            - nextNeighbor.moveHandler.width / 2;
        midY = (nextNeighbor.startPoint.y + nextNeighbor.endPoint.y) / 2
            - nextNeighbor.moveHandler.height / 2;
        nextNeighbor.moveHandler.setPosition(midX, midY);
    }

    this.paint();
    return this;
};

/**
 * @abstract
 * @class RegularShape
 * @extend Shape
 * The class RegularShape represents all
 * regular shapes created in the canvas such as, rectangles, ovals, ports, and
 * handlers
 *
 * This class will hold all the common behavior of regular shapes
 * like rectangles or ovals
 *
 * @constructor
 * Initializes a regular shape
 */
RegularShape = function (options) {
    Shape.call(this, options);

    /**
     * color of the shape
     * @property {Color}
     */
    this.color = new Color();

    /**
     * Graphics for this regular shape
     */
    this.graphics = null;
};

RegularShape.prototype = new Shape();

/**
 * Type of the shape
 * @property {String}
 */
RegularShape.prototype.type = "RegularShape";

//getters
/**
 * Returns the color of the shape
 * @returns {Color}
 */
RegularShape.prototype.getColor = function () {
    return this.color;
};

/**
 * Sets the color of the shape
 * @returns {RegularShape}
 * @param {Color} newColor
 */
RegularShape.prototype.setColor = function (newColor) {
    if (newColor.type && newColor.type === "Color") {
        this.color = newColor;
    }
    return this;
};

/**
 * @class Polygon
 * Abstract class polygon to draw simple poly-lines
 *
 * An example of usage:
 *
 *      var polygon = new Polygon({
 *          points: []
 *      });
 *
 * @extend RegularShape
 *
 * @constructor Creates an instance of the class Polygon
 * @param {Object} options Initialization options
 * @cfg {Array} [points=[]] The points that make the polygon
 */
Polygon = function (options) {

    RegularShape.call(this, options);

    /**
     * The points representing this polygon
     * @property {Array}
     */
    this.points = null;

    Polygon.prototype.initObject.call(this, options);
};

Polygon.prototype = new RegularShape();

/**
 * The type of each instance of this class
 * @property {String}
 */
Polygon.prototype.type = "Polygon";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
Polygon.prototype.initObject = function (options) {
    var defaults = {
        points: []
    };
    $.extend(true, defaults, options);
    this.setPoints(defaults.points);
};

/**
 * Sets the points of this polygon
 * @param {Array} newPoints
 * @chainable
 */
Polygon.prototype.setPoints = function (newPoints) {
    var i, point;
    this.points = [];
    for (i = 0; i < newPoints.length; i += 1) {
        point = newPoints[i];
        this.points.push(new Point(point.getX(), point.getY()));
    }
};

/**
 * Gets the points of this polygon
 * @return {Array}
 */
Polygon.prototype.getPoints = function () {
    return this.points;
};


/**
 * @class Rectangle
 * A regular shape that represents a rectangle, in the jCore framework instances of the class Rectangle
 * are used to represent a resize handler and a segment move handler.
 *
 * Some examples of use:
 *
 *      var rectangle = new Rectangle();
 *
 * @extend Polygon
 *
 * @constructor Creates an instance of the class Rectangle
 * @param {Object} options Initialization options (currently there are no initialization options)
 */
Rectangle = function (options) {
    Polygon.call(this, options);
    Rectangle.prototype.initObject.call(this, options);
};

Rectangle.prototype = new Polygon();

/**
 * The type of each instance of this class
 * @property {String}
 */
Rectangle.prototype.type = "Rectangle";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
Rectangle.prototype.initObject = function (options) {
};

/**
 * Paints the rectangle applying the predefined style and adding a background color if
 * it's possible (it's possible if this rectangle has an instance of the class Color).
 * @chainable
 */
Rectangle.prototype.paint = function () {
    if (this.html) {
        // apply predefined style
        this.style.applyStyle();

        if (this.color) {
            this.style.addProperties({
                backgroundColor: this.color.getCSS()
            });
        }
    }
    return this;
};

/**
 * Creates the HTML representation of the Rectangle
 * @returns {HTMLElement}
 */
Rectangle.prototype.createHTML = function () {
    Shape.prototype.createHTML.call(this);
    return this.html;
};

/**
 * @class Oval
 * A regular shape that represents an oval, in the jCore framework instances of the class Oval
 * are used to represent a Port.
 *
 * Some examples of use:
 *
 *      var oval = new Oval({
 *          width: 8,
 *          height: 8,
 *          center: new Point(100, 100)
 *      });
 *
 * @extend RegularShape
 *
 * @constructor Creates an instance of the class Oval
 * @param {Object} options Initialization options
 * @cfg {number} [width=4] The width of this oval
 * @cfg {number} [height=4] The height of this oval
 * @cfg {number} [center=new Center(0, 0)] The center of this oval
 */
Oval = function (options) {
    RegularShape.call(this, options);

    Oval.prototype.initObject.call(this, options);
};

Oval.prototype = new RegularShape();

/**
 * The type of each instance of this class
 * @property {String} [type=Oval]
 */
Oval.prototype.type = "Oval";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} options The object that contains the config
 * @private
 */
Oval.prototype.initObject = function (options) {
    /**
     * Default options for the object
     * @property {Object}
     */
    var defaults = {
        center: new Point(0, 0),
        width : 4,
        height : 4
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // call setters using the defaults object
    this.setCenter(defaults.center)
        .setWidth(defaults.width)
        .setHeight(defaults.height);
};

/**
 * Paints a **red** oval using the configuration options (the HTML is not appended to
 * the DOM)
 * @chainable
 */
Oval.prototype.paint = function () {

    // show or hide the oval
    this.setVisible(this.visible);

    if (this.html) {
        // apply predefined style
        this.style.applyStyle();

//        this.setOpacity(8);
        this.graphic = new JSGraphics(this.id);
        //this.graphic.setColor('#40CA09');
        this.graphic.setColor('red');
        this.graphic.fillOval(0, 0, this.getWidth(), this.getHeight());
        this.graphic.paint();
    }
    return this;
};

/**
 * Creates the HTML representation of the Oval
 * @returns {HTMLElement}
 */
Oval.prototype.createHTML = function () {

    Shape.prototype.createHTML.call(this);
//  this.html.style.backgroundColor = this.color.getCSS();
    return this.html;
    //return this;
};
/**
 * Set the oval Color
 * @param {String} newColor
 * @chainable
 */
Oval.prototype.setColor = function(newColor) {
    this.graphic.setColor(newColor);
    this.graphic.fillOval(0, 0, this.getWidth(), this.getHeight());
    this.graphic.paint();
    return this;
}

/**
 * @class Arc
 * @extend RegularShape
 * Class arc that draws arcs using the HTMLElement draw engine.
 * Since the canvas is inverted in the y-axis the angles are:
 *      TOP    270
 *      RIGHT  0
 *      BOTTOM 90
 *      LEFT   180
 * An arc can be defined with the following elements:
 *
 * - *startAngle* start angle `0 <= startAngle < 360`.
 * - *endAngle* end angle `0 <= endAngle < 360`.
 * - *radius* the radius of the circle.
 *
 * Besides, the HTMLElement draw engine needs another parameter called *step*, this field tells the engine to
 * draw only at '*step*' steps
 *      i.e.
 *      startAngle = 90
 *      endAngle = 150
 *      engine.paint() with step = 10:
 *          90, 100, 110, 120, 130, 140, 150
 *      engine.paint() with step = 20:
 *          90, 110, 130, 150
 * As a consequence of the y-axis being inverted,we start drawing from the end angle towards the start angle,
 * therefore to draw an arc from 0 deg to 90 deg we must invert the parameters
 *      var a = new Arc({
 *          center: new Point(10, 10),
 *          radius: 200,
 *          startAngle: 270,
 *          endAngle: 0
 *      });
 *
 * @param {Object} options Initialization options
 * @cfg {Point} [center=new Points(0, 0)] Point representing the center of the arc
 * @cfg {number} [radius=Shape.prototype.DEFAULT_RADIUS] radius of the arc
 * @cfg {number} [startAngle=270] start angle of the arc
 * @cfg {number} [endAngle=90] end angle of the arc
 * @cfg {number} [step=10] steps to jump from end angle (to get to start angle)
 * @constructor Creates a new instance of arc
 */
Arc = function (options) {
    RegularShape.call(this);

    /**
     * Start angle of this arc
     * @property {number}
     */
    this.startAngle = null;

    /**
     * End angle of this arc
     * @property {number}
     */
    this.endAngle = null;

    /**
     * Radius of the arc
     * @property {number}
     */
    this.radius = null;

    /**
     * Steps to draw the arc
     * @property {number}
     */
    this.step = null;

    // set defaults
    Arc.prototype.initObject.call(this, options);
};

Arc.prototype = new RegularShape();

/**
 * Type of this shape
 * @property {String}
 */
Arc.prototype.type = "Arc";

/**
 * Instance initializer which uses options to extend the config options to
 * initialize the instance
 * @private
 * @param {Object} options
 */
Arc.prototype.initObject = function (options) {

    // Default options for the object
    var defaults = {
        center: new Point(0, 0),
        radius: Shape.prototype.DEFAULT_RADIUS,
        startAngle: 270,
        endAngle: 90,
        step: 10
    };

    // extend recursively defaults with the given options
    $.extend(true, defaults, options);

    // call setters using the defaults object
    this.setCenter(defaults.center)
        .setStartAngle(defaults.startAngle)
        .setEndAngle(defaults.endAngle)
        .setRadius(defaults.radius)
        .setStep(defaults.step);

    // change the id (to debug easier)
    this.id += "-ARC";
};

/**
 * In charge of the painting / positioning of the figure on
 * the DOM and setting the styles
 * @chainable
 */
Arc.prototype.paint = function () {

    this.setVisible(this.visible);

    if (this.html) {
        this.style.applyStyle();
        // this.graphic is inherited from RegularShape
        this.graphics = new Graphics(this.id);
        this.graphics.setColor("black");
        this.graphics.drawArc(this.center.x, this.center.y, this.radius,
            this.startAngle, this.endAngle, this.step);
        this.graphics.graphics.paint();
    }
    return this;
};

/**
 * Creates the HTML representation of the Arc
 * @returns {HTMLElement}
 */
Arc.prototype.createHTML = function () {
    Shape.prototype.createHTML.call(this);
    return this.html;
};

/**
 * Returns the startAngle of the arc
 * @returns {number}
 */
Arc.prototype.getStartAngle = function () {
    return this.startAngle;
};

/**
 * Sets the startAngle of the arc
 * @param {number} newAngle
 * @chainable
 */
Arc.prototype.setStartAngle = function (newAngle) {
    this.startAngle = newAngle;
    return this;
};

/**
 * Returns the endAngle of the arc
 * @returns {number}
 */
Arc.prototype.getEndAngle = function () {
    return this.endAngle;
};

/**
 * Sets the endAngle of the arc
 * @param {number} newAngle
 * @chainable
 */
Arc.prototype.setEndAngle = function (newAngle) {
    this.endAngle = newAngle;
    return this;
};

/**
 * Returns the radius of the arc
 * @returns {number}
 */
Arc.prototype.getRadius = function () {
    return this.radius;
};

/**
 * Sets the radius of the arc
 * @param {number} newRadius
 * @chainable
 */
Arc.prototype.setRadius = function (newRadius) {
    this.radius = newRadius;
    return this;
};

/**
 * Returns the radius of the arc
 * @returns {number}
 */
Arc.prototype.getStep = function () {
    return this.step;
};

/**
 * Sets the step to draw the arc (steps jumped from startAngle to endAngle)
 * @param {number} newStep
 * @chainable
 */
Arc.prototype.setStep = function (newStep) {
    this.step = newStep;
    return this;
};

/**
 * @class MultipleSelectionContainer
 * Represents the rectangle created to do multiple selection after firing {@link Canvas#event-mousedown} and
 * dragging a rectangle over the desired elements in the canvas and firing {@link Canvas#event-mouseup},
 * currently it can only select shapes that are direct children of the canvas.
 *
 * An example of use:
 *
 *      // let's assume that canvas is an instance of the class Canvas
 *      var multipleSelectionContainer = new MultipleSelectionContainer(canvas);
 *
 * @extend Rectangle
 *
 * @constructor Creates an instance of the class MultipleSelectionContainer
 * @param {Canvas} canvas
 */
MultipleSelectionContainer = function (canvas) {
    RegularShape.call(this);

    /**
     * The background color of this element
     * @property {Color}
     */
    this.backgroundColor = null;

    /**
     * Reference to the canvas
     * @property {Canvas}
     */
    this.canvas = null;

    // init object
    MultipleSelectionContainer.prototype.initObject.call(this, canvas);
};

MultipleSelectionContainer.prototype = new Rectangle();

/**
 * Type of each instance of this class
 * @property {String}
 */
MultipleSelectionContainer.prototype.type = "MultipleSelectionContainer";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Canvas} canvas The canvas of this multiple selection container
 * @private
 */
MultipleSelectionContainer.prototype.initObject = function (canvas) {
    this.backgroundColor = new Color(0, 128, 255, 0.1);     // light blue
    this.canvas = canvas;
    // add this element to the canvas
    this.canvas.addElement(this, 0, 0, true);
};

/**
 * Paints the multiple selection container with the color *light blue* (defined in initObject)
 * @chainable
 */
MultipleSelectionContainer.prototype.paint = function () {
    this.style.addProperties({
        backgroundColor: this.backgroundColor.getCSS()
    });
    return this;
};

/**
 * Changes the opacity of this multiple selection container (and repaints it later).
 * @param {number} value
 * @chainable
 */
MultipleSelectionContainer.prototype.changeOpacity = function (value) {
    this.backgroundColor.setOpacity(value);
    this.paint();
    return this;
};

/**
 * Wraps the direct children of the canvas. To call this method it's assumed that this instance has a position
 * and a dimension in the canvas (this method is called from {@link Canvas#event-mouseup}).
 * It executes the following actions:
 *
 * 1. Gathers the currentSelection
 * 2. Checks which direct children of the canvas are inside the selection
 *      (done through {@link MultipleSelectionContainer#intersectElements}).
 * 3. Fires {@link Canvas#triggerSelectEvent} using the new `this.canvas.currentSelection`
 * 4. Resets the state of this instance
 *
 * @chainable
 */
MultipleSelectionContainer.prototype.wrapElements = function () {
    var currentSelection = this.canvas.currentSelection,
        selection = [];
    this.intersectElements();
    if (!currentSelection.isEmpty()) {
        selection = currentSelection.asArray();
        this.canvas.triggerSelectEvent(selection);
    }
    this.reset();
    this.setVisible(false);
    return this;
};

/**
 * Checks which direct children of the canvas are inside `this` (represented as a rectangle in the canvas).
 * The steps are:
 *
 * 1. Empty `this.canvas.currentSelection` by calling {@link Canvas#emptyCurrentSelection}.
 * 2. If a child is inside this rectangle then it's added to `this.canvas.currentSelection`.
 *
 * @chainable
 */
MultipleSelectionContainer.prototype.intersectElements = function () {
    var i,
        shape,
        children;

    //empty the current selection
    this.canvas.emptyCurrentSelection();

    // get all the customShapes
    children = this.canvas.customShapes;
    for (i = 0; i < children.getSize(); i += 1) {
        shape = children.get(i);
        if (shape.parent.family === "Canvas" && this.checkIntersection(shape)) {
            this.canvas.addToSelection(shape);
        }
    }
    return this;
};

/**
 * Resets the position and dimensions of this selection container.
 * @chainable
 */
MultipleSelectionContainer.prototype.reset = function () {
    this.setPosition(0, 0);
    this.setDimension(0, 0);
    return this;
};

/**
 * Alias for {@link JCoreObject#getAbsoluteX}.
 * @property {Function} getLeft
 */
MultipleSelectionContainer.prototype.getLeft = Shape.prototype.getAbsoluteX;

/**
 * Alias for {@link JCoreObject#getAbsoluteY}.
 * @property {Function} getTop
 */
MultipleSelectionContainer.prototype.getTop = Shape.prototype.getAbsoluteY;

/**
 * Checks if `shape` is inside `this`, `shape` is inside `this` if one of its corners
 * its inside `this`.
 * @param {Shape} shape
 * @return {boolean}
 */
MultipleSelectionContainer.prototype.checkIntersection = function (shape) {
    var topLeft = new Point(this.zoomX, this.zoomY),
        bottomRight = new Point(this.zoomX + this.zoomWidth,
                this.zoomY + this.zoomHeight);
    return Geometry.pointInRectangle(new Point(shape.getZoomX(), shape.getZoomY()),
        topLeft, bottomRight) ||
        Geometry.pointInRectangle(new Point(shape.zoomX +
            shape.zoomWidth, shape.zoomY), topLeft, bottomRight) ||
        Geometry.pointInRectangle(new Point(shape.zoomX, shape.zoomY +
            shape.zoomHeight), topLeft, bottomRight) ||
        Geometry.pointInRectangle(new Point(shape.zoomX +
            shape.zoomWidth, shape.zoomY + shape.zoomHeight), topLeft, bottomRight);
};

/**
 * @class Intersection
 * An intersection in the designer is defined as an arc which has only one additional property: `idOtherConnection`
 * and it's the ID of the other connection this segment has intersection with.
 *
 * All the intersection of a segment are stored in `segment.intersections`.
 *
 * An example of instantiation:
 *
 *      // let's assume that 'segment' is an instance of the class Segment
 *      // let's assume that 'otherSegment' is an instance of the class Segment
 *      // let's assume that 'segment' has an intersection with 'otherSegment' at 'ip' (intersection point)
 *      var intersection = new Intersection(
 *          ip,
 *          otherSegment.parent,getID(),
 *          segment
 *      );
 *
 * @extends Arc
 *
 * @constructor Creates an instance of the class Intersection
 * @param {Point} center
 * @param {string} idOtherConnection
 * @param {Segment} parent
 */
Intersection = function (center, idOtherConnection, parent) {

    Arc.call(this);
    /**
     * The center of the arc
     * @property {Point} [center=null]
     */
    this.center = (!center) ? null : center;
    /**
     * Visibility of this arc
     * @property {boolean}
     */
    this.visible = true;
    /**
     * Parent of this intersection is a segment
     * @property {Segment}
     */
    this.parent = parent;
    /**
     * Id of the other connection
     * @property {String}
     */
    this.idOtherConnection = idOtherConnection;
};

Intersection.prototype = new Arc();

/**
 * The type of each instance of the class Intersection
 * @property {String}
 */
Intersection.prototype.type = "Intersection";

/**
 * Paints this intersection (calling `Arc.paint()`) considering the orientation of its parent.
 *
 * It overwrites the properties `startAngle` and `endAngle` inherited from {@link Arc}
 * according to the orientation of its parent (segment), the calculation is as follows:
 *
 * - Segment is vertical
 *      - startAngle = 270
 *      - endAngle = 90
 * - Segment is horizontal
 *      - startAngle = 180
 *      - endAngle = 0
 *
 * @chainable
 */
Intersection.prototype.paint = function () {

    // NOTE: it's always visible so do not call setVisible()

    if (this.parent.orientation === this.VERTICAL) {
        this.startAngle = 270;
        this.endAngle = 90;
    } else {
        this.startAngle = 180;
        this.endAngle = 0;
    }

    // call the representation (always an arc)
    Arc.prototype.paint.call(this);

    // apply predefined style
    this.style.applyStyle();

    return this;
};

/**
 * Destroys the intersection by removing its HTML from the DOM.
 * @chainable
 */
Intersection.prototype.destroy = function () {
    $(this.html).remove();
    return this;
};

/**
 * Creates the HTML representation of the Intersection.
 * @returns {HTMLElement}
 */
Intersection.prototype.createHTML = function () {
    Shape.prototype.createHTML.call(this);
    return this.html;
};

/**
 * @class Snapper
 * Class snapper represents the helper shown while moving shapes.
 * @extend JCoreObject
 *
 * @constructor Creates an instance of the class Snapper
 * @param {Object} options Initialization options
 * @cfg {Point} [orientation="horizontal"] The default orientation of this snapper
 */
Snapper = function (options) {

    JCoreObject.call(this, options);

    /**
     * Orientation of this snapper, it can be either "horizontal" or "vertical".
     * @property {string} [orientation=null]
     */
    this.orientation = null;

    /**
     * Data saved to define the positioning of this snapper in the canvas.
     * @property {Array} [data=[]]
     */
    this.data = [];

    /**
     * The visibility of this snapper.
     * @property {boolean} [visible=false]
     */
    this.visible = false;

    Snapper.prototype.initObject.call(this, options);
};

Snapper.prototype = new JCoreObject();

/**
 * The type of each instance of this class
 * @property {String}
 */
Snapper.prototype.type = "Snapper";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * @param {Object} options The object that contains the config
 * @private
 */
Snapper.prototype.initObject = function (options) {

    var defaults = {
        orientation: "horizontal"
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // call setters using the defaults object
    this.setOrientation(defaults.orientation);
    this.setDimension(defaults.width,defaults.height);

    // create the html (it's hidden initially)
    this.createHTML();
    this.hide();
};

/**
 * Creates the HTML representation of the snapper.
 * @returns {HTMLElement}
 */
Snapper.prototype.createHTML = function () {
    JCoreObject.prototype.createHTML.call(this);
    $(this.canvas.getHTML()).append(this.html);
    this.setZOrder(99);
    this.html.className = 'custom-snapper';

    if(this.getOrientation() == 'horizontal') {
        this.html.id = 'guide-h';
        this.html.style.borderTop = '1px dashed #55f';
        this.html.style.width = '100%';
    } else {
        this.html.id = 'guide-v';
        this.html.style.borderLeft = '1px dashed #55f';
        this.html.style.height = '100%';
    }
    return this.html;
};

/**
 * Hides the snapper.
 * @chainable
 */
Snapper.prototype.hide = function () {
    this.visible = false;
    this.setVisible(this.visible);
    return this;
};

/**
 * Shows the snapper.
 * @chainable
 */
Snapper.prototype.show = function () {
    this.visible = true;
    this.setVisible(this.visible);
    return this;
};

/**
 * Fills the data for the snapper (using customShapes and regularShapes).
 * The data considered for each shape is:
 *
 * - Its absoluteX
 * - Its absoluteY
 * - Its absoluteX + width
 * - Its absoluteY + height
 *
 * @chainable
 */
Snapper.prototype.createSnapData = function () {
    var i,
        index = 0,
        shape,
        border = 0;

    // clear the data before populating it
    this.data = [];

//    console.log("Sizes:");
//    console.log(this.canvas.customShapes.getSize());
//    console.log(this.canvas.regularShapes.getSize());

    // populate the data array using the customShapes
    for (i = 0; i < this.canvas.customShapes.getSize(); i += 1) {
        shape = this.canvas.customShapes.get(i);
        if (!this.canvas.currentSelection.find('id', shape.getID())) {
            border = parseInt($(shape.getHTML()).css('borderTopWidth'), 10);
            if (this.orientation === 'horizontal') {
                this.data[index * 2] = shape.getAbsoluteY() - border;
                this.data[index * 2 + 1] = shape.getAbsoluteY() + shape.getZoomHeight();
            } else {
                this.data[index * 2] = shape.getAbsoluteX() - border;
                this.data[index * 2 + 1] = shape.getAbsoluteX() + shape.getZoomWidth();
            }
            index += 1;
        }

    }

    // populate the data array using the regularShapes
    for (i = 0; i < this.canvas.regularShapes.getSize(); i += 1) {
        shape = this.canvas.regularShapes.get(i);
        border = parseInt($(shape.getHTML()).css('borderTopWidth'), 10);
        if (this.orientation === 'horizontal') {
            this.data[index * 2] = shape.getAbsoluteY() - border;
            this.data[index * 2 + 1] = shape.getAbsoluteY() +
                shape.getZoomHeight();
        } else {
            this.data[index * 2] = shape.getAbsoluteX() - border;
            this.data[index * 2 + 1] = shape.getAbsoluteX() +
                shape.getZoomWidth();
        }
        index += 1;
    }
    return this;
};

/**
 * Sorts the data using the builtin `sort()` function, so that there's an strictly increasing order.
 * @chainable
 */
Snapper.prototype.sortData = function () {
    this.data.sort(function (a, b) {
        return a > b;
    });
    return this;
};

/**
 * Performs a binary search for `value` in `this.data`, return true if `value` was found in the data.
 * @param {number} value
 * @return {boolean}
 */
Snapper.prototype.binarySearch = function (value) {
    var low = 0,
        up = this.data.length - 1,
        mid;

    while (low <= up) {
        mid = parseInt((low + up) / 2, 10);
        if (this.data[mid] === value) {
            return value;
        }
        if (this.data[mid] > value) {
            up = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return false;
};

/**
 * Attaches listeners to this snapper, currently it only has the
 * mouseMove event which hides the snapper.
 * @param {Snapper} snapper
 * @chainable
 */
Snapper.prototype.attachListeners = function (snapper) {
    var $snapper = $(snapper.html).mousemove(
        function () {
            snapper.hide();
        }
    );
    return this;
};

/**
 * Sets the orientation of this snapper.
 * @param {string} orientation
 * @chainable
 */
Snapper.prototype.setOrientation = function (orientation) {
    if (orientation === "horizontal" || orientation === "vertical") {
        this.orientation = orientation;
    } else {
        throw new Error("setOrientation(): parameter is not valid");
    }
    return this;
};

/**
 * Gets the orientation of this snapper.
 * @return {string}
 */
Snapper.prototype.getOrientation = function () {
    return this.orientation;
};

/**
 * @class ReadOnlyLayer
 * Layer used to give the canvas a readonly state so that the user can just look
 * at the diagram and not be able to perform any modification,
 * the canvas is in charge of instantiating this object when its property
 * readOnly is set to true, there is no need to instance this object
 * independently
 * @extends JCoreObject
 *
 * @constructor
 * Creates an instance of this class
 * @param {Object} options configuration options inherited from JCoreObject
 */

ReadOnlyLayer = function (options) {
    JCoreObject.call(this, options);
    ReadOnlyLayer.prototype.initObject.call(this, options);
};

ReadOnlyLayer.prototype = new JCoreObject();
/**
 * Creates the HTML and attach the event listeners
 * @param options
 */
ReadOnlyLayer.prototype.initObject = function (options) {
    this.createHTML();
    this.attachListeners();
};
/**
 * Attach the event listeners necessary for blocking interactions
 */
ReadOnlyLayer.prototype.attachListeners = function () {
    var $layer = $(this.html);
    $layer.on('mousedown', this.onMouseDown(this))
        .on('mouseup', this.onMouseUp(this))
        .on('mousemove', this.onMouseMove(this))
        .on('click', this.onClick(this))
        .droppable({
            accept : "*",
            greedy : true,
            onDrop : function () {
                return false;
            }
        });
};
/**
 * Stops the propagation of the mousedown event
 * @param {ReadOnlyLayer} layer
 * @return {Function}
 */
ReadOnlyLayer.prototype.onMouseDown = function (layer) {
    return function (e, ui) {
        e.stopPropagation();
    };
};
/**
 * Stops the propagation of the mouseup event
 * @param {ReadOnlyLayer} layer
 * @return {Function}
 */
ReadOnlyLayer.prototype.onMouseUp = function (layer) {
    return function (e, ui) {
        e.stopPropagation();
    };
};
/**
 * Stops the propagation of the click event
 * @param {ReadOnlyLayer}layer
 * @return {Function}
 */
ReadOnlyLayer.prototype.onClick = function (layer) {
    return function (e, ui) {
        e.stopPropagation();
    };
};
/**
 * Stops the propagation of the mousemove event
 * @param {ReadOnlyLayer} layer
 * @return {Function}
 */
ReadOnlyLayer.prototype.onMouseMove = function (layer) {
    return function (e, ui) {
        e.stopPropagation();
    };
};


/**
 * @class Canvas
 * Is the object where all the shapes and drawings will be placed on, in addition it handles zoom operations
 * and also the triggering of events.
 *
 * Below are some unique characteristics of the instances of this class:
 *
 * - Each instance of this class has an instance of the following:
 *      - {@link CommandStack Command stack}
 *      - {@link Snapper Two snappers} (one horizontal snapper and one vertical snapper).
 *      - {@link MultipleSelectionContainer} to select multiple shapes.
 *      - {@link Segment}. To create connections between shapes.
 *      - {@link Canvas#property-customShapes CustomShapes arrayList}. To save all the custom shapes
 *          created in this canvas.
 *      - {@link Canvas#property-connections Connections arrayList}. To save all the connections
 *          created in this canvas.
 *      - {@link Canvas#property-currentSelection Current selection arrayList}. To save all the custom shapes
 *          that are select (by clicking, ctrl clicking them or selecting them using the
 *          multipleSelectionContainer instance).
 *      - {@link Canvas#property-currentConnection Current connection}. A pointer to the selected
 *          connection.
 *      - {@link Canvas#property-currentLabel Current label}. A pointer to the active label.
 *
 * Besides this class does the following:
 *
 * - Parses the JSON retrieved from the database (through {@link Canvas#parse})
 * - Creates some custom events (defined in {@link Canvas#attachListeners})
 * - Creates, stores and executes the commands (through its {@link Canvas#property-commandStack}) property
 *
 * Below is an example of instantiation of this class:
 *
 *      // The canvas needs an object containing the reference to existing classes outside the library
 *      // i.e. let's define two classes
 *      var BpmnActivity = function (options) {
 *          ...
 *      };
 *      var BpmnEvent = function (options) {
 *          ...
 *      };
 *
 *      // Next, the canvas needs a factory function to create custom shapes dragged from a toolbar
 *      // this function needs an ID to create the shape
 *      function toolbarFactory (id) {
 *          var customShape = null;
 *          switch(id) {
 *              case: 'BpmnActivity':
 *                  customShape = new BpmnActivity({
 *                      ....
 *                  });
 *                  break;
 *              case: 'BpmnEvent':
 *                  customShape = new BpmnEvent({
 *                      ....
 *                  });
 *                  break;
 *          }
 *          return customShape;
 *      }
 *
 *      // finally an instance of this class can be defined
 *      var canvas = new Canvas({
 *          width: 4000,
 *          height: 4000,
 *          toolbarFactory: toolbarFactory,
 *          copyAndPasteReferences: {
 *              bpmnActivity: BpmnActivity,
 *              bpmnEvent: BpmnEvent
 *          }
 *      });
 *
 * @extends BehavioralElement
 *
 * @constructor
 * Creates an instance of the class
 * @param {Object} options configuration options of the canvas
 * @cfg {number} [width=4000] Width of this canvas.
 * @cfg {number} [height=4000] Height of this canvas.
 * @cfg {Function} [commandStackOnSuccess=function(){}] commandStackOnSuccess callback of the command stack.
 * @cfg {Function} toolbarFactory Function that will handle object creation
 * from a custom toolbar
 * @cfg {Object} [copyAndPasteReferences={}] References to the constructors of the classes
 * (so that a shape is easily created from the canvas)
 * @cfg {boolean} [readOnly=false] Property that determines the permission a
 * user has over the canvas
 */
Canvas = function (options) {
    BehavioralElement.call(this, options);

    /**
     * Variable that points to the HTML in the DOM of this object.
     * @property {HTMLElement} [html=null]
     */
    this.html = null;
    /**
     * A list of all the custom shapes in the canvas.
     * @property {ArrayList}
     */
    this.customShapes = null;
    /**
     * A list of all the regular shapes in the canvas.
     * @property {ArrayList}
     */
    this.regularShapes = null;
    /**
     * A list of all the connections in the canvas.
     * @property {ArrayList}
     */
    this.connections = null;
    /**
     * A list of all the shapes that are currently selected.
     * @property {ArrayList}
     */
    this.currentSelection = null;
    /**
     * A list of all the connections that will not be repainted (using the ManhattanRouter algorithm),
     * but will be moved only.
     * @property {ArrayList}
     */
    this.sharedConnections = null;
    /**
     * Left Scroll coordinate of the canvas
     * @property {number} [leftScroll=0]
     */
    this.leftScroll = 0;
    /**
     * Top scroll coordinate of the canvas
     * @property {number} [topScroll=0]
     */
    this.topScroll = 0;
    /**
     * Reference to the current selected connection in the canvas
     * @property {Connection}
     */
    this.currentConnection = null;
    /**
     * Pointer to the last connection selected in the canvas
     * (this variable is set from the commandDelete)
     * @property {Connection}
     */
    this.oldCurrentConnection = null;
    /**
     * Instance of the class {@link Segment} used to make connections in the canvas.
     * @property {Segment}
     */
    this.connectionSegment = null;
    /**
     * Instance of the class {@link MultipleSelectionContainer} created to do multiple selection
     * @property {MultipleSelectionContainer}
     */
    this.multipleSelectionHelper = null;
    /**
     * Instance of the class {@link Snapper} which represents the horizontal line used for snapping
     * @property {Snapper}
     */
    this.horizontalSnapper = null;
    /**
     * Instance of the class {@link Snapper} which represents the vertical line used for snapping
     * @property {Snapper}
     */
    this.verticalSnapper = null;
    /**
     * Current zoom Factor of the diagram
     * @property {number} [zoomFactor=1]
     */
    this.zoomFactor = 1;
    /**
     * Index for the zoom properties for shapes corresponding to the current
     * zoom factor
     * @property {number} [zoomPropertiesIndex=2]
     */
    this.zoomPropertiesIndex = 2;
    /**
     * zOrder of the HTML Representation
     * @property {number} [zOrder=0]
     */
    this.zOrder = 0;
    /**
     * Boolean set true if the {@link Canvas#event-mousedown} event of the canvas is fired,
     * it's set to false in the {@link Canvas#event-mouseup} event.
     * @property {boolean} [isMouseDown=false]
     */
    this.isMouseDown = false;
    /**
     * Current selected shape
     * @property {Shape}
     */
    this.currentShape = null;
    /**
     * True if the {@link Canvas#event-mousedown} event of the canvas is triggered and
     * the {@link Canvas#event-mousemove} event is triggered, it's set to false in mouseUp event.
     * @property {boolean} [isMouseDownAndMove=false]
     */
    this.isMouseDownAndMove = false;
    /**
     * Denotes if there's been a multiple drop prior to a drag end.
     * @property {boolean} [multipleDrop=false]
     */
    this.multipleDrop = false;
    /**
     * Denotes if a segment move handler is being dragged. in order not to
     * trigger events in the canvas [draggingASegmentHandler=false]
     * @property {boolean}
     */
    this.draggingASegmentHandler = false;
    /**
     * Elements that was added, changed or deleted in the canvas.
     * @property {Object}
     */
    this.updatedElement = null;
    /**
     * Determines if the canvas has been right clicked at {@link Canvas#event-mousedown}
     * @property {boolean} [rightClick=false]
     */
    this.rightClick = false;
    /**
     * Each time a shape is moved using the cursors, the following code is executed:
     *
     *      // for each 'connection' that is not in this.sharedConnection and that it's being
     *      // recalculated (using ManhattanRouter algorithm)
     *      connection.disconnect().connect()
     *                  .setSegmentMoveHandlers()
     *                  .checkAndCreateIntersectionsWithAll();
     *
     *  So to avoid these operations for each key press of the cursors, let's create a timeout,
     *  so that only after that timeout has expired the code above will run.
     *  This variable is a reference to that timeout.
     * @property {Object}
     */
    this.intersectionTimeout = null;

    /**
     * Point to the current label that is being edited
     * @property {Object}
     */
    this.currentLabel = null;
    /**
     * Instance of the class {@link CommandStack} to be used in this canvas
     * @property {CommandStack}
     */
    this.commandStack = null;
    /**
     * Array which contains a list of all the objects that were duplicated
     * (during copy)
     * @property {Array} [shapesToCopy=[]]
     */
    this.shapesToCopy = [];
    /**
     * Array which contains a list of all the connections that were duplicated
     * (during copy)
     * @property {Array} [connectionsToCopy=[]]
     */
    this.connectionsToCopy = [];
    /**
     * Property that determines the permissions a user has over the canvas
     * @property {boolean} [readOnly=false]
     */
    this.readOnly = false;
    /**
     * Layer that prevents the canvas to be altered
     * @property {ReadOnlyLayer}
     */
    this.readOnlyLayer = null;
    /**
     * Object which holds references to the constructors of the classes
     * (so that a shape is easily created from the canvas)
     * @property {Object} [copyAndPasteReferences={}]
     */
    this.copyAndPasteReferences = {};
    /**
     * Previous zoom properties index
     * @property {number} [prevZoom=1]
     */
    this.prevZoom = 1;
    /**
     * Initializer for labels, so that jQuery can measure the width of a message
     * in the first time its created
     * @type {HTMLElement}
     */
    this.dummyLabelInitializer = null;
    /**
     * Minimum distance to "snap" to a guide
     * @type {number}
     */
    this. MIN_DISTANCE = 4;
    /**
     * Array which contains a list of all coordinates  to snap
     * @type {number}
     */
    this. guides = []; // no guides available ...

    Canvas.prototype.initObject.call(this, options);
};

Canvas.prototype = new BehavioralElement();
/**
 * Type of the instances
 * @property {String}
 */
Canvas.prototype.type = "Canvas";
/**
 * Family of the instances, this attribute must not be overridden
 * @property {String}
 * @readonly
 */
Canvas.prototype.family = "Canvas";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * The following properties are instantiated in this method:
 *
 *      this.children = new ArrayList();
 *      this.customShapes = new ArrayList();
 *      this.regularShapes = new ArrayList();
 *      this.connections = new ArrayList();
 *      this.currentSelection = new ArrayList();
 *      this.sharedConnections = new ArrayList();
 *      this.commandStack = new CommandStack(20, commandStackOnSuccess);
 *      this.multipleSelectionHelper = new MultipleSelectionContainer(this);
 *      this.horizontalSnapper = new Snapper({orientation: 'horizontal', canvas: this});
 *      this.verticalSnapper = new Snapper({orientation: 'vertical', canvas: this});
 *
 * @param {Object} options The object that contains the config
 * @private
 */
Canvas.prototype.initObject = function (options) {

    var canvasPosition,
        defaults;

    defaults = {
        width: 4000,
        commandStackOnSuccess: function () {},
        height: 4000,
//        toolbarFactory : function (id) {return null; }
        toolbarFactory : (options && options.toolbarFactory) ||
            Canvas.prototype.toolBarShapeFactory ||
            function (id) {return null; },
        copyAndPasteReferences: (options && options.copyAndPasteReferences) || {},
        readOnly : false,
        snapToGuide : true
    };

    $.extend(true, defaults, options);

    if (options) {
        this.createHTML();
        canvasPosition = $("#" + this.id).offset();
        this.children = new ArrayList();
        this.customShapes = new ArrayList();
        this.regularShapes = new ArrayList();
        this.connections = new ArrayList();
        this.currentSelection = new ArrayList();
        this.sharedConnections = new ArrayList();
        this.commandStack = new CommandStack(20, defaults.commandStackOnSuccess);
        this.multipleSelectionHelper = new MultipleSelectionContainer(this);
        this.copyAndPasteReferences = defaults.copyAndPasteReferences;
        this.setToolBarShapeFactory(defaults.toolbarFactory);

        this.setPosition(canvasPosition.left, canvasPosition.top)
            .setDimension(defaults.width, defaults.height)
            .setCanvas(this)
            .setSnapToGuide(defaults.snapToGuide);

        if (defaults.readOnly) {
            this.setToReadOnly();
        }
    }
};

/**
 * Sets the read and write permissions of the canvas.
 * @param {boolean} readOnly Determines if the canvas will be set to read only
 * or if it will be editable
 * @chainable
 */
Canvas.prototype.setReadOnly = function (readOnly) {
    if (readOnly) {
        this.setToReadOnly();
    } else {
        this.unsetReadOnly();
    }
    return this;
};

/**
 * Sets the canvas to readOnly mode by creating a ReadOnlyLayer instance and appending its html to
 * this html
 * @chainable
 */
Canvas.prototype.setToReadOnly = function () {
    var readOnlyLayer = this.readOnlyLayer;
    if (readOnlyLayer && readOnlyLayer.html) {
        this.html.appendChild(this.readOnlyLayer.html);
    } else {
        this.readOnlyLayer = new ReadOnlyLayer({
            width : this.width,
            height : this.height
        });
        this.html.appendChild(this.readOnlyLayer.html);
    }
    this.readOnly = true;
    return this;
};

/**
 * Sets the canvas to read and write mode.
 * @chainable
 */
Canvas.prototype.unsetReadOnly = function () {
    var readOnlyLayer = this.readOnlyLayer;
    this.html.removeChild(readOnlyLayer.getHTML());
    this.readOnly = false;
    return this;
};

/**
 * Sets the position of the canvas.
 * @param {number} x x coordinate relative to where the canvas is contained
 * @param {number} y y coordinate relative to where the canvas is contained
 * @chainable
 */
Canvas.prototype.setPosition = function (x, y) {
    this.setX(x);
    this.setY(y);
    return this;
};

/**
 * Sets the x coordinate of the canvas, its zoomX and absoluteX to an equal value.
 * @param {number} newX new x coordinate to be applied in the canvas
 * @chainable
 */
Canvas.prototype.setX = function (newX) {
    this.x = this.zoomX = newX;
    this.absoluteX = 0;
    return this;
};

/**
 * Set the y coordinate of the canvas, its zoomY and absoluteY to an equal value
 * @param {number} newY new y coordinate to be applied in the canvas
 * @chainable
 */
Canvas.prototype.setY = function (newY) {
    this.y = this.zoomY = newY;
    this.absoluteY = 0;
    return this;
};

/**
 * Set guide Lines to canvas and create vertican and horizontal snappers
 * @param {Boolean} snap new value to verify if canvas has enabled snappes
 * @chainable
 */
Canvas.prototype.setSnapToGuide = function (snap) {
    this.snapToGuide = snap;
    // create snappers
    if (!this.horizontalSnapper) {
        this.horizontalSnapper = new Snapper({
            orientation: 'horizontal',
            canvas: this,
            width : 4000,
            height: 1
        });
    }
    if (!this.verticalSnapper) {
        this.verticalSnapper = new Snapper({
            orientation: 'vertical',
            canvas: this,
            width : 1,
            height :4000
        });
    }
    return this;
};

/**
 * Retrieves the div element that has this canvas id
 * @return {HTMLElement}
 */
Canvas.prototype.createHTMLDiv = function () {
    return document.getElementById(this.id);
};

/**
 * Default shape factory for creating shapes.
 * @param {String} id
 * @return {CustomShape}
 * @template
 */
Canvas.prototype.toolBarShapeFactory = function (id) {
    var customShape = null;

    switch (id) {
    case "tiny_shape":
        customShape = new CustomShape({
            width: 50,
            height: 50,
            "canvas" : this,
            "connectAtMiddlePoints": false,
            "drop" : {
                type : "connection"
            },
            "style": {
                cssClasses: ["grey"],
                cssProperties: {
                    border: "1px solid blue",
                    "-webkit-box-shadow": "0px 0px 4px 0px black",
                    "box-shadow": "0px 0px 4px 0px black"
                }
            },
            // BEHAVIORS
            resizeBehavior: "NoResize",
            resizeHandlers: {
                type: "Rectangle",
                total: 8,
                resizableStyle: {
                    cssProperties: {
                        'background-color': "rgb(0, 255, 0)",
                        'border': '1px solid black'
                    }
                },
                nonResizableStyle: {
                    cssProperties: {
                        'background-color': "white",
                        'border': '1px solid black'
                    }
                }
            }
        });
        customShape.attachListeners();
        break;
    case "big_shape":
        customShape = new CustomShape({
            width: 200,
            height: 200,
            canvas : this,
            container: 'regular',
            "connectAtMiddlePoints": false,
            drop : {
                type : "connectioncontainer",
                selectors: ['.custom_shape']
            },
            "style": {
                cssClasses: ["grey"],
                cssProperties: {
                    border: "1px solid green",
                    "-webkit-box-shadow": "0px 0px 4px 0px black",
                    "box-shadow": "0px 0px 4px 0px black"
                }
            },
            // BEHAVIORS
            resizeBehavior: "yes",
            resizeHandlers: {
                type: "Rectangle",
                total: 8,
                resizableStyle: {
                    cssProperties: {
                        'background-color': "rgb(0, 255, 0)",
                        'border': '1px solid black'
                    }
                },
                nonResizableStyle: {
                    cssProperties: {
                        'background-color': "white",
                        'border': '1px solid black'
                    }
                }
            }
        });
        customShape.attachListeners();
        break;
    default:
    }

    return customShape;
};

/**
* Identifies the family of the shape (which might be *"CustomShape"* or *"RegularShape"*)
* and adds `shape` to either `this.customShapes` or `this.regularShapes`.
* @param {Shape} shape
* @chainable
*/
Canvas.prototype.addToList = function (shape) {
    switch (shape.family) {
    case "CustomShape":
        if (!this.customShapes.contains(shape)) {
            this.customShapes.insert(shape);
        }
        break;
    case "RegularShape":
        if (!this.regularShapes.contains(shape)) {
            this.regularShapes.insert(shape);
        }
        break;
    default:
    }
    return this;
};

/**
 * Hides `this.currentConnection` if there is one.
 * @chainable
 */
Canvas.prototype.hideCurrentConnection = function () {
    // hide the current connection if there was one
    if (this.currentConnection) {
        this.currentConnection.hidePortsAndHandlers();
        this.currentConnection = null;
    }
    return this;
};

/**
 * Applies a zoom scale to the canvas and all its elements
 * @param {number} scale numbered from 1 to n
 * @chainable
 */
Canvas.prototype.applyZoom = function (scale) {
    // TODO Implement Zoom Constants in utils
    var i,
        shape;
    if (scale > 0) {
        scale -= 1;
        this.prevZoom = this.zoomPropertiesIndex;
        this.zoomPropertiesIndex = scale;
        this.zoomFactor = (scale * 25 + 50) / 100;
    }

    for (i = 0; i < this.customShapes.getSize(); i += 1) {
        shape = this.customShapes.get(i);
        shape.applyZoom();
        shape.paint();
    }

    for (i = 0; i < this.regularShapes.getSize(); i += 1) {
        shape = this.regularShapes.get(i);
        shape.applyZoom();
        shape.paint();
    }

    return this;
};

/**
 * Adds a connection to the canvas, appending its html to the DOM and inserting
 * it in the list of connections
 * @param {Connection} conn
 * @chainable
 */
Canvas.prototype.addConnection = function (conn) {
    this.html.appendChild(conn.getHTML());
    this.connections.insert(conn);
    this.updatedElement = conn;
//    $(this.html).trigger("createelement");
    return this;
};

/**
 * Remove all selected elements, it destroy the shapes and all references to them.
 * @chainable
 */
Canvas.prototype.removeElements = function () {
    // destroy the shapes (also destroy all the references to them)
    var shape,
        command;

    command = new CommandDelete(this);
    this.commandStack.add(command);
    command.execute();

//    while (this.getCurrentSelection().getSize() > 0) {
//        shape = this.getCurrentSelection().getFirst();
//        shape.destroy();
//    }
//
//    // destroy the currentConnection (also destroy all the references to it)
//    if (this.currentConnection) {
//        this.currentConnection.destroy();
//        this.currentConnection = null;
//    }

//    DEBUG
//    console.log("CurrentSelection: " + canvas.getCurrentSelection().getSize());
//    console.log("CustomShapes: " + canvas.getCustomShapes().getSize());
//    console.log("RegularShapes: " + canvas.getRegularShapes().getSize());
//    console.log("Connections: " + canvas.getConnections().getSize());

    return this;
};

/**
 * Moves all the connections of the children of this shape (shape was moved using the cursors but the children
 * connections don't know that so move those connections), this method is called from #moveElements.
 * @param {Shape} shape
 * @chainable
 */
Canvas.prototype.moveAllChildConnections = function (shape) {
    var i,
        child,
        j,
        port;
    if (shape.child !== null) {
        for (i = 0; i < shape.children.getSize(); i += 1) {
            child = shape.children.get(i);
            child.setPosition(child.x, child.y);
            for (j = 0; j < child.getPorts().getSize(); j += 1) {
                port = child.getPorts().get(j);
                port.setPosition(port.x, port.y);
                port.connection.disconnect();
                //alert('disconnected');
                port.connection.connect();

            }

            this.moveAllChildConnections(child);
        }

    }
    return this;

};

/**
 * Move all selected elements in one direction, used mainly for keyboard events
 * @param {Canvas} canvas
 * @param {string} direction The direction to move the shapes to
 * @param {Function} [hook] Hook used to determine which shapes can be moved with the keyboard,
 * the function must receive a shape as its parameter and return true if the shape can be moved, false
 * otherwise (if this function is not defined then it's assumed that all shapes are valid
 * to be moved).
 *      // i.e.
 *      hook = function(shape) {
 *          return shape.isValidToMove();
 *      }
 *
 * @chainable
 */
Canvas.prototype.moveElements = function (canvas, direction, hook) {
    var i, j,
        shape,
        hfactor = 0,
        vfactor = 0,
        port,
        currentSelection = [],
        canMove;
    switch (direction) {
    case 'LEFT':
        hfactor = -1;
        break;
    case 'RIGHT':
        hfactor = 1;
        break;
    case 'TOP':
        vfactor = -1;
        break;
    case 'BOTTOM':
        vfactor = 1;
        break;
    }

    for (i = 0; i < canvas.getCurrentSelection().getSize(); i += 1) {
        canMove = true;
        shape = canvas.getCurrentSelection().get(i);
        currentSelection.push(shape);

        if (hook && typeof hook === "function" && !hook(shape)) {
            canMove = false;
        }

        if (canMove) {
            shape.oldX = shape.x;
            shape.oldY = shape.y;
            shape.oldAbsoluteX = shape.absoluteX;
            shape.oldAbsoluteY = shape.absoluteY;

            shape.setPosition(shape.getX() + hfactor, shape.getY() + vfactor);
            shape.changePosition(shape.oldX, shape.oldY, shape.oldAbsoluteX,
                shape.oldAbsoluteY);

            for (j = 0; j < shape.ports.getSize(); j += 1) {
                //for each port update its absolute position and repaint its
                // connection
                port = shape.ports.get(j);

                port.setPosition(port.x, port.y);
                port.connection.disconnect().connect();
    //            this.intersectionTimeout = null;
            }
            this.moveAllChildConnections(shape);
            shape.refreshConnections(false);
        }
    }

    clearTimeout(this.intersectionTimeout);
    this.intersectionTimeout = window.setTimeout(function (currentSelection) {
        var stack = [],
            selection = currentSelection || [];

        for (i = 0; i < selection.length; i += 1) {
            shape = selection[i];
            stack.push(shape);
        }
        while (stack.length > 0) {
            shape = stack.pop();
            // add the children to the stack
            for (i = 0; i < shape.getChildren().getSize(); i += 1) {
                stack.push(shape.getChildren().get(i));
            }
            for (j = 0; j < shape.ports.getSize(); j += 1) {
                //for each port update its absolute position and repaint its
                // connection
                port = shape.ports.get(j);
                port.connection.disconnect().connect();
                port.connection.setSegmentMoveHandlers();
                port.connection.checkAndCreateIntersectionsWithAll();
            }
        }
    }, 1000, currentSelection);

    return this;
};

/**
 * Removes `shape` from the its corresponding list in the canvas (the shape has a reference either in
 * `this.customShapes` or `this.regularShapes`).
 * @param {Shape} shape
 * @chainable
 */
Canvas.prototype.removeFromList = function (shape) {
    // remove from the current selection
    this.currentSelection.remove(shape);

    if (shape.family === "CustomShape") {
        this.customShapes.remove(shape);
    } else if (shape.family === "RegularShape") {
        this.regularShapes.remove(shape);
    }
    return this;
};

///**
// * Fixes the data of the snappers recreating the arrays and sorting them,
// * this method is called from {@link RegularDragBehavior#onDragStart} (it might
// * be an overrided method `onDragStart` if the instance of {@link RegularDragBehavior} was changed).
// * @chainable
// */
//Canvas.prototype.fixSnapData = function () {
//    this.horizontalSnapper.createSnapData();
//    this.verticalSnapper.createSnapData();
//    this.horizontalSnapper.sortData();
//    this.verticalSnapper.sortData();
//    return this;
//};

/**
 * Build the data of the snappers recreating the arrays,
 * this method is called from {@link RegularDragBehavior#onDragStart} (it might
 * be an overrided method `onDragStart` if the instance of {@link RegularDragBehavior} was changed).
 * @chainable
 */
Canvas.prototype.startSnappers = function (event) {
    var shape, i, parent;
    this.guides = [];
    for (i = 0; i < this.canvas.customShapes.getSize(); i += 1) {
        shape = this.canvas.customShapes.get(i);
        if (!this.canvas.currentSelection.find('id', shape.getID())) {
            this.computeGuidesForElement(shape);
        }
    }
    return this;
};


Canvas.prototype.computeGuidesForElement = function (shape) {
    var x = shape.getAbsoluteX();
    var y = shape.getAbsoluteY();

    var w = shape.getZoomWidth() - 1;
    var h = shape.getZoomHeight() - 1;

    this.guides.push(
            { type: "h", x: x, y: y },
            { type: "h", x: x, y: y + h },
            { type: "v", x: x, y: y },
            { type: "v", x: x + w, y: y }
        );
    return this;

};

/**
 * Process the snappers according to this criteria and show and hide:
 *
 * - To show the vertical snapper
 *      - `shape.absoluteX` must equal a value in the data of `this.verticalSnapper`
 *      - `shape.absoluteX + shape.width` must equal a value in the data of `this.verticalSnapper`
 *
 * - To show the horizontal snapper
 *      - `shape.absoluteY` must equal a value in the data of `this.horizontalSnapper`
 *      - `shape.absoluteY + shape.height` must equal a value in the data of `this.horizontalSnapper`
 *
 * @param {Object} e
 * @parem {Object} ui
 * @param {Shape} customShape
 * @chainable
 */
Canvas.prototype.processGuides = function (e, ui, customShape){
    // iterate all guides, remember the closest h and v guides
    var guideV,
        guideH,
        distV = this.MIN_DISTANCE + 1,
        distH = this.MIN_DISTANCE + 1,
        offsetV,
        offsetH,
        mouseRelX,
        mouseRelY,
        pos,
        w = customShape.getZoomWidth() - 1,
        h = customShape.getZoomHeight() - 1,
        d;

    mouseRelY = e.originalEvent.pageY - ui.offset.top;
    mouseRelX = e.originalEvent.pageX - ui.offset.left;
    pos = {
        top: e.originalEvent.pageY - customShape.canvas.getY() - mouseRelY
            + customShape.canvas.getTopScroll(),
        left: e.originalEvent.pageX - customShape.canvas.getX() - mouseRelX
            + customShape.canvas.getLeftScroll()
    };
    $.each(this.guides, function (i, guide) {
        if (guide.type === "h"){
            d = Math.abs(pos.top - guide.y);
            if (d < distH) {
                distH = d;
                guideH = guide;
                offsetH = 0;
            }
            d = Math.abs(pos.top - guide.y + h);
            if (d < distH) {
                distH = d;
                guideH = guide;
                offsetH = h;
            }
        }
        if (guide.type === "v") {
            d = Math.abs(pos.left - guide.x);
            if (d < distV) {
                distV = d;
                guideV = guide;
                offsetV = 0;
            }
            d = Math.abs(pos.left - guide.x + w);
            if (d < distV) {
                distV = d;
                guideV = guide;
                offsetV = w;
            }
        }
    });

    if (distH <= this.MIN_DISTANCE) {
        $("#guide-h").css("top", guideH.y).show();
        if (customShape.parent.family !== 'canvas') {
            ui.position.top = guideH.y - offsetH - customShape.parent.getAbsoluteY();
            customShape.setPosition(ui.helper.position().left / this.zoomFactor,
                guideH.y - offsetH - customShape.parent.getAbsoluteY())
        } else {
            ui.position.top = guideH.y - offsetH;
            customShape.setPosition(ui.helper.position().left / this.zoomFactor,
                guideH.y - offsetH)
        }
//        customShape.setPosition(ui.helper.position().left / this.zoomFactor,
//            guideH.y - offsetH);
    } else {
        $("#guide-h").hide();
        //ui.position.top = pos.top;
        //console.log(pos.top);
        //customShape.setPosition(this.getX(), pos.top);
    }

    if (distV <= this.MIN_DISTANCE) {
        $("#guide-v").css("left", guideV.x).show();
        if (customShape.parent.family !== 'canvas') {
            ui.position.left = guideV.x - offsetV - customShape.parent.getAbsoluteX();
            customShape.setPosition(
                guideV.x - offsetV - customShape.parent.getAbsoluteX(),
                ui.helper.position().top / this.zoomFactor
            );
        } else {
            ui.position.left = guideV.x - offsetV;
            customShape.setPosition(guideV.x - offsetV,
                ui.helper.position().top / this.zoomFactor);
        }

    } else{
        $("#guide-v").hide();
       // customShape.setPosition(pos.left, this.getY());
       // ui.position.left = pos.left;
    }
    return this;
};


///**
// * Shows or hides the snappers according to this criteria:
// *
// * - To show the vertical snapper
// *      - `shape.absoluteX` must equal a value in the data of `this.verticalSnapper`
// *      - `shape.absoluteX + shape.width` must equal a value in the data of `this.verticalSnapper`
// *
// * - To show the horizontal snapper
// *      - `shape.absoluteY` must equal a value in the data of `this.horizontalSnapper`
// *      - `shape.absoluteY + shape.height` must equal a value in the data of `this.horizontalSnapper`
// *
// * @param {Shape} shape
// * @chainable
// */
//Canvas.prototype.showOrHideSnappers = function (shape) {
//    var hSnapper = this.horizontalSnapper,
//        vSnapper = this.verticalSnapper,
//        x = shape.getAbsoluteX(),
//        y = shape.getAbsoluteY(),
//        width = shape.getZoomHeight(),
//        height = shape.getZoomHeight();
//
//    if (hSnapper.binarySearch(y)) {
//        hSnapper.setPosition(
//            this.getLeftScroll() / this.zoomFactor,
//            y / this.zoomFactor
//        );
//        hSnapper.show();
//    } else if (hSnapper.binarySearch(y + height)) {
//        hSnapper.setPosition(
//            this.getLeftScroll() / this.zoomFactor,
//            (y + height) / this.zoomFactor
//        );
//        hSnapper.show();
//    } else {
//        hSnapper.hide();
//    }
//
//    if (vSnapper.binarySearch(x)) {
//        vSnapper.setPosition(
//            x / this.zoomFactor,
//            this.getTopScroll() / this.zoomFactor
//        );
//        vSnapper.show();
//    } else if (vSnapper.binarySearch(x + width)) {
//        vSnapper.setPosition(
//            (x + width) / this.zoomFactor,
//            this.getTopScroll() / this.zoomFactor
//        );
//        vSnapper.show();
//    } else {
//        vSnapper.hide();
//    }
//    return this;
//};


/**
 * Empties `this.currentSelection` arrayList, thus hiding the resize handlers
 * of each shape that was in it, it also clears `this.sharedConnections` array
 * (there's a direct relationship between them).
 * @chainable
 */
Canvas.prototype.emptyCurrentSelection = function () {
    var i,
        shape;
    while (this.currentSelection.getSize() > 0) {
        shape = this.currentSelection.get(0);
        this.removeFromSelection(shape);
    }

    // also clear the sharedConnections
    this.sharedConnections.clear();

    return this;
};

/**
 * Determines if it's possible to select `newShape` using `referenceShape` as a reference (`newShape` is a valid
 * shape to be added to the selection if it has the same parent as `referenceShape`).
 * @param {Shape} referenceShape shape which parent will be taken as reference
 * @param {Shape} newShape new selected shape
 * @return {boolean}
 */
Canvas.prototype.isValidSelection = function (referenceShape, newShape) {
    if (referenceShape.parent === null) {
        return newShape.parent === null;
    }
    if (newShape.parent === null) {
        return false;
    }
    return newShape.parent.id === referenceShape.parent.id;
};

/**
 * Adds `shape` to `this.currentSelection` if it meets one of the following rules:
 *
 * - If `this.currentSelection` is empty then add it to the arrayList
 * - If `this.currentSelection` is not empty then check if this candidate shape
 *      has the same parent as any element in `this.currentSelection`, if so then add it to
 *      the arrayList.
 *
 * This method also shows the resize handlers of the shape and adds its connections
 * to `this.sharedConnections` if possible.
 * @param {Shape} shape
 * @chainable
 */
Canvas.prototype.addToSelection = function (shape) {
    var currentSelection = this.currentSelection,
        firstSelected,
        valid,
        isEmpty = currentSelection.isEmpty();
    if (!isEmpty) {
        firstSelected = currentSelection.get(0);
        valid = this.isValidSelection(firstSelected, shape);
    } else {
        valid = true;
    }
    if (!currentSelection.contains(shape) && valid) {
        // increase this shape zIndex
        shape.increaseZIndex();
        currentSelection.insert(shape);

        // add the connections from this shape that are connected
        // to another shape in the currentSelection to the
        // canvas sharedConnections array
        // NOTE: the shape is passed as an argument but its
        // connections are stored
        if (shape.family === "CustomShape") {
            this.addToSharedConnections(shape);
        }

//        console.log("currentSelection: " + this.currentSelection.getSize());
//        console.log("shared connections: " + this.sharedConnections.getSize());
        shape.selected = true;
        shape.showOrHideResizeHandlers(true);
    }
    return this;
};

/**
 * Removes `shape` from `this.currentSelection` (also hiding its resize handlers).
 * @param {Shape} shape
 * @chainable
 */
Canvas.prototype.removeFromSelection = function (shape) {
    shape.decreaseZIndex();
    this.removeFromSharedConnections(shape);
    this.currentSelection.remove(shape);
    shape.selected = false;
    shape.showOrHideResizeHandlers(false);
    return this;
};

/**
 * Removes all the shared connections between `customShape` and every shape
 * found in `this.currentSelection`, also the connections inside `customShape` are removed from
 * `this.sharedConnections` array.
 * @param {CustomShape} customShape
 * @chainable
 */
Canvas.prototype.removeFromSharedConnections = function (customShape) {
    var i,
        child,
        connection,
        sharedConnections = this.sharedConnections;

    for (i = 0; i < customShape.getChildren().getSize(); i += 1) {
        child = customShape.getChildren().get(i);
        this.removeFromSharedConnections(child);
    }

    if (customShape.ports) {
        for (i = 0; i < customShape.ports.getSize(); i += 1) {
            connection = customShape.ports.get(i).connection;
            if (sharedConnections.find('id', connection.getID())) {
                this.sharedConnections.remove(connection);
            }
        }
    }
    return this;
};

/**
 * Checks if an ancestor of `shape` is in `this.currentSelection`.
 * @return {boolean}
 */
Canvas.prototype.findAncestorInCurrentSelection = function (shape) {
    if (this.currentSelection.find('id', shape.getID())) {
        return true;
    }
    if (!shape.parent) {
        return false;
    }
    return this.findAncestorInCurrentSelection(shape.parent);
};

/**
 * Adds all the connections between `customShape` and another shape in the
 * currentSelection to the `sharedConnections` arrayList, also the connections inside
 * `customShape` are added to `this.sharedConnections` array.
 * @param {CustomShape} customShape
 * @chainable
 */
Canvas.prototype.addToSharedConnections = function (customShape) {
    var i,
        child,
        connection,
        sourceShape,
        destShape,
        sharedConnections = this.sharedConnections;

    for (i = 0; i < customShape.getChildren().getSize(); i += 1) {
        child = customShape.getChildren().get(i);
        this.addToSharedConnections(child);
    }

    if (customShape.ports) {
        for (i = 0; i < customShape.ports.getSize(); i += 1) {
            connection = customShape.ports.get(i).connection;
            sourceShape = connection.srcPort.parent;
            destShape = connection.destPort.parent;
//            console.log(sourceShape);
//            console.log(destShape);

            if (this.findAncestorInCurrentSelection(sourceShape) &&
                    this.findAncestorInCurrentSelection(destShape) &&
                    !sharedConnections.find('id', connection.getID())) {
                sharedConnections.insert(connection);
            }
        }
    }
    return this;
};

/**
 * Removes a connection from `this.connections`.
 * @param {Connection} conn
 * @chainable
 */
Canvas.prototype.removeConnection = function (conn) {
    //this.currentSelection.remove(conn);
    this.connections.remove(conn);
    return this;
};

/**
 * Attaches event listeners to this canvas, it also creates some custom triggers
 * used to save the data (to send it to the database later).
 *
 * The events attached to this canvas are:
 *
 * - {@link Canvas#event-mousedown Mouse down event}
 * - {@link Canvas#event-mousemove Mouse move event}
 * - {@link Canvas#event-mouseup Mouse up event}
 * - {@link Canvas#event-click Click event}
 * - {@link Canvas#event-scroll Scroll event}
 *
 * The custom events are:
 *
 * - {@link Canvas#event-createelement Create element event}
 * - {@link Canvas#event-removeelement Remove element event}
 * - {@link Canvas#event-changeelement Change element event}
 * - {@link Canvas#event-selectelement Select element event}
 * - {@link Canvas#event-rightclick Right click event}
 *
 * This method also initializes jQueryUI's droppable plugin (instantiated as `this.dropBehavior`)
 * @chainable
 */
Canvas.prototype.attachListeners = function () {
    var $canvas = $(this.html).click(this.onClick(this)),
        $canvasContainer = $canvas.parent();

    $canvas.mousedown(this.onMouseDown(this));
    $canvasContainer.scroll(this.onScroll(this, $canvasContainer));
    $canvas.mousemove(this.onMouseMove(this));
    $canvas.mouseup(this.onMouseUp(this));
    $canvas.on("createelement", this.onCreateElement(this));
    $canvas.on("removeelement", this.onRemoveElement(this));
    $canvas.on("changeelement", this.onChangeElement(this));
    $canvas.on("selectelement", this.onSelectElement(this));
    $canvas.on("rightclick", this.onRightClick(this));
    $canvas.on("contextmenu", function (e) {
        e.preventDefault();
    });

    this.updateBehaviors();
    return this;
};

/**
 * This is a hook that will be executed after an element has been created in
 * the canvas.
 * This hook will be executed every time a shape, a connection, or an
 * independent label is created.
 * @param {Object} updatedElement
 * @param {string} [updatedElement.id] ID of the updated element
 * @param {string} [updatedElement.type] Type of the updated element
 * @param {Shape} [updatedElement.relatedObject] The updated element
 * @param {Array} [updatedElement.relatedElements] An array with all the other elements created
 *  i.e. When executing {@link CommandDelete#undo CommandDelete.undo()}, multiple elements are created
 *  at once, so this property will contain all those shapes.
 * @template
 * @protected
 */
Canvas.prototype.onCreateElementHandler = function (updatedElement) {
};

/**
 * @event createelement
 * Handler for the custom event createelement, this event fires when an element
 * has been created. It executes the hook #onCreateElementHandler
 * @param {Canvas} canvas
 */
Canvas.prototype.onCreateElement = function (canvas) {
    return function (e, ui) {
        canvas.onCreateElementHandler(canvas.updatedElement);
    };
};

/**
 * This is a hook that will be executed after an element has been deleted in
 * the canvas.
 * This hook will be executed every time a shape, a connection, or an
 * independent label is deleted
 * @param {Object} updatedElement
 * @param {string} [updatedElement.id] ID of the removed element
 * @param {string} [updatedElement.type] Type of the removed element
 * @param {Shape} [updatedElement.relatedObject] The removed element
 * @param {Array} [updatedElement.relatedElements] An array with all the other elements removed
 *  i.e. When executing {@link CommandDelete#execute CommandDelete.execute()}, multiple elements are created
 *  at once, so this property will contain all those shapes.
 * @template
 * @protected
 */
Canvas.prototype.onRemoveElementHandler = function (updatedElement) {
    return true;
};

/**
 * @event removeelement
 * Handler for the custom event removeelement, this event fires when an element
 * has been deleted. It executes the hook #onRemoveElementHandler
 * @param {Canvas} canvas
 */
Canvas.prototype.onRemoveElement = function (canvas) {
    return function (e, ui) {
        canvas.onRemoveElementHandler(canvas.updatedElement.relatedElements);
    };
};
/**
 * This is a hook that will be executed after an element has been changed in
 * the canvas.
 * This hook will be executed every time a shape, a connection, or an
 * independent label is changed.
 * `arguments[0]` is an array with all the elements that were updated,
 * the structure of each element of the array is described below:
 *
 *      {
 *          id: #,      // the id of the updated element
 *          type: #     // the type of the updated element
 *          fields: [
 *              {
 *                  field: #        // the field that was updated in this element
 *                  oldVal: #       // the old value of this shape
 *                  newVal: #       // the new value of this shape
 *              },
 *              ...
 *          ]
 *      }
 *
 * @param {Array} updatedElements Array with all the elements that were updated.
 * @template
 * @protected
 */
Canvas.prototype.onChangeElementHandler = function (updatedElements) {
};

/**
 * @event changeelement
 * Handler for the custom event changeeelement, this event fires when an element
 * has been changed. It executes the hook #onChangeElementHandler
 * @param {Canvas} canvas
 */
Canvas.prototype.onChangeElement = function (canvas) {
    return function (e, ui) {
        canvas.onChangeElementHandler(canvas.updatedElement);
    };
};

/**
 * This is a hook that will be executed after an element has been selected in
 * the canvas.
 * This hook will be executed every time a shape, a connection, or an
 * independent label is selected
 * `arguments[0]` is an array with all the elements that were selected,
 * the structure of each element of the array is described below:
 *
 *      {
 *          id: #,              // the id of the selected element
 *          type: #             // the type of the selected element
 *          relatedObject       // the selected element
 *      }
 * @param {Array} updatedElements Array with the selected elements
 * @protected
 * @template
 */
Canvas.prototype.onSelectElementHandler = function (updatedElements) {
};

/**
 * @event selectelement
 * Handler for the custom event selectelement, this event fires when an element
 * has been selected. It executes the hook #onSelectElementHandler
 * @param {Canvas} canvas
 */
Canvas.prototype.onSelectElement = function (canvas) {
    return function (e, ui) {
        canvas.onSelectElementHandler(canvas.updatedElement);
    };
};

/**
 * This is a hook that will be executed after an element has been right clicked
 * in the canvas or the canvas's been right clicked itself.
 * This hook will be executed every time a shape, a connection, an
 * independent label or the canvas is right clicked
 * @param {Object} updatedElement Reference to the last element that was
 * right clicked in the canvas
 * @param {number} x x coordinate where the mouse was pressed
 * @param {number} y y coordinate where the mouse was pressed
 * @template
 * @protected
 */
Canvas.prototype.onRightClickHandler = function (updatedElement, x, y) {
};

/**
 * @event rightclick
 * Handler for the custom event rightclick, this event fires when an element
 * has been right clicked. It executes the hook #onRightClickHandler
 * @param {Canvas} canvas
 */
Canvas.prototype.onRightClick = function (canvas) {
    return function (event, e, element) {
        var x = e.pageX - canvas.x + canvas.leftScroll,
            y = e.pageY - canvas.y + canvas.topScroll;
        canvas.updatedElement = element;
        console.log(element);
        canvas.onRightClickHandler(canvas.updatedElement, x, y);
    };
};

/**
 * @event click
 * Click event handler, which makes `this.currentLabel` lose its focus.
 * @param {Canvas} canvas
 */
Canvas.prototype.onClick = function (canvas) {
    return function (e, ui) {
        var currentLabel = canvas.currentLabel;
        //console.log('current:'+ current);

        if (currentLabel) {
            currentLabel.loseFocus();
            $(currentLabel.textField).focusout();
        }

    };
};

/**
 * @event mousedown
 * MouseDown Handler of the canvas. It does the following:
 *
 * - Trigger the {@link Canvas#event-rightclick Right Click event} if it detects a right click
 * - Empties `canvas.currentSelection`
 * - Hides `canvas.currentConnection` if there's one
 * - Resets the position of `canvas.multipleSelectionContainer` making it visible and setting its
 *      `[x, y]` to the point where the user did mouse down in the `canvas`.
 *
 * @param {Canvas} canvas
 */
Canvas.prototype.onMouseDown = function (canvas) {
    return function (e, ui) {

        var x = e.pageX - canvas.getX() + canvas.getLeftScroll(),
            y = e.pageY - canvas.getY() + canvas.getTopScroll();
        e.preventDefault();

        if (e.which === 3) {
            canvas.rightClick = true;
            $(canvas.html).trigger("rightclick", [e, canvas]);
        }

        canvas.isMouseDown = true;
        canvas.isMouseDownAndMove = false;

        // do not create the rectangle selection if a segment handler
        // is being dragged
        if (canvas.draggingASegmentHandler) {
            return;
        }

        // clear old selection
        canvas.emptyCurrentSelection();

        // hide the currentConnection if there's one
        canvas.hideCurrentConnection();

        canvas.multipleSelectionHelper.reset();
        canvas.multipleSelectionHelper.setPosition(x / canvas.zoomFactor,
                y / canvas.zoomFactor);
        canvas.multipleSelectionHelper.oldX = x;
        canvas.multipleSelectionHelper.oldY = y;
        canvas.multipleSelectionHelper.setVisible(true);
        canvas.multipleSelectionHelper.changeOpacity(0.2);
//        console.log("canvas down");

    };
};

/**
 * @event mousemove
 * MouseMove handler of the canvas, it does the following:
 *
 * - Updates the position and dimension of `canvas.multipleSelectionContainer`
 *
 * @param {Canvas} canvas
 */
Canvas.prototype.onMouseMove = function (canvas) {
    return function (e, ui) {
        if (canvas.isMouseDown && !canvas.rightClick) {
            canvas.isMouseDownAndMove = true;
            var x = e.pageX - canvas.getX() + canvas.getLeftScroll(),
                y = e.pageY - canvas.getY() + canvas.getTopScroll(),
                topLeftX,
                topLeftY,
                bottomRightX,
                bottomRightY;

            topLeftX = Math.min(x, canvas.multipleSelectionHelper.oldX);
            topLeftY = Math.min(y, canvas.multipleSelectionHelper.oldY);
            bottomRightX = Math.max(x, canvas.multipleSelectionHelper.oldX);
            bottomRightY = Math.max(y, canvas.multipleSelectionHelper.oldY);

            canvas.multipleSelectionHelper.setPosition(
                topLeftX / canvas.zoomFactor,
                topLeftY / canvas.zoomFactor
            );
            canvas.multipleSelectionHelper.setDimension(
                (bottomRightX - topLeftX) / canvas.zoomFactor,
                (bottomRightY - topLeftY) / canvas.zoomFactor
            );

        }

//        console.log("canvas move");
    };
};

/**
 * click handler
 * MouseClick handler of the canvas. It does the following:
 *
 * @param {Canvas} canvas
 * @param {Number} x
 * @param {Number} y
 */
Canvas.prototype.onClickHandler = function (canvas, x, y) {

};
/**
 * @event mouseup
 * MouseUp handler of the canvas. It does the following:
 *
 * - Wraps the elements that are inside `canvas.multipleSelectionContainer`
 * - Resets the state of `canvas.multipleSelectionContainer` (see {@link MultipleSelectionContainer#reset})
 *
 * @param {Canvas} canvas
 */
Canvas.prototype.onMouseUp = function (canvas) {
    return function (e, ui) {
        if (canvas.isMouseDownAndMove) {
            var x = e.pageX - canvas.getX() + canvas.getLeftScroll(),
                y = e.pageY - canvas.getY() + canvas.getTopScroll();
            canvas.multipleSelectionHelper.setPosition(
                Math.min(x, canvas.multipleSelectionHelper.zoomX) / canvas.zoomFactor,
                Math.min(y, canvas.multipleSelectionHelper.zoomY) / canvas.zoomFactor
            );

            if (canvas.multipleSelectionHelper) {
                canvas.multipleSelectionHelper.wrapElements();
            }
        } else {
            if (canvas.isMouseDown && !canvas.rightClick) {
                canvas.onClickHandler(canvas, x, y);
            }
            //canvas.setCurrentShape(null);
            //hideSelectedPorts(canvas);

            if (!canvas.multipleSelectionHelper.wasDragged) {
                canvas.multipleSelectionHelper.reset().setVisible(false);
            }
        }
        canvas.isMouseDown = false;
        canvas.isMouseDownAndMove = false;
        canvas.rightClick = false;

//        console.log("canvas up");
    };
};

/**
 * @event scroll
 * Handler for scrolling, sets the scroll values to the canvas
 * @param {Canvas} canvas
 * @param {Object} $canvasContainer jQuery element that is the container of the `canvas`
 */
Canvas.prototype.onScroll = function (canvas, $canvasContainer) {
    return function (e, ui) {
        canvas.setLeftScroll($canvasContainer.scrollLeft())
            .setTopScroll($canvasContainer.scrollTop());
    };
};

/**
 * Fires the {@link Canvas#event-selectelement} event, and elaborates the structure of the object that will
 * be passed to the handlers.
 * @param {Array} selection The `currentSelection` ArrayList of some canvas
 * @chainable
 */
Canvas.prototype.triggerSelectEvent = function (selection) {
    var i,
        elements = [],
        current;
    for (i = 0; i < selection.length; i += 1) {
        current = selection[i];
        elements.push({
            id : current.id,
            type : current.type,
            relatedObject : current
        });
    }
    this.updatedElement = elements;
    $(this.html).trigger('selectelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-rightclick} event and elaborates the structure
 * of the object that will be passed to the event.
 * @param {CustomShape} element The object that's been right clicked on.
 * @chainable
 */
Canvas.prototype.triggerRightClickEvent = function (element) {
    this.updatedElement = {
        id : element.id,
        type : element.type,
        relatedObject : element
    };
    $(this.html).trigger('rightclick');
    return this;
};

/**
 * Fires the {@link Canvas#event-createelement} event, and elaborates the structure of the object that will
 * be passed to the handlers.
 * @param {Object} shape The shape created
 * @param {Array} relatedElements The array with the other elements created
 * @chainable
 */
Canvas.prototype.triggerCreateEvent = function (shape, relatedElements) {
    this.updatedElement = {
        id : (shape && shape.id) || null,
        type : (shape && shape.type) || null,
        relatedObject : shape,
        relatedElements: relatedElements

    };
    $(this.html).trigger('createelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-removeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers.
 * @param {CustomShape} shape The shape created
 * @param {Array} relatedElements The array with the other elements created
 * @chainable
 */
Canvas.prototype.triggerRemoveEvent = function (shape, relatedElements) {
    this.updatedElement = {
        id : (shape && shape.id) || null,
        type : (shape && shape.type) || null,
        relatedObject: shape,
        relatedElements : relatedElements
    };
    $(this.html).trigger('removeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - width
 * - height
 *
 * @param {CustomShape} shape The shape that updated its dimension
 * @param {number} oldWidth The old width of `shape`
 * @param {number} oldHeight The old height of `shape`
 * @param {number} newWidth The new width of `shape`
 * @param {number} newHeight The old height of `shape`
 * @chainable
 */
Canvas.prototype.triggerDimensionChangeEvent = function (shape, oldWidth,
            oldHeight, newWidth, newHeight) {
    this.updatedElement = [{
        id : shape.id,
        type : shape.type,
        fields : [
            {
                field : "width",
                oldVal : oldWidth,
                newVal : newWidth
            },
            {
                field : "height",
                oldVal : oldHeight,
                newVal : newHeight
            }
        ],
        relatedObject: shape
    }];
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - x
 * - y
 * - parent (the shape that is parent of this shape)
 * - state (of the connection)
 *
 * @param {Port} port The port updated
 * @chainable
 */
Canvas.prototype.triggerPortChangeEvent = function (port) {
    this.updatedElement = [{
        id: port.getID(),
        type: port.type,
        fields: [
            {
                field: 'x',
                oldVal: port.getOldX(),
                newVal: port.getX()
            },
            {
                field: 'y',
                oldVal: port.getOldY(),
                newVal: port.getY()
            },
            {
                field: 'parent',
                oldVal: port.getOldParent().getID(),
                newVal: port.getParent().getID()
            },
            {
                field: 'state',
                oldVal: port.connection.getOldPoints(),
                newVal: port.connection.savePoints() &&
                    port.connection.getPoints()
            }
        ],
        relatedObject: port
    }];

    console.log('port change!');
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - state (of the connection)
 *
 * @param {Connection} connection The connection updated
 * @chainable
 */
Canvas.prototype.triggerConnectionStateChangeEvent = function (connection) {
    var points = [],
        point,
        i;
    connection.savePoints();
    for (i = 0; i < connection.points.length; i += 1) {
        point = connection.points[i];
        points.push(new Point(point.x / this.zoomFactor, point.y / this.zoomFactor));
    }
    this.updatedElement = [{
        id: connection.getID(),
        type: connection.type,
        fields: [
            {
                field: 'state',
                oldVal: connection.getOldPoints(),
                newVal: points
            }
        ],
        relatedObject: connection
    }];

    console.log('connection state change!');
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - x
 * - y
 *
 * @param {Array} shapes The shapes that were updated
 * @param {Array} before The state of the shapes before they were repositioned
 * @param {Array} after The state of the shapes after they were repositioned
 * @chainable
 */
Canvas.prototype.triggerPositionChangeEvent = function (shapes, before, after) {
    var i,
        elements = [];
    for (i = 0; i < shapes.length; i += 1) {
        elements.push({
            id : shapes[i].getID(),
            type : shapes[i].type,
            fields : [
                {
                    field : "x",
                    oldVal : before[i].x,
                    newVal : after[i].x
                },
                {
                    field : "y",
                    oldVal : before[i].y,
                    newVal : after[i].y
                }
            ],
            relatedObject : shapes[i]
        });
    }

    this.updatedElement = elements;
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - message
 *
 * @param {CustomShape} element The shape that updated one of ots labels
 * @param {string} oldText The old text of the label
 * @param {string} newText The new text of the label
 * @chainable
 */
Canvas.prototype.triggerTextChangeEvent = function (element, oldText, newText) {
    this.updatedElement = [{
        id : element.id,
        type : element.type,
        parent : element.parent,
        fields : [
            {
                field : "message",
                oldVal : oldText,
                newVal : newText
            }
        ],
        relatedObject: element
    }];
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Fires the {@link Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - parent
 * - x
 * - y
 *
 * @param {Array} shapes The shapes that were updated
 * @param {Array} before The state of the shapes before they were repositioned
 * @param {Array} after The state of the shapes after they were repositioned
 * @chainable
 */
Canvas.prototype.triggerParentChangeEvent = function (shapes, before, after) {

    var i,
        elements = [];
    for (i = 0; i < shapes.length; i += 1) {
        elements.push({
            id : shapes[i].getID(),
            type : shapes[i].type,
            fields : [
                {
                    field : "parent",
                    oldParent: before[i].parent,
                    newVal : after[i].parent

                },
                {
                    field : "x",
                    oldVal : before[i].x,
                    newVal : after[i].x
                },
                {
                    field : "y",
                    oldVal : before[i].y,
                    newVal : after[i].y
                }
            ],
            relatedObject : shapes[i]
        });
    }

    this.updatedElement = elements;
    $(this.html).trigger('changeelement');
    return this;
};

/**
 * Sets the top scroll of this canvas.
 * @param {number} newScroll
 * @chainable
 */
Canvas.prototype.setTopScroll = function (newScroll) {
    this.topScroll = newScroll;
    return this;
};
/**
 * Sets the left scroll of this canvas.
 * @param {number} newScroll
 * @chainable
 */
Canvas.prototype.setLeftScroll = function (newScroll) {
    this.leftScroll = newScroll;
    return this;
};
/**
 * Sets the zoom Factor applied in the canvas
 * @param {number} newZoom
 * @chainable
 */
Canvas.prototype.setZoomFactor = function (newZoom) {
    if (typeof newZoom === "number" && newZoom % 25 === 0 && newZoom > 0) {
        this.zoomFactor = newZoom;
    }
    return this;
};
/**
 * Sets the currentConnection of this canvas.
 * @param {Connection} newConnection
 * @chainable
 */
Canvas.prototype.setCurrentConnection = function (newConnection) {
    if (newConnection.type === "Connection") {
        this.currentConnection = newConnection;
    }
    return this;
};

/**
 * Assigns `newFunction` as `Canvas.prototype.toolbarShapeFactory` so that
 * the canvas has a reference to the shapes that will be created when they
 * are dragged from the toolbar.
 * @param {Function} newFunction
 * @chainable
 */
Canvas.prototype.setToolBarShapeFactory = function (newFunction) {
    Canvas.prototype.toolBarShapeFactory = newFunction;
    return this;
};

/**
 * Gets the current zoom factor applied in the canvas
 * @return {number}
 */
Canvas.prototype.getZoomFactor = function () {
    return this.zoomFactor;
};

/**
 * Gets the index where the zoom properties are located for the current
 * zoom factor.
 * @return {number}
 */
Canvas.prototype.getZoomPropertiesIndex = function () {
    return this.zoomPropertiesIndex;
};

/**
 * Gets the segment used to make connections in the canvas.
 * @return {Segment}
 */
Canvas.prototype.getConnectionSegment = function () {
    return this.connectionSegment;
};

/**
 * Gets the left scroll position of the canvas.
 * @return {number}
 */
Canvas.prototype.getLeftScroll = function () {
    return this.leftScroll;
};

/**
 * Gets the top scroll position of the canvas.
 * @return {number}
 */
Canvas.prototype.getTopScroll = function () {
    return this.topScroll;
};

/**
 * Gets the current connection stored in this canvas.
 * @return {Connection}
 */
Canvas.prototype.getCurrentConnection = function () {
    return this.currentConnection;
};

/**
 * Gets the current selection of this canvas.
 * @return {ArrayList}
 */
Canvas.prototype.getCurrentSelection = function () {
    return this.currentSelection;
};

/**
 * Gets all the connections of this canvas.
 * @return {ArrayList}
 */
Canvas.prototype.getConnections = function () {
    return this.connections;
};

/**
 * Gets all the shared connections stored in this canvas.
 * @return {ArrayList}
 */
Canvas.prototype.getSharedConnections = function () {
    return this.sharedConnections;
};

/**
 * Gets all the custom shapes of the canvas.
 * @return {ArrayList}
 */
Canvas.prototype.getCustomShapes = function () {
    return this.customShapes;
};

/**
 * Gets all the regular shapes of the canvas.
 * @return {ArrayList}
 */
Canvas.prototype.getRegularShapes = function () {
    return this.regularShapes;
};
/**
 * Gets the multiple selection container instance.
 * @return {MultipleSelectionContainer}
 */
Canvas.prototype.getMultipleSelectionHelper = function () {
    return this.multipleSelectionHelper;
};

/**
 * Gets the horizontal snapper of this canvas.
 * @return {Snapper}
 */
Canvas.prototype.getHorizontalSnapper = function () {
    return this.horizontalSnapper;
};

/**
 * Gets the vertical snapper of this canvas.
 * @return {Snapper}
 */
Canvas.prototype.getVerticalSnapper = function () {
    return this.verticalSnapper;
};

/**
 * Gets the last updated element in the canvas
 * @return {Mixed}
 */
Canvas.prototype.getUpdatedElement = function () {
    return this.updatedElement;
};

/**
 * Any instance of the class Canvas is not resizable so this method
 * will always return false.
 * @return {boolean}
 */
Canvas.prototype.isResizable = function () {
    return false;
};

/**
 * Gets a reference to itself.
 * @return {Canvas}
 */
Canvas.prototype.getCanvas = function () {
    return this;
};

/**
 * Undoes the last action in the canvas by calling `this.commandStack.undo`.
 * @chainable
 */
Canvas.prototype.undo = function () {
    this.commandStack.undo();
    return this;
};

/**
 * Redoes the last action in the canvas by calling `this.commandStack.redo`.
 * @chainable
 */
Canvas.prototype.redo = function () {
    this.commandStack.redo();
    return this;
};

/**
 * Serializes this canvas by serializing its customShapes, regularShapes and connections.
 * @return {Object}
 * @return {Object} return.customShapes See {@link CustomShape#stringify}
 * @return {Object} return.regularShapes See {@link Shape#stringify}
 * @return {Object} return.connections See {@link Connection#stringify}
 */
Canvas.prototype.stringify = function () {

    var i,
        customShapes = [],
        regularShapes = [],
        connections = [],
        inheritedJSON,
        thisJSON;

    // serialize custom shapes
    for (i = 0; i < this.customShapes.getSize(); i += 1) {
        customShapes.push(this.customShapes.get(i).stringify());
    }

    // serialize regular shapes
    for (i = 0; i < this.regularShapes.getSize(); i += 1) {
        regularShapes.push(this.regularShapes.get(i).stringify());
    }

    // serialize connections shapes
    for (i = 0; i < this.connections.getSize(); i += 1) {
        connections.push(this.connections.get(i).stringify());
    }

    inheritedJSON = Shape.prototype.stringify.call(this);
    thisJSON = {
        customShapes: customShapes,
        regularShapes: regularShapes,
        connections: connections
    };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * Adds shape and its children to `this.shapesToCopy` array so that later
 * they can be pasted in the canvas.
 * @param {Shape} shape
 * @chainable
 */
Canvas.prototype.addToShapesToCopy = function (shape) {
    var i,
        child;
    this.shapesToCopy.push(shape.stringify());
    for (i = 0; i < shape.getChildren().getSize(); i += 1) {
        child = shape.getChildren().get(i);
        this.addToShapesToCopy(child);
    }
    return this;
};

/**
 * Duplicates the `this.sharedConnection` array and the shapes stored in `this.currentSelection`
 * array (saving them in `this.shapesToCopy` and `this.connectionsToCopy` respectively) so
 * that they can be pasted later in the canvas.
 * @chainable
 */
Canvas.prototype.copy = function () {
    var i,
        shape,
        connection;

    // duplicate shapes
    this.shapesToCopy = [];
    for (i = 0; i < this.getCurrentSelection().getSize(); i += 1) {
        shape = this.getCurrentSelection().get(i);
        this.addToShapesToCopy(shape);
    }

    // duplicate connections
    this.connectionsToCopy = [];
    for (i = 0; i < this.getSharedConnections().getSize(); i += 1) {
        connection = this.getSharedConnections().get(i);
        this.connectionsToCopy.push(connection.stringify());
    }

    console.log('shapes: ' + this.shapesToCopy.length);
    console.log('conn: ' + this.connectionsToCopy.length);
    /*
        // testing method Canvas.prototype.transformToTree(tree)
        var tree = [];
        for (i = 0; i < this.shapesToCopy.length; i += 1) {
            shape = this.shapesToCopy[i];
            tree.push({id: shape.id, parent: shape.parent});
        }
        console.log(this.transformToTree(tree));
    */
    return this;
};

/**
 * Pastes the shapes saved in `this.shapesToCopy` and the connections saved in `this.connectionsToCopy`
 * by calling the #parse method.
 *
 * Currently the parser is called with these arguments:
 *
 *       {
 *          shapes: this.shapesToCopy,
 *          connections: this.connectionsToCopy,
 *          createCommand: true,
 *          uniqueID: true,
 *          selectAfterFinish: true,
 *          prependMessage: "Copy of ",
 *          diffX: 100,
 *          diffY: 100
 *      }
 *
 * @chainable
 */
Canvas.prototype.paste = function () {
    this.parse({
        shapes: this.shapesToCopy,
        connections: this.connectionsToCopy,
        createCommand: true,
        uniqueID: true,
        selectAfterFinish: true,
        prependMessage: "Copy of ",
        diffX: 100,
        diffY: 100
    });
    return this;
};

/**
 * Default copy paste factory which creates new instances of {@link CustomShape}, its main purpose
 * is to create instances using `this.copyAndPasteReferences` (passed through the config options of the canvas)
 * which are reference variables to the constructor of some class (a class declared outside the library).
 *
 *      // let's assume that there's a class declared outside the library called BpmnActivity
 *      var BpmnActivity = function (options) {
 *          ...
 *      };
 *
 *      // in the config options of this canvas, we passed a reference to the constructor like this
 *      var canvas = new Canvas({
 *          ...
 *          copyAndPasteReferences: {
 *              bpmnActivity: BpmnActivity
 *          }
 *          ...
 *      });
 *
 *      // so the shapeFactory will create an instance of the class BpmnActivity
 *      // using that reference
 *      // i.e.
 *      // let's assume that options are the correct configuration options for BpmnActivity
 *      var bpmnActivityInstance = Canvas.prototype.shapeFactory('bpmnActivity', options);
 *
 *
 * @param {string} type The type of the shape to be created
 * @param {Object} options The config options to be passed to the constructor of the shape
 * @return {CustomShape} A custom shape or shape created using the reference created before.
 */
Canvas.prototype.shapeFactory = function (type, options) {
    if (this.copyAndPasteReferences[type]) {
        return new this.copyAndPasteReferences[type](options);
    }
    return new CustomShape(options);
};

/**
 * Factory to create connections
 * @param {string} type
 * @param {Object} options
 * @return {Object}
 */
Canvas.prototype.connectionFactory = function (type, options) {
    if (type && this.copyAndPasteReferences[type]) {
        return new this.copyAndPasteReferences[type](options);
    }
    return new Connection(options);
};

/**
 * Transforms an array of objects, each of the form `{id: #, parent: #}` to a tree like object.
 * The structure of the returned object (which represents a tree) is:
 *
 *      {
 *          id_1: [child_1_of_id1, child_2_of_id1, ...],
 *          id_2: [child_1_of_id2, child_2_of_id2, ...],
 *          ...
 *      }
 *
 * @param {Array} nodes
 * @return {Object}
 */
Canvas.prototype.transformToTree = function (nodes) {
    var tree = {},
        node,
        i;
    for (i = 0; i < nodes.length; i += 1) {
        // node = {id: #, parent: #, order: #}
        node = nodes[i];

        // create the children of node.id
        if (!tree[node.id]) {
            tree[node.id] = [];
        }

        // insert to the children of its parent
        if (node.parent) {
            // check if the node exists
            if (!tree[node.parent]) {
                tree[node.parent] = [];
            }

            // add node to the children of node's parent
            tree[node.parent][node.order] = node.id;
        }
    }

    return tree;
};

/**
 * Given a tree (with the structure proposed in #transformToTree)
 * and a pointer to the root node, perform a levelOrder traversal (BFS)
 * of the tree and returning an array with the IDs of each node.
 * @param {Object} tree
 * @param {String} [root=canvas.getID()] The ID of the root node (might be canvas)
 * @return {Array} An array with the IDs of the nodes of the tree in level order traversal
 */
Canvas.prototype.levelOrderTraversal = function (tree, root) {
    var queue = [],
        processed = [],                     // processed shapes
        top,
        realRoot = root || this.getID(),
        i;

    queue.push(realRoot);
    while (queue.length > 0) {
        top = queue.shift();

        // push the json of the node
        processed.push(top);

        // push to the queue
        for (i = 0; i < tree[top].length; i += 1) {
            queue.push(tree[top][i]);
        }
    }

    // return the IDs
    return processed;
};

/**
 * Parses `options` creating shapes and connections and placing them in this canvas.
 * It does the following:
 *
 * - Creates each shape (in the same order as it is in the array `options.shapes`)
 * - Creates each connection (in the same order as it is in the array `options.connections`)
 * - Creates the an instance of {@link CommandPaste} (if possible)
 *
 * @param {Object} options
 * @param {Array} [options.shapes=[]] The config options of each shape to be placed in this canvas.
 * @param {Array} [options.connections=[]] The config options of each connection to be placed in this canvas.
 * @param {boolean} [options.uniqueID=false] If set to true, it'll assign a unique ID to each shape created.
 * @param {boolean} [options.selectAfterFinish=false] If set to true, it'll add the shapes that are
 * direct children of this canvas to `this.currentSelection` arrayList.
 * @param {string} [options.prependMessage=""] The message to be prepended to each shape's label.
 * @param {boolean}  [options.createCommand=true] If set to true it'll create a command for each creation
 * of a shape and connection (see {@link CommandCreate}, {@link CommandConnect}) and save them in
 * a {@link CommandPaste} (for undo-redo purposes).
 * @param {number} [options.diffX=0] The number of pixels on the x-coordinate to move the shape on creation
 * @param {number} [options.diffY=0] The number of pixels on the y-coordinate to move the shape on creation
 * @chainable
 */
Canvas.prototype.parse = function (options) {
    var defaults = {
        shapes: [],
        connections: [],
        uniqueID: false,
        selectAfterFinish: false,
        prependMessage: "",
        createCommand: true,
        diffX: 0,
        diffY: 0
    },
        i,
        j,
        id,
        oldID,
        shape,
        points,
        shapeOptions,
        connection,
        connectionOptions,
        sourcePort,
        sourcePortOptions,
        sourceShape,
        sourceBorder,
        destPort,
        destPortOptions,
        destShape,
        destBorder,
        command,
        diffX,
        diffY,
        connectionConstructor,
        stackCommandCreate = [],
        stackCommandConnect = [],
        canvasID = this.getID(),
        mapOldId = {},              // {oldId: newId}
        map = {},                   // {newId: reference to the shape},
        connectExtendedOptions = {};

    $.extend(true, defaults, options);

    // set the differentials (if the shapes are pasted in the canvas)
    diffX = defaults.diffX;
    diffY = defaults.diffY;

    // map the canvas
    map[canvasID] = this;
    mapOldId[canvasID] = canvasID;

    // empty the current selection and sharedConnections as a consequence
    // (so that the copy is selected after)
    if (defaults.selectAfterFinish) {
        this.emptyCurrentSelection();
    }

    for (i = 0; i < defaults.shapes.length; i += 1) {
        shapeOptions = {};
        $.extend(true, shapeOptions, defaults.shapes[i]);

        // set the canvas of <shape>
        shapeOptions.canvas = this;

        // create a map of the current id with a new id
        oldID = shapeOptions.id;
        // generate a unique id on user request
        if (defaults.uniqueID) {
            shapeOptions.id = Utils.generateUniqueId();
        }
        mapOldId[oldID] = shapeOptions.id;

        // change labels' messages (using prependMessage)
        if (shapeOptions.labels) {
            for (j = 0; j < shapeOptions.labels.length; j += 1) {
                shapeOptions.labels[j].message = defaults.prependMessage +
                    shapeOptions.labels[j].message;
            }
        }

        // create an instance of the shape based on its type
        shape = this.shapeFactory(shapeOptions.type, shapeOptions);

        // map the instance with its id
        map[shapeOptions.id] = shape;

        // if the shapes don't have a valid parent then set the parent
        // to be equal to the canvas
        // TODO: ADD shapeOptions.topLeftOnCreation TO EACH SHAPE
        if (!mapOldId[shapeOptions.parent]) {
            this.addElement(shape,
                shapeOptions.x + diffX, shapeOptions.y + diffY, true);
        } else if (shapeOptions.parent !== canvasID) {
            // get the parent of this shape
            map[mapOldId[shapeOptions.parent]].addElement(shape, shapeOptions.x,
                shapeOptions.y, true);
        } else {
            // move the shapes a little (so it can be seen that
            // they were duplicated)
            map[mapOldId[shapeOptions.parent]].addElement(shape,
                shapeOptions.x + diffX, shapeOptions.y + diffY, true);
        }
        // perform some extra actions defined for each shape
        shape.parseHook();

        shape.attachListeners();

//        console.log(shape);
        // execute command create but don't add it to the canvas.commandStack
        command = new CommandCreate(shape);
        command.execute();
        stackCommandCreate.push(command);
    }

    for (i = 0; i < defaults.connections.length; i += 1) {
        connectionOptions = {};
        $.extend(true, connectionOptions, defaults.connections[i]);

        // state of the connection
        points = connectionOptions.state || [];

        // determine the shapes
        sourcePortOptions = connectionOptions.srcPort;
        sourceShape = map[mapOldId[sourcePortOptions.parent]];
        sourceBorder = sourceShape.getBorderConsideringLayers();

        destPortOptions = connectionOptions.destPort;
        destShape = map[mapOldId[destPortOptions.parent]];
        destBorder = destShape.getBorderConsideringLayers();

        // populate points if points has no info (backwards compatibility,
        // i.e. the flow state is null)
        if (points.length === 0) {
            points.push({
                x: sourcePortOptions.x + sourceShape.getAbsoluteX(),
                y: sourcePortOptions.y + sourceShape.getAbsoluteY()
            });
            points.push({
                x: destPortOptions.x + destShape.getAbsoluteX(),
                y: destPortOptions.y + destShape.getAbsoluteY()
            });
        }

        //create the ports
        sourcePort = new Port({
            width: 12,
            height: 12
        });
        destPort = new Port({
            width: 12,
            height: 12
        });

        // add the ports to the shapes
        // LOGIC: points is an array of points relative to the canvas.
        // CustomShape.addPort() requires that the point passed as an argument
        // is respect to the shape, so transform the point's coordinates (also
        // consider the border)
        sourceShape.addPort(
            sourcePort,
            points[0].x + diffX + sourceBorder -
                sourceShape.getAbsoluteX(),
            points[0].y + diffX + sourceBorder -
                sourceShape.getAbsoluteY()
        );
        destShape.addPort(
            destPort,
            points[points.length - 1].x + diffX + destBorder -
                destShape.getAbsoluteX(),
            points[points.length - 1].y + diffY + destBorder -
                destShape.getAbsoluteY(),
            false,
            sourcePort
        );

        connectExtendedOptions = $.extend(true, {}, defaults.connections[i],
            {
                srcPort : sourcePort,
                destPort: destPort,
                canvas : this,
                segmentStyle: connectionOptions.segmentStyle
            }
        );
        connection = this.connectionFactory(connectionOptions.type,
            connectExtendedOptions);

        connection.id = connectionOptions.id || Utils.generateUniqueId();
        if (defaults.uniqueID) {
            connection.id = Utils.generateUniqueId();
        }

        //set its decorators
        connection.setSrcDecorator(new ConnectionDecorator({
            width: 11,
            height: 11,
            canvas: this,
            decoratorPrefix: connectionOptions.srcDecoratorPrefix,
            decoratorType: "source",
            parent: connection
        }));
        connection.setDestDecorator(new ConnectionDecorator({
            width: 11,
            height: 11,
            canvas: this,
            decoratorPrefix: connectionOptions.destDecoratorPrefix,
            decoratorType: "target",
            parent: connection
        }));

        command = new CommandConnect(connection);
        stackCommandConnect.push(command);

        //connect the two ports
        if (points.length >= 3) {
//            console.log("user");
            connection.connect({
                algorithm: 'user',
                points: connectionOptions.state,
                dx: defaults.diffX,
                dy: defaults.diffY
            });
        } else {
            // use manhattan
//            console.log("manhattan");
            connection.connect();
        }
        connection.setSegmentMoveHandlers();

        // / fixes the zIndex of the connection
        //connection.fixZIndex();

        //add the connection to the canvas, that means insert its html to
        // the DOM and adding it to the connections array
        this.addConnection(connection);

        // now that the connection was drawn try to create the intersections
        connection.checkAndCreateIntersectionsWithAll();

        //attaching port listeners
        sourcePort.attachListeners(sourcePort);
        destPort.attachListeners(destPort);

        this.triggerCreateEvent(connection, []);
    }

    // finally add to currentSelection each shape if possible (this method is
    // down here because of the zIndex problem with connections)
    if (defaults.selectAfterFinish) {
        for (id in map) {
            if (map.hasOwnProperty(id)) {
                if (map[id].family !== 'Canvas') {
                    this.addToSelection(map[id]);
                }
            }
        }
    }

    // create command if possible
    if (defaults.createCommand) {
        this.commandStack.add(new CommandPaste(this, {
            stackCommandCreate: stackCommandCreate,
            stackCommandConnect: stackCommandConnect
        }));
    }
    return this;
};

///**
// * Testing json (easy viewing of the json file)
// * @param object
// */
//Canvas.prototype.stringifyAndSaveToFile = function (object) {
//    $.ajax({
//        url: '../src/json_test/output.php',
//        type: 'POST',
//        data: {
//            json: object
//        }
//    });
//    window.open('../src/json_test/output.json', '_blank');
//};



       /**
     * KEYBOARD EVENTS
     */
    $(document).keydown(function (e) {
    //        console.log(e.which);
        if (activeCanvas) {
            switch (e.which) {
                case 16: // SHIFT KEY
                    isShift = true;
                    break;
                case 17: // CTRL KEY
                    isCtrl = true;
                    break;
                case 116: // F5 KEY
                    e.preventDefault();
                    window.location.reload(true);
                    break;
                case 37:
                    // Left
                    if (!activeCanvas.currentLabel) {
                        e.preventDefault();
                        activeCanvas.moveElements(activeCanvas, 'LEFT');
                    }
                    break;
                case 38:
                    // Top
                    if (!activeCanvas.currentLabel) {
                        e.preventDefault();
                        activeCanvas.moveElements(activeCanvas, 'TOP');
                    }
                    break;
                case 39:
                    // Right
                    if (!activeCanvas.currentLabel) {
                        e.preventDefault();
                        activeCanvas.moveElements(activeCanvas, 'RIGHT');
                    }
                    break;
                case 40:
                    // Bottom
                    if (!activeCanvas.currentLabel) {
                        e.preventDefault();
                        activeCanvas.moveElements(activeCanvas, 'BOTTOM');
                    }
                    break;
                case 67:    // char 'c'
                    if (!activeCanvas.currentLabel && isCtrl) {
                        e.preventDefault();
                        activeCanvas.copy();
                    }
                    break;
                case 86:    // char 'v'
                    if (!activeCanvas.currentLabel && isCtrl) {
                        e.preventDefault();
                        activeCanvas.paste();
                    }
                    break;
                case 90:    // char 'z'
                    if (isCtrl) {
                        if (isShift) {
                            // ctrl + shift + z (redo)
                            activeCanvas.redo();
                            e.preventDefault();
                        } else {
                            // ctrl + z (undo)
                            activeCanvas.undo();
                            e.preventDefault();
                        }
                    }
                    break;
            }
        }
    }).keypress(function (e) {

        }).keyup(function (e) {
            var current;
            e.preventDefault();
            switch (e.which) {
                case 8:  //BACKSPACE
                    if (isCtrl) {
                        if (activeCanvas && !activeCanvas.currentLabel) {
                            activeCanvas.removeElements();
                        }
                    }
                    break;
                case 13:    // ENTER
                    if (activeCanvas && activeCanvas.currentLabel) {
                        activeCanvas.currentLabel.loseFocus();
                    }
                    break;
                case 46: // DELETE KEY
                    if (activeCanvas && !activeCanvas.currentLabel) {
                        activeCanvas.removeElements();
                    }
                    break;
                case 16: // SHIFT KEY
                    isShift = false;
                    break;
                case 17: //CTRL KEY
                    isCtrl = false;
                    break;
                case 113: //F2 KEY
                    if (activeCanvas &&
                        activeCanvas.getCurrentSelection().getLast() !== null) {
                        //Run other code here when the element
                        // 'CurElement' is deleted
                        current = activeCanvas.getCurrentSelection().getLast();
                        if (current !== undefined && current.label.html !== null) {
                            $(current.label.html).dblclick();
                            $(current.label.text.html).focus();
                        }
                    }
                    break;
            }
        });


    return {
        ArrayList: ArrayList,
        Point: Point,
        Geometry: Geometry,
        Graphics: Graphics,
        Utils: Utils,

        Command: Command,
        CommandStack: CommandStack,
        CommandResize: CommandResize,
        CommandConnect: CommandConnect,
        CommandReconnect: CommandReconnect,
        CommandSegmentMove: CommandSegmentMove,
        CommandMove: CommandMove,
        CommandCreate: CommandCreate,
        CommandSwitchContainer: CommandSwitchContainer,
        CommandDelete: CommandDelete,
        CommandPaste: CommandPaste,
        CommandEditLabel: CommandEditLabel,

        ContainerBehavior: ContainerBehavior,
        RegularContainerBehavior: RegularContainerBehavior,
        NoContainerBehavior: NoContainerBehavior,
        DragBehavior: DragBehavior,
        RegularDragBehavior: RegularDragBehavior,
        NoDragBehavior: NoDragBehavior,
        ConnectionDragBehavior: ConnectionDragBehavior,
        CustomShapeDragBehavior: CustomShapeDragBehavior,
        ResizeBehavior: ResizeBehavior,
        RegularResizeBehavior: RegularResizeBehavior,
        NoResizeBehavior: NoResizeBehavior,
        DropBehavior: DropBehavior,
        ConnectionDropBehavior: ConnectionDropBehavior,
        NoDropBehavior: NoDropBehavior,
        ContainerDropBehavior: ContainerDropBehavior,
        ConnectionContainerDropBehavior: ConnectionContainerDropBehavior,

        Color: Color,
        Style: Style,
        JCoreObject: JCoreObject,
        Handler: Handler,
        ReadOnlyLayer: ReadOnlyLayer,
        ResizeHandler: ResizeHandler,
        SegmentMoveHandler: SegmentMoveHandler,
        Port: Port,
        Router: Router,
        ManhattanConnectionRouter: ManhattanConnectionRouter,
        ConnectionDecorator: ConnectionDecorator,
        Connection: Connection,

        BehavioralElement: BehavioralElement,
        Layer: Layer,
        Shape: Shape,
        Label: Label,
        CustomShape: CustomShape,
        Segment: Segment,

        RegularShape: RegularShape,
        Polygon: Polygon,
        Rectangle: Rectangle,
        Oval: Oval,
        Arc: Arc,
        MultipleSelectionContainer: MultipleSelectionContainer,

        Intersection: Intersection,
        Snapper: Snapper,
        Canvas: Canvas,

        /**
         * Sets the active canvas.
         * @param {Canvas} canvas
         * @chainable
         */
        setActiveCanvas: function (canvas) {
            activeCanvas = canvas;
            return this;
        },
        /**
         * Gets the active canvas
         * @return {Canvas}
         */
        getActiveCanvas: function () {
            return activeCanvas;
        },
        /**
        * Get jCore Version.
        * @return {String}
        */
        getVersion: function () {
            return version;
        }
    };

}(jQuery, window));


/**
 * @fileoverview jquery.progrid.js
 * @brief jQuery plugin to create a grid with input/select elements within it 
 * @author  Daniel Canedo
 * @date 20130125
 * @version 2.0
 * @requires jQuery
*/

(function( $ ) {

    var defaultPrefix = 'progrid', 
    defaultSettings = {
        id: null, 
        rows: [],
        width: '100%',
        fontSize: '11px',
        prefix: defaultPrefix,
        onValueChanged: null,
        onChangeDiscarded: null,
        onViewMode: null,
        onEditMode: null,
        onRowsInitialized: null,
        onRowSelected: null,
        onRowDeselected: null,
        onGridReady: null
    },
    instances = 0,
    createRow = function( settings, prefix ){
        if(!settings.name) {
            $.error('name setting is required!');
        }
        var defaultSettings = $.extend({
                label: '',
                type: '',
                readOnly: false,
                trueLabel: 'true',
                falseLabel: 'false',
                yesNoValueMode: 'boolean',
                validate: 'none'
            }, settings),
            row = {
                name: defaultSettings.name,
                label: defaultSettings.label,
                type: defaultSettings.type,
                readOnly: defaultSettings.readOnly
            },
            html = null,
            value = null,
            valueText = null,
            addSelectRowListener = function(flag) {
                if(typeof flag === 'undefined' || flag) {
                    $(html).find('td').on('selectRow', onSelectRow);
                    $(html).on("click", function(){
                        $(this).find("td:last").trigger("selectRow");
                    });
                } else {
                    $(html).find('td').off('selectRow', onSelectRow);
                    $(html).off("click");
                }
            },
            addDeselectRowListener = function(flag) {
                if(typeof flag === 'undefined' || flag) {
                    $(html).find('td').on('focusout', onDeselectRow);
                } else {
                    $(html).find('td').off('focusout', onDeselectRow);
                }
            },
            onSelectRow = function(){
                var row = $(this).parent(),
                    obj = row.data("rowObject");

                addSelectRowListener(false);

                if(typeof obj.onSelected === 'function'){
                    obj.onSelected.call(obj);
                }

                if(obj.readOnly) {
                    $(html).find('td:last div').focus();
                    addDeselectRowListener();
                    return;
                }
                obj.editMode();
                addDeselectRowListener();
            },
            onDeselectRow = function() {
                var row = $(this).parent(),
                    obj = row.data("rowObject");
                addDeselectRowListener(false);
                obj.editMode(false, false);
                addSelectRowListener();
                if(typeof obj.onRowDeselected === 'function') {
                    obj.onRowDeselected.call(obj);
                }
            },
            setViewModeEvents = function(){
                $(this.getHTML()).find("td:last div").on("focus", function(){
                    $(this.parentNode).trigger("selectRow");
                }).on('keydown', function(e){
                    e.stopPropagation();
                    if(e.keyCode === 13)
                        $(this.parentNode).trigger("selectRow");
                });
            },
            getCurrentSelectedValue = function(){
                var selectedValue = $(html).find('td:last > *').val();

                //we get the current selected value
                switch(this.type){
                    case 'text':
                        selectedValue = defaultSettings.validate === 'integer'?parseInt(selectedValue, 10):selectedValue;
                        break;
                    case 'yesNo':
                        switch(defaultSettings.yesNoValueMode){
                            case 'int':
                                selectedValue = parseInt(selectedValue, 10);
                                break;
                            case 'boolean':
                                selectedValue = selectedValue === "true"?true:false;
                        }
                        break;
                }

                return selectedValue;
            },
            discardChanges = function(){
                if(!this.readOnly) {
                    var valueDiscarded = getCurrentSelectedValue.call(this), 
                        currentValue = this.getValue();
                    this.editMode(false);
                    if(typeof this.onChangeDiscarded === 'function' && valueDiscarded !== currentValue) {
                        this.onChangeDiscarded.call(this, {
                            valueDiscarded: valueDiscarded,
                            currentValue: currentValue
                        });
                    }
                }
            };

        row.onValueChanged = null;

        row.onSelected = null;

        row.onEditMode = null;

        row.onViewMode = null;

        row.onChangeDiscarded = null;

        row.onRowDeselected = null;

        row.getValue = function() {
            return value;
        };

        row.updateValueText = function() {
            valueText = this.getValue();
            switch (this.type) {
                case 'text':
                    valueText = value.toString();
                    break;
                case 'yesNo':
                        valueText = value?defaultSettings.trueLabel:defaultSettings.falseLabel;
                    break;
                case 'select':
                    if(!defaultSettings.options) {
                        valueText = "";
                        break;
                    }
                    for( i = 0; i < defaultSettings.options.length; i++) {
                        if (defaultSettings.options[i].value === valueText) {
                            valueText = defaultSettings.options[i].label;
                            break;
                        }
                    }
                    break;
            }
        };

        row.getValueText = function() {
            return valueText;
        };

        row.getHTML = function() {
            if(!html) {
                var value = this.getValueText(), i, that = this;
                html = document.createElement('tr');
                
                $(html).append('<td class="'+prefix+'-first-col"><div style="width:0px">'+this.label+'</div></td>'+
                    '<td class="'+prefix+'-second-col"><div tabindex="0" style="width:0px">'+(value?value:'')+'</div></td>');
                $(html).data("rowObject", this);
                addSelectRowListener(true);//$(html).find('td').on('selectRow', onSelectRow);
                //$(html).on("focusout", onDeselectRow);
                setViewModeEvents.call(this);
            }

            return html;
        };

        row.save = function(){
            if(defaultSettings.readOnly) {
                return;
            }
            var previousValue = this.getValue(),
                data,
                newValue = getCurrentSelectedValue.call(this);
            if(defaultSettings.validate === 'integer' && this.type === 'text') {
                previousValue = parseInt(previousValue, 10);
            }

            if(newValue !== previousValue){
                value = newValue;
                this.updateValueText();
                if(typeof this.onValueChanged === 'function') {
                    this.onValueChanged({
                        row: this,
                        newValue: newValue,
                        previousValue: previousValue
                    });   
                }
            }

            this.editMode(false);
        };

        row.editMode = function(edit, focus){
            var element, val, that = this,
                width = $(html.parentNode).width(),
                fontSize = parseInt($(html).css('font-size'),10),
                availableWidth = (width/2)-(fontSize*1.82);

            if(typeof edit === 'undefined' || edit){
                switch(this.type) {
                    case 'text':
                        element = $('<input>').addClass('input-small').attr({type:"text"}).val(this.getValueText()).css({
                            "width": availableWidth
                        });
                        if(defaultSettings.validate === 'integer'){
                            element.on('keydown', function(e){
                                e.stopPropagation();
                                if ( e.keyCode == 46 || e.keyCode == 8 || e.keyCode == 9 || e.keyCode == 27 || e.keyCode == 13 || 
                                    (e.keyCode == 65 && e.ctrlKey === true) || 
                                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                                         return;
                                }
                                else {
                                    if (e.shiftKey || (e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105 )) {
                                        e.preventDefault(); 
                                    }   
                                }
                            });
                        }
                        break;
                    case 'select':
                        element = $('<select>').css({
                            width: "100%"
                        });
                        for(i=0; i<this.options.length; i++)
                        {
                            name = this.options[i].label;
                            element.append($('<option label="'+name+'" value="'+this.options[i].value+'" '+((this.options[i].value === this.getValue())?'selected="selected"':'')+' '+(this.options[i].disabled?'disabled':'')+' >'+name+'</option>'));
                        }
                        break;
                    case 'yesNo':
                        if(typeof value === 'string'){
                            val = value;
                            val = val === 'true'?true:false;
                        } else {
                            val = !!value;
                        }
                        element = $('<select>').css({
                            width: "100%"
                        });
                        element.append($('<option label="'+defaultSettings.trueLabel+'" value="'+(defaultSettings.yesNoValueMode === 'int'?1:'true')+'" '+(val?'selected="selected"':'')+'>'+defaultSettings.trueLabel+'</option>'));
                        element.append($('<option label="'+defaultSettings.falseLabel+'" value="'+(defaultSettings.yesNoValueMode === 'int'?0:'false')+'" '+(!val?'selected="selected"':'')+'>'+defaultSettings.falseLabel+'</option>'));
                }
                element.on('focusout', function(){
                    that.save();
                }).on("click", function(e){
                    e.stopPropagation();
                }).on("keydown", function(e){
                    e.stopPropagation();
                    if(e.keyCode === 13)
                    {
                        that.save();
                    }else if(e.keyCode === 27){
                        discardChanges.call(that);
                    }
                });
                try{
                    $(html).find('td:last').empty();
                }catch(e){};
                $(html).find('td:last').append(element);
                element.focus();
                if(typeof this.onEditMode === 'function') {
                    this.onEditMode.call(this);
                }
                element.select();
            } else {
                try{
                    $(html).find('td:last').empty();
                }catch(e){};
                $(html).find('td:last').append($('<div tabindex="0" style="width: '+availableWidth+'px">'+this.getValueText()+'</div>'));
                if(typeof focus === 'undefined' || focus) {
                    $(html).find('td:last div').focus();
                }
                setViewModeEvents.call(this);
                if(typeof this.onViewMode === 'function') {
                    this.onViewMode.call(this);
                }
            }

        };

        prefix = prefix || defaultPrefix;

        if(row.type === 'select') {
            row.options = settings.options || [];
        }
        switch (row.type) {
            case 'text':
                value = (typeof defaultSettings.value !== 'undefined' && defaultSettings.value !== null && (defaultSettings.validate !== 'int'?defaultSettings.value.toString():parseInt(defaultSettings.value,10))) || '';
                break;
            case 'select':
                if(!defaultSettings.options) {
                    value = null;
                    break;
                }
                for( i = 0; i < defaultSettings.options.length; i++) {
                    if ((typeof defaultSettings.options[i].selected === 'boolean' && defaultSettings.options[i].selected) ||
                        (typeof defaultSettings.options[i].selected !== 'boolean' && defaultSettings.options[i].selected === defaultSettings.options[i].value)
                    ) {
                        value = defaultSettings.options[i].value;
                        break;
                    }
                }
                if(value === null && defaultSettings.options[0]) {
                    value = (defaultSettings.options && defaultSettings.options[0].value) || null;
                }
                break;
            case 'yesNo':
                if(typeof defaultSettings.value === 'string'){
                    value = defaultSettings.value.toLowerCase();
                    value = value === 'true'?true:false;
                } else {
                    value = !!defaultSettings.value;
                }
                switch(defaultSettings.yesNoValueMode){
                    case 'int':
                        value = value?1:0;
                        break;
                    case 'literal':
                        value = value?'true':'false';
                }
        }

        row.updateValueText();
        return row;
    },
    setWidth = function(width){
        if(typeof width !== 'undefined'){
            var theWidth;
            var fontSize = parseInt($(this).find('table.progrid-table').css("font-size"));
            if(isNaN(fontSize)) {
                fontSize = 0;
            }
            theWidth = $(this).find('table').find('td div').css({
                "width": "0px"
            }).end().css({
                "width": width
            }).width();
            theWidth = (theWidth/2)-(1.82*fontSize);
            $(this).find('td div').css({"width": theWidth});
        }
    },
    appendRow = function (row) {
        var i, j, aux, flag = false,
            rows = this.find('tr'), name;
        for(i = 0; i < rows.length; i++){
            name = $(rows[i]).data('rowObject').label;
            for(j=0; j < name.length; j++) {
                if(row.label === "" || row.label.charAt(j) < name.charAt(j)) {
                    flag = true;
                }
                break;
            }
            if(flag) {
                break;
            }
        }
        if(rows[i]) {
            $(rows[i]).before(row.getHTML());
        } else {
            this.append(row.getHTML());
        }
    },
    buildTable = function(settings){
        var $this = $(this),
            table = $(document.createElement('table')),
            i, row, body;
        table
            .css({"width": settings.width, "font-size": settings.fontSize})
            .addClass('progrid-table')
            .attr({'id': settings.prefix+'-propTable-'+instances, cellpadding:0, cellspacing:0, border:0});
        table.append($('<thead>').append($('<tr>').append('<th>Name</th>').append('<th>Value</th>')));
        body = $('<tbody>');

        for(i = 0; i < settings.rows.length; i++){
            row = createRow(settings.rows[i]);
            row.onSelected = function(){
                $(this.getHTML()).addClass('row_selected');
                if(typeof settings.onRowSelected === 'function') {
                    settings.onRowSelected.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name, 
                        fieldLabel: this.label,
                        fieldType: this.type,
                        value: this.getValue()
                    });
                }
            };
            row.onViewMode = function(){
                if(typeof settings.onViewMode === 'function') {
                    settings.onViewMode.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name, 
                        fieldLabel: this.label,
                        fieldType: this.type,
                        value: this.getValue()
                    });
                }
            };
            row.onEditMode = function(){
                if(typeof settings.onEditMode === 'function') {
                    settings.onEditMode.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name, 
                        fieldLabel: this.label,
                        fieldType: this.type,
                        value: this.getValue()
                    });
                }
            };
            row.onRowDeselected = function(){
                $(this.getHTML()).removeClass('row_selected');
                if(typeof settings.onRowDeselected === 'function') {
                    settings.onRowDeselected.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name,
                        fieldLabel: this.label,
                        fieldType: this.type,
                        value: this.getValue()
                    });
                }
            };
            row.onChangeDiscarded = function(data){
                if(typeof settings.onChangeDiscarded === 'function') {
                    settings.onChangeDiscarded.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name,
                        fieldLabel: this.label,
                        fieldType: this.type,
                        currentValue: data.currentValue,
                        discardedValue: data.valueDiscarded
                    });
                }
            };
            row.onValueChanged = function(data) {
                if(typeof settings.onValueChanged === 'function') {
                    settings.onValueChanged.call($this.get(0), {
                        id: settings.id,
                        fieldName: this.name,
                        fieldLabel: this.label,
                        fieldType: this.type,
                        value: data.newValue,
                        previousValue: data.previousValue
                    });
                }
            };
            $(row.getHTML()).addClass(i%2===0?'odd':'even');
            appendRow.call(body, row);
        }

        table.append(body);
        if(typeof settings.onRowsInitialized === 'function') {
            settings.onRowsInitialized.call($this.get(0), {
                rows: settings.rows
            });
        }

        $this.append(table);
    },
    methods = {
        /**
         * jQuery method to initialize the grid.
         * @param  {object} settings        Object that contains the settings for the grid creation,
         *                                  this settings are:
         *                                  {
         *                                      id: []
         *                                  }
         *                                  id: an identifier for the element related to the properties on the grid
         *                                  width: the width for the grid, defaults to 'auto'
         *                                  rows: an objects array, each object have the settings for every field in the grid, 
         *                                         this settings may vary depend on the type of field, 
         *                                         however, there are 3 settings that are used in all types, they are:
         *                                         
         *                                         name: the name for the field, always required,
         *                                         label: the text show as label for the field
         *                                         type: the field type, it can be 'text', 'selection', 'yesNo',
         *                                         readOnly: a boolean that indicates if the field will be a read only item
         *
         *                                         the other settings are:
         *
         *                                          value: inicates the initial value for the field.
         *                                              it can be applied only in text and yesNo type fields.
         *                                          validate: it can contain the value 'integer' for admit just integer values, 
         *                                              it can applied only in text type field. default to 'none'
         *                                          options: an objects array, only for select type field, 
         *                                              each object specify the settings for every option in the select type field, 
         *                                              the structure for each object is:
         *                                                  label: the label to show in the option,
         *                                                  value: the value for the option,
         *                                                  selected: an boolean or string that indicates id the option is selected, 
         *                                                      if the value is a string then it is compared with the value field, 
         *                                                      if they are identical then the option is selected.
         *                                           trueLabel: only for yesNo type field, a string specifies the label for the true option
         *                                           falseLabel:  only for yesNo type field, a string that specifies the label for the false option
         *                                           yeaNoValueMode: only for yesNo type field, it can be 'boolean', 'int', 'literal'
         *                                                   'boolean' returns javascript boolean values (true, false)
         *                                                   'int' returns javascript integer values (0, 1)
         *                                                   'literal' returns javascript strings ('true', 'false')
         *                                                the value field for the select yesNo typoe can be boolean, int or string type, 
         *                                                it will converted internally to the right type 
         *                                   prefix: a string to be used in the class name for the elements on grid,
         *                                   onViewMode: callback to be executed when some field of the grid enters to view mode,
         *                                   onEditMode: callback to be executed when some field of the grid enters to edit mode,        
         *                                   onRowsInitialized:  callback to be executed when all fields of the grid are built,        
         *                                   onRowSelected:  callback to be executed when some field of the grid is selected,        
         *                                   onRowDeselected:  callback to be executed when some field of the grid is deselected,        
         *                                   onGridReady: callback to be executed when the grid is built and ready to use
         *                                          
         * @return {jQuery object}          jQuery object the plugin was invoked on
         */
        init : function( settings ) {
            settings = $.extend({}, defaultSettings, settings);
            return this.each(function(){
                instances++;
                $(this).empty();
                buildTable.call(this, settings);
                setWidth.call(this, settings.width);
                $(this).trigger('gridready');
                if(typeof settings.onGridReady === 'function') {
                    settings.onGridReady.call(this);
                }
            });
        },
        /**
         * jQuery function to set the grid width
         * @param {number|string} width the width value for the grid, it can be in css format (i.e. '300px', 'auto')
         */
        setWidth: function(width){
            setWidth.call(this, width);
        }
    };

    $.fn.progrid = function( method ) {
        if( methods[method] ) {
            return methods[method].apply(this, Array.prototype.slice.call( arguments, 1 ));
        } else if( typeof method === 'object' || !method ) {
            return methods.init.apply(this, arguments);
        } else {

        }
    };


})( jQuery );
/** @fileoverview jquery.pmtree.js
 *  @author  Rodrigo Quelca
 *  @version 1.0
 *  @requires jQuery
 */


 /**
 * @class
 * @name jQuery
 * @exports $ as jQuery
 * @description pmtree is a <a href="http://jquery.com/">jQuery</a> plugin. The only fields and methods listed here are those that come as part of the pmtree library.
 */

(function( $ ) {
   /**
   * Creates a method object. This should be invoked as a method rather than constructed using new.
   * @class methods
   */
    var div = null;
    var methods = {
        /**
        * init method, the main methods for actions whit th tree
        * @constructs
        */
        init : function( options ) {
            
            var settings = {
                container: $(this),
                id        :'root'
            };
            return this.each(function(){
                if(options){
                    settings = $.extend(settings,options);
                }
                //HERE would be the code
                 var div =settings.container;
                //<div class="content_tree"></div>;
                div.append ($('<div>').addClass("content_tree"));
                //<ul id="root" class="menu"></ul>;
                var root = $('<ul>').attr({'class': 'tree-menu', id: settings.id});
                $('.content_tree').append(root);
                var tree=settings.items;
                if (typeof tree != 'undefined' && tree !== null)
                    createTree(root,tree);
                
                if (!options.collapsed) {
                    $('#'+settings.id+' ul').each(function() {
                        $(this).css("display", "none");
                    });
                }
                $('#'+settings.id+' .category').click(function() {
                    var childid = "#" + $(this).attr("childid");
			
                    if ($(childid).css("display") == "none") {
                        $(childid).css("display", "block");
                    } else {
                        $(childid).css("display", "none");
                    }
                    if ($(this).hasClass("tree_cat_close")) {
                        $(this).removeClass("tree_cat_close").addClass("tree_cat_open");
                    }	else {
                        $(this).removeClass("tree_cat_open").addClass("tree_cat_close");
                    }
                });
                $('.treechild').hover(
                    function(){
                        if ($(this).attr("status")=="unmarked"){
                            var id="#" + $(this).attr("id");
                            $(id).css("background","#EFF5FB");
                        }
                    },
                    function(){
                        if ($(this).attr("status")=="unmarked"){
                            var id="#" + $(this).attr("id");
                            $(id).css("background","#fff");
                        }
				
                    }
                    );

                $(".details").click(function(){
                    var id="#" + $(this).attr("desc");
                    $(".treechild").attr("status","unmarked");
                    $(".treechild").css("background","#fff");
			
                    $(id).css("background","#CEE3F6");
                    $(id).attr("status","marked");
                    var oShape = {};
                    if ($(this).attr("uid") !== undefined)
                        oShape.uid=$(this).attr("uid");
                    if ($(this).attr("name") !== undefined)
                        oShape.name=$(this).attr("name");
                    if ($(this).attr("type") !== undefined)
                        oShape.type=$(this).attr("type");
                    if (typeof settings.select !== 'undefined' && settings.select!== null) {
                        settings.select.call(this,oShape);
                    }
                });
                $('.treechild > a ').css({'text-decoration':'none'}); //clean a atribute decoratios
            });
        },
        
        
       
        /**
        * sample method
        * @param {String} a
        * @param {Object} b
        * @methodOf jQuery#
        * @name jQuery#example
        */
        example : function(a , b){}

    };
    /**
     *pmtree  method
     * @param {Object} method
    */
    $.fn.pmtree = function( method ) {
        if ( methods[method] ) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exsts!' );
        }
        return true;
    };
    
     /**
        * createTree method
        * @param {Object} root
        * @param {Object} tree
        * @return append the html new code added to #root div
        */
        function createTree (root, tree) {
            var html='';
            for (var i=0; i< tree.length; i++){
               var li = $('<li>');
               html = $('<div>').addClass('treechild').attr({id: i, status:'unmarked'}).css({'cursor':'pointer', 'text-decoration':'none'});
               html.append($('<a>').addClass('tree_cat_close category').attr({childid:'c_'+i}).html('&nbsp;&nbsp;&nbsp'));
               // html  =  '<li>	<div class="treechild" id="'+i+'" status="unmarked"> <a childid = "c_'+i+'" class="tree_cat_close category">&nbsp;&nbsp;&nbsp;</a>';
               
                //alert(tree[i].icon);
                if (typeof tree[i].icon !== 'undefined' && tree[i].icon !== null) {
                    //html += '<a desc="'+i+'" class="details" name="'+tree[i].name+'" uid="'+tree[i].id+'" type="'+tree[i].type+'"><i class="'+tree[i].icon+'"></i> '+tree[i].name+'</a>';
                     html.append( '<a desc="'+i+'" class="details" name="'+tree[i].name+'" uid="'+tree[i].id+'" type="'+tree[i].type+'"><i class="'+tree[i].icon+'"></i> '+tree[i].name+'</a>');
                }
                else
                    //html +=  '<a desc="'+i+'" class="details" name="'+tree[i].name+'" uid="'+tree[i].id+'" type="'+tree[i].type+'"><i class="tree-folder-open"></i> '+tree[i].name+'</a>';
                    html.append( '<a desc="'+i+'" class="details" name="'+tree[i].name+'" uid="'+tree[i].id+'" type="'+tree[i].type+'"><i class="tree-folder-open"></i> '+tree[i].name+'</a>');
               // html += '</div>'
                //html += '</li>'
                li.append(html);
               // $('#'+settings.id).append(li);
                if (typeof tree[i].items != "undefined" &&  tree[i].items !== null )	{
                   //html +=	methods.addNodes(tree[i].items,'c_'+i);
                   li.append(addNodes(tree[i].items,'c_'+i));
                }
                
                root.append(li);
                //$('#'+settings.id).append(html);
            }
        }
        /**
        * addNodes method
        * @param {object} node
        * @param {string} childid
        * @return {string} html the added nodes
        */
        function addNodes(node,childid) {
            var html = '';
            html += '<ul id="'+childid+'">' ;
            for (var i=0; i<node.length; i++){
                //alert(node[i].name)
                html += '<li>';
                if (typeof node[i].items != "undefined" &&  node[i].items !== null )	{
                    html += '<div class="treechild" id="'+childid+'_'+i+'" status="unmarked" style="cursor:pointer; text-decoration:none;"><a childid = "c_'+childid+'_'+i+'"+ class="tree_cat_close category">&nbsp;&nbsp;&nbsp;</a>'; 
                    if (node[i].icon != 'undefined' && node[i].icon !== null)
						html +='<a desc="'+childid+'_'+i+'" class="details" name="'+node[i].name+'" uid="'+node[i].id+'" type="'+node[i].type+'"><i class="'+node[i].icon+'"></i> '+node[i].name+'</a>';
                    else
                        html +='<a desc="'+childid+'_'+i+'" class="details" name="'+node[i].name+'" uid="'+node[i].id+'" type="'+node[i].type+'"><i class="tree-folder-open"></i> '+node[i].name+'</a>';
                    html += '</div>';
                    html +=	addNodes(node[i].items,'c_'+childid+'_'+i);
                } else {
                    html += '<div class="treechild" id="'+childid+'_'+i+'" status="unmarked" style="cursor:pointer; text-decoration:none;"><a class="product">&nbsp;&nbsp;&nbsp;</a>';
                    if (typeof node[i].icon != 'undefined' && node[i].icon !== null)
                        html +='<a desc="'+childid+'_'+i+'" class="details" name="'+node[i].name+'" uid="'+node[i].id+'" type="'+node[i].type+'"><i class="'+node[i].icon+'"></i> '+node[i].name+'</a>';
                    else
                        html +='<a desc="'+childid+'_'+i+'" class="details" name="'+node[i].name+'" uid="'+node[i].id+'" type="'+node[i].type+'"><i class="tree-folder-open"></i> '+node[i].name+'</a>';
                    //html +=	addNodes(node[i].items,'c_'+childid+'_'+i);
                    html += '</div>';
                }
				//html += '<a>'+node[i].name+'</a>';
                html += '</li>';
            }
            html += '</ul>';
            return html;
        }
   /**
    * treeReload method
    * @param {Object} id
    * @param {Object} items
    * @return {string} html the added nodes
    */        
//    treeReload = function (id, items) {
//     //   alert(id);
//        var $elem = $('#'+id).parent().parent();
//
//        $elem.empty();
//        //createTree($elem,items)
//
//       $elem.pmtree({
//         id:id,
//         collapsed:true,
//         items:items,
//         select : function (param) {
//                   alert ('selected item '+ param.uid);
//               },
//               unselect :function (id) {
//                   alert ('unselect item');
//               }
//
//       });
//    };
})( jQuery );

/*! jQuery UI - v1.10.3 - 2013-05-10
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.datepicker.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js
* Copyright 2013 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.3",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.3" } });

var PROP_NAME = "datepicker",
	instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, PROP_NAME);

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.3";

})(jQuery);
(function($, undefined) {

var dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.10.3",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery);
(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

/**
 * Version: 1.0 Alpha-1 
 * Build Date: 13-Nov-2007
 * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
 */
Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|after|from)/i,subtract:/^(\-|before|ago)/i,yesterday:/^yesterday/i,today:/^t(oday)?/i,tomorrow:/^tomorrow/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^min(ute)?s?/i,hour:/^h(ou)?rs?/i,week:/^w(ee)?k/i,month:/^m(o(nth)?s?)?/i,day:/^d(ays?)?/i,year:/^y((ea)?rs?)?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a|p)/i},abbreviatedTimeZoneStandard:{GMT:"-000",EST:"-0400",CST:"-0500",MST:"-0600",PST:"-0700"},abbreviatedTimeZoneDST:{GMT:"-000",EDT:"-0500",CDT:"-0600",MDT:"-0700",PDT:"-0800"}};
Date.getMonthNumberFromName=function(name){var n=Date.CultureInfo.monthNames,m=Date.CultureInfo.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.getDayNumberFromName=function(name){var n=Date.CultureInfo.dayNames,m=Date.CultureInfo.abbreviatedDayNames,o=Date.CultureInfo.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.isLeapYear=function(year){return(((year%4===0)&&(year%100!==0))||(year%400===0));};Date.getDaysInMonth=function(year,month){return[31,(Date.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};Date.getTimezoneOffset=function(s,dst){return(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()]:Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];};Date.getTimezoneAbbreviation=function(offset,dst){var n=(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST:Date.CultureInfo.abbreviatedTimeZoneStandard,p;for(p in n){if(n[p]===offset){return p;}}
return null;};Date.prototype.clone=function(){return new Date(this.getTime());};Date.prototype.compareTo=function(date){if(isNaN(this)){throw new Error(this);}
if(date instanceof Date&&!isNaN(date)){return(this>date)?1:(this<date)?-1:0;}else{throw new TypeError(date);}};Date.prototype.equals=function(date){return(this.compareTo(date)===0);};Date.prototype.between=function(start,end){var t=this.getTime();return t>=start.getTime()&&t<=end.getTime();};Date.prototype.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};Date.prototype.addSeconds=function(value){return this.addMilliseconds(value*1000);};Date.prototype.addMinutes=function(value){return this.addMilliseconds(value*60000);};Date.prototype.addHours=function(value){return this.addMilliseconds(value*3600000);};Date.prototype.addDays=function(value){return this.addMilliseconds(value*86400000);};Date.prototype.addWeeks=function(value){return this.addMilliseconds(value*604800000);};Date.prototype.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,this.getDaysInMonth()));return this;};Date.prototype.addYears=function(value){return this.addMonths(value*12);};Date.prototype.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.millisecond||x.milliseconds){this.addMilliseconds(x.millisecond||x.milliseconds);}
if(x.second||x.seconds){this.addSeconds(x.second||x.seconds);}
if(x.minute||x.minutes){this.addMinutes(x.minute||x.minutes);}
if(x.hour||x.hours){this.addHours(x.hour||x.hours);}
if(x.month||x.months){this.addMonths(x.month||x.months);}
if(x.year||x.years){this.addYears(x.year||x.years);}
if(x.day||x.days){this.addDays(x.day||x.days);}
return this;};Date._validate=function(value,min,max,name){if(typeof value!="number"){throw new TypeError(value+" is not a Number.");}else if(value<min||value>max){throw new RangeError(value+" is not a valid value for "+name+".");}
return true;};Date.validateMillisecond=function(n){return Date._validate(n,0,999,"milliseconds");};Date.validateSecond=function(n){return Date._validate(n,0,59,"seconds");};Date.validateMinute=function(n){return Date._validate(n,0,59,"minutes");};Date.validateHour=function(n){return Date._validate(n,0,23,"hours");};Date.validateDay=function(n,year,month){return Date._validate(n,1,Date.getDaysInMonth(year,month),"days");};Date.validateMonth=function(n){return Date._validate(n,0,11,"months");};Date.validateYear=function(n){return Date._validate(n,1,9999,"seconds");};Date.prototype.set=function(config){var x=config;if(!x.millisecond&&x.millisecond!==0){x.millisecond=-1;}
if(!x.second&&x.second!==0){x.second=-1;}
if(!x.minute&&x.minute!==0){x.minute=-1;}
if(!x.hour&&x.hour!==0){x.hour=-1;}
if(!x.day&&x.day!==0){x.day=-1;}
if(!x.month&&x.month!==0){x.month=-1;}
if(!x.year&&x.year!==0){x.year=-1;}
if(x.millisecond!=-1&&Date.validateMillisecond(x.millisecond)){this.addMilliseconds(x.millisecond-this.getMilliseconds());}
if(x.second!=-1&&Date.validateSecond(x.second)){this.addSeconds(x.second-this.getSeconds());}
if(x.minute!=-1&&Date.validateMinute(x.minute)){this.addMinutes(x.minute-this.getMinutes());}
if(x.hour!=-1&&Date.validateHour(x.hour)){this.addHours(x.hour-this.getHours());}
if(x.month!==-1&&Date.validateMonth(x.month)){this.addMonths(x.month-this.getMonth());}
if(x.year!=-1&&Date.validateYear(x.year)){this.addYears(x.year-this.getFullYear());}
if(x.day!=-1&&Date.validateDay(x.day,this.getFullYear(),this.getMonth())){this.addDays(x.day-this.getDate());}
if(x.timezone){this.setTimezone(x.timezone);}
if(x.timezoneOffset){this.setTimezoneOffset(x.timezoneOffset);}
return this;};Date.prototype.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};Date.prototype.isLeapYear=function(){var y=this.getFullYear();return(((y%4===0)&&(y%100!==0))||(y%400===0));};Date.prototype.isWeekday=function(){return!(this.is().sat()||this.is().sun());};Date.prototype.getDaysInMonth=function(){return Date.getDaysInMonth(this.getFullYear(),this.getMonth());};Date.prototype.moveToFirstDayOfMonth=function(){return this.set({day:1});};Date.prototype.moveToLastDayOfMonth=function(){return this.set({day:this.getDaysInMonth()});};Date.prototype.moveToDayOfWeek=function(day,orient){var diff=(day-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};Date.prototype.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};Date.prototype.getDayOfYear=function(){return Math.floor((this-new Date(this.getFullYear(),0,1))/86400000);};Date.prototype.getWeekOfYear=function(firstDayOfWeek){var y=this.getFullYear(),m=this.getMonth(),d=this.getDate();var dow=firstDayOfWeek||Date.CultureInfo.firstDayOfWeek;var offset=7+1-new Date(y,0,1).getDay();if(offset==8){offset=1;}
var daynum=((Date.UTC(y,m,d,0,0,0)-Date.UTC(y,0,1,0,0,0))/86400000)+1;var w=Math.floor((daynum-offset+7)/7);if(w===dow){y--;var prevOffset=7+1-new Date(y,0,1).getDay();if(prevOffset==2||prevOffset==8){w=53;}else{w=52;}}
return w;};Date.prototype.isDST=function(){console.log('isDST');return this.toString().match(/(E|C|M|P)(S|D)T/)[2]=="D";};Date.prototype.getTimezone=function(){return Date.getTimezoneAbbreviation(this.getUTCOffset,this.isDST());};Date.prototype.setTimezoneOffset=function(s){var here=this.getTimezoneOffset(),there=Number(s)*-6/10;this.addMinutes(there-here);return this;};Date.prototype.setTimezone=function(s){return this.setTimezoneOffset(Date.getTimezoneOffset(s));};Date.prototype.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r[0]+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};Date.prototype.getDayName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedDayNames[this.getDay()]:Date.CultureInfo.dayNames[this.getDay()];};Date.prototype.getMonthName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedMonthNames[this.getMonth()]:Date.CultureInfo.monthNames[this.getMonth()];};Date.prototype._toString=Date.prototype.toString;Date.prototype.toString=function(format){var self=this;var p=function p(s){return(s.toString().length==1)?"0"+s:s;};return format?format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g,function(format){switch(format){case"hh":return p(self.getHours()<13?self.getHours():(self.getHours()-12));case"h":return self.getHours()<13?self.getHours():(self.getHours()-12);case"HH":return p(self.getHours());case"H":return self.getHours();case"mm":return p(self.getMinutes());case"m":return self.getMinutes();case"ss":return p(self.getSeconds());case"s":return self.getSeconds();case"yyyy":return self.getFullYear();case"yy":return self.getFullYear().toString().substring(2,4);case"dddd":return self.getDayName();case"ddd":return self.getDayName(true);case"dd":return p(self.getDate());case"d":return self.getDate().toString();case"MMMM":return self.getMonthName();case"MMM":return self.getMonthName(true);case"MM":return p((self.getMonth()+1));case"M":return self.getMonth()+1;case"t":return self.getHours()<12?Date.CultureInfo.amDesignator.substring(0,1):Date.CultureInfo.pmDesignator.substring(0,1);case"tt":return self.getHours()<12?Date.CultureInfo.amDesignator:Date.CultureInfo.pmDesignator;case"zzz":case"zz":case"z":return"";}}):this._toString();};
Date.now=function(){return new Date();};Date.today=function(){return Date.now().clearTime();};Date.prototype._orient=+1;Date.prototype.next=function(){this._orient=+1;return this;};Date.prototype.last=Date.prototype.prev=Date.prototype.previous=function(){this._orient=-1;return this;};Date.prototype._is=false;Date.prototype.is=function(){this._is=true;return this;};Number.prototype._dateElement="day";Number.prototype.fromNow=function(){var c={};c[this._dateElement]=this;return Date.now().add(c);};Number.prototype.ago=function(){var c={};c[this._dateElement]=this*-1;return Date.now().add(c);};(function(){var $D=Date.prototype,$N=Number.prototype;var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),de;var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
return this.moveToDayOfWeek(n,this._orient);};};for(var i=0;i<dx.length;i++){$D[dx[i]]=$D[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};for(var j=0;j<mx.length;j++){$D[mx[j]]=$D[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$D[de]=$D[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}}());Date.prototype.toJSONString=function(){return this.toString("yyyy-MM-ddThh:mm:ssZ");};Date.prototype.toShortDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern);};Date.prototype.toLongDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.longDatePattern);};Date.prototype.toShortTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern);};Date.prototype.toLongTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.longTimePattern);};Date.prototype.getOrdinal=function(){switch(this.getDate()){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};Date.Grammar={};Date.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=((s.length==3)?Date.getMonthNumberFromName(s):(Number(s)-1));};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<Date.CultureInfo.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];var now=new Date();this.year=now.getFullYear();this.month=now.getMonth();this.day=1;this.hour=0;this.minute=0;this.second=0;for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
this.hour=(this.meridian=="p"&&this.hour<13)?this.hour+12:this.hour;if(this.day>Date.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
if(this.now){return new Date();}
var today=Date.today();var method=null;var expression=!!(this.days!=null||this.orient||this.operator);if(expression){var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(this.weekday){this.unit="day";gap=(Date.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
if(this.unit=="week"){this.unit="day";this.value=this.value*7;}
this[this.unit+"s"]=this.value*orient;}
return today.add(this);}else{if(this.meridian&&this.hour){this.hour=(this.hour<13&&this.meridian=="p")?this.hour+12:this.hour;}
if(this.weekday&&!this.day){this.day=(today.addDays((Date.getDayNumberFromName(this.weekday)-today.getDay()))).getDate();}
if(this.month&&!this.day){this.day=1;}
return today.set(this);}}};var _=Date.Parsing.Operators,g=Date.Grammar,t=Date.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=Date.CultureInfo.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken(Date.CultureInfo.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.mm,g.ss],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^(\+|\-)?\s*\d\d\d\d?/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^(\+|\-)\s*\d\d\d\d/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[Date.CultureInfo.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw Date.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["yyyy-MM-ddTHH:mm:ss","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};}());Date._parse=Date.parse;Date.parse=function(s){var r=null;if(!s){return null;}
try{r=Date.Grammar.start.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};Date.getParseFunction=function(fx){var fn=Date.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};Date.parseExact=function(s,fx){return Date.getParseFunction(fx)(s);};

/*
 * jQuery timepicker addon
 * By: Trent Richardson [http://trentrichardson.com]
 * Version 1.3
 * Last Modified: 05/05/2013
 *
 * Copyright 2013 Trent Richardson
 * You may use this project under MIT or GPL licenses.
 * http://trentrichardson.com/Impromptu/GPL-LICENSE.txt
 * http://trentrichardson.com/Impromptu/MIT-LICENSE.txt
 */

/*jslint evil: true, white: false, undef: false, nomen: false */

(function($) {

	/*
	* Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
	*/
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
	* Extend jQueryUI, get it started with our version number
	*/
	$.extend($.ui, {
		timepicker: {
			version: "1.3"
		}
	});

	/* 
	* Timepicker manager.
	* Use the singleton instance of this class, $.timepicker, to interact with the time picker.
	* Settings for (groups of) time pickers are maintained in an instance object,
	* allowing multiple different settings on the same page.
	*/
	var Timepicker = function() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			defaultValue: null,
			parse: 'strict'
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour','minute','second','millisec', 'microsec'],
		support: {},
		control: null,

		/* 
		* Override the default settings for all instances of the time picker.
		* @param  settings  object - the new settings to use as defaults (anonymous object)
		* @return the manager object
		*/
		setDefaults: function(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
		* Create a new Timepicker instance
		*/
		_newInst: function($input, o) {
			var tp_inst = new Timepicker(),
				inlineSettings = {},
            	fns = {},
		    	overrides, i;

			for (var attrName in this._defaults) {
				if(this._defaults.hasOwnProperty(attrName)){
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

		    overrides = {
		        beforeShow: function (input, dp_inst) {
		            if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
		                return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
		            }
		        },
		        onChangeMonthYear: function (year, month, dp_inst) {
		            // Update the time as well : this prevents the time from disappearing from the $input field.
		            tp_inst._updateDateTime(dp_inst);
		            if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
		                tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
		            }
		        },
		        onClose: function (dateText, dp_inst) {
		            if (tp_inst.timeDefined === true && $input.val() !== '') {
		                tp_inst._updateDateTime(dp_inst);
		            }
		            if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
		                tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
		            }
		        }
		    };
		    for (i in overrides) {
		        if (overrides.hasOwnProperty(i)) {
		            fns[i] = o[i] || null;
		        }
		    }

		    tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, overrides, {
		        evnts:fns,
		        timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
		    });
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(
					tp_inst._defaults.timeFormat + 
					(tp_inst._defaults.pickerTimeFormat? tp_inst._defaults.pickerTimeFormat:'') + 
					(tp_inst._defaults.altTimeFormat? tp_inst._defaults.altTimeFormat:''));

			// controlType is string - key to our this._controls
			if(typeof(tp_inst._defaults.controlType) === 'string'){
				if(tp_inst._defaults.controlType == 'slider' && typeof(jQuery.ui.slider) === 'undefined'){
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else{ 
				tp_inst.control = tp_inst._defaults.controlType;
			}

			// prep the timezone options
			var timezoneList = [-720,-660,-600,-570,-540,-480,-420,-360,-300,-270,-240,-210,-180,-120,-60,
					0,60,120,180,210,240,270,300,330,345,360,390,420,480,525,540,570,600,630,660,690,720,765,780,840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl=timezoneList.length,tzi=0,tzv=null;
			if (tzl > 0 && typeof timezoneList[0] !== 'object') {
				for(; tzi<tzl; tzi++){
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : 
							((new Date()).getTimezoneOffset()*-1);
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin? tp_inst._defaults.hourMin : 
							tp_inst._defaults.hour > tp_inst._defaults.hourMax? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin? tp_inst._defaults.minuteMin : 
							tp_inst._defaults.minute > tp_inst._defaults.minuteMax? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin? tp_inst._defaults.secondMin : 
							tp_inst._defaults.second > tp_inst._defaults.secondMax? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin? tp_inst._defaults.millisecMin : 
							tp_inst._defaults.millisec > tp_inst._defaults.millisecMax? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin? tp_inst._defaults.microsecMin : 
							tp_inst._defaults.microsec > tp_inst._defaults.microsecMax? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (o.altField) {
				tp_inst.$altInput = $(o.altField).css({
					cursor: 'pointer'
				}).focus(function() {
					$input.trigger("focus");
				});
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function() {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
		* add our sliders to the calendar
		*/
		_addTimePicker: function(dp_inst) {
			var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val();

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
		},

		/*
		* parse the time string from input value or _setTime
		*/
		_parseTime: function(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err +
									"\ndate/time string = " + timeString +
									"\ntimeFormat = " + this._defaults.timeFormat +
									"\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
		* generate and inject html for timepicker into ui datepicker
		*/
		_injectTimePicker: function() {
			var $dp = this.inst.dpDiv,
				o = this.inst.settings,
				tp_inst = this,
				litem = '',
				uitem = '',
				show = null,
				max = {},
				gridSize = {},
				size = null,
				i=0,
				l=0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' style="display:none;"',
					html = '<div class="ui-timepicker-div'+ (o.isRTL? ' ui-timepicker-rtl' : '') +'"><dl>' + '<dt class="ui_tpicker_time_label"' + ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' + 
								'<dd class="ui_tpicker_time"' + ((o.showTime) ? '' : noDisplay) + '></dd>';

				// Create the markup
				for(i=0,l=this.units.length; i<l; i++){
					litem = this.units[i];
					uitem = litem.substr(0,1).toUpperCase() + litem.substr(1);
					show = o['show'+uitem] !== null? o['show'+uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt((o[litem+'Max'] - ((o[litem+'Max'] - o[litem+'Min']) % o['step'+uitem])), 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_'+ litem +'_label"' + (show ? '' : noDisplay) + '>' + o[litem +'Text'] + '</dt>' + 
								'<dd class="ui_tpicker_'+ litem +'"><div class="ui_tpicker_'+ litem +'_slider"' + (show ? '' : noDisplay) + '></div>';

					if (show && o[litem+'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if(litem == 'hour'){
							for (var h = o[litem+'Min']; h <= max[litem]; h += parseInt(o[litem+'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm? 'hht':'HH', {hour:h}, o);									
								html += '<td data-for="'+litem+'">' + tmph + '</td>';
							}
						}
						else{
							for (var m = o[litem+'Min']; m <= max[litem]; m += parseInt(o[litem+'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="'+litem+'">' + ((m < 10) ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}
				
				// Timezone
				var showTz = o.showTimezone !== null? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label"' + (showTz ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone" ' + (showTz ? '' : noDisplay) + '></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}
				
				// add sliders, adjust grids, add events
				for(i=0,l=tp_inst.units.length; i<l; i++){
					litem = tp_inst.units[i];
					uitem = litem.substr(0,1).toUpperCase() + litem.substr(1);
					show = o['show'+uitem] !== null? o['show'+uitem] : this.support[litem];

					// add the slider
					tp_inst[litem+'_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_'+litem+'_slider'), litem, tp_inst[litem], o[litem+'Min'], max[litem], o['step'+uitem]);

					// adjust the grid and add click event
					if (show && o[litem+'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem+'Grid'] / (max[litem] - o[litem+'Min']);
						$tp.find('.ui_tpicker_'+litem+' table').css({
							width: size + "%",
							marginLeft: o.isRTL? '0' : ((size / (-2 * gridSize[litem])) + "%"),
							marginRight: o.isRTL? ((size / (-2 * gridSize[litem])) + "%") : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function(e){
								var $t = $(this),
									h = $t.html(),
									n = parseInt(h.replace(/[^0-9]/g),10),
									ap = h.replace(/[^apm]/ig),
									f = $t.data('for'); // loses scope, so we use data-for

								if(f == 'hour'){
									if(ap.indexOf('p') !== -1 && n < 12){
										n += 12;
									}
									else{
										if(ap.indexOf('a') !== -1 && n === 12){
											n = 0;
										}
									}
								}
								
								tp_inst.control.value(tp_inst, tp_inst[f+'_slider'], litem, n);

								tp_inst._onTimeChange();
								tp_inst._onSelectHandler();
							}).css({
								cursor: 'pointer',
								width: (100 / gridSize[litem]) + '%',
								textAlign: 'center',
								overflow: 'hidden'
							});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select,
				$.map(o.timezoneList, function(val, idx) {
					return $("<option />").val(typeof val == "object" ? val.value : val).text(typeof val == "object" ? val.label : val);
				}));
				if (typeof(this.timezone) != "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = (new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12)).getTimezoneOffset()*-1;
					if (local_timezone == this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof(this.hour) != "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function() {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
				});
				// End timezone options
				
				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time');

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
						rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;
						
					setTimeout(function() { // fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function() {
									var $g = $(this),
										oldWidth = $g.outerWidth(),
										oldMarginLeft = $g.css(rtl? 'marginRight':'marginLeft').toString().replace('%', ''),
										newWidth = oldWidth - sliderAccessWidth,
										newMarginLeft = ((oldMarginLeft * newWidth) / oldWidth) + '%',
										css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl? 'marginRight':'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

			}
		},

		/*
		* This function tries to limit the ability to go outside the
		* min/max date range
		*/
		_limitMinMaxDateTime: function(dp_inst, adjustSliders) {
			var o = this._defaults,
				dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
					minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if(this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
					maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)), 10),
					minMax = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)), 10),
					secMax = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)), 10),
					millisecMax = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)), 10);
					microsecMax = parseInt((this._defaults.microsecMax - ((this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec)), 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax });
					this.control.value(this, this.hour_slider, 'hour', this.hour - (this.hour % this._defaults.stepHour));
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax });
					this.control.value(this, this.minute_slider, 'minute', this.minute - (this.minute % this._defaults.stepMinute));
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax });
					this.control.value(this, this.second_slider, 'second', this.second - (this.second % this._defaults.stepSecond));
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - (this.millisec % this._defaults.stepMillisec));
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - (this.microsec % this._defaults.stepMicrosec));
				}
			}

		},

		/*
		* when a slider moves, set the internal time...
		* on time change is also called when the time is updated in the text field
		*/
		_onTimeChange: function() {
			var hour = (this.hour_slider) ? this.control.value(this, this.hour_slider, 'hour') : false,
				minute = (this.minute_slider) ? this.control.value(this, this.minute_slider, 'minute') : false,
				second = (this.second_slider) ? this.control.value(this, this.second_slider, 'second') : false,
				millisec = (this.millisec_slider) ? this.control.value(this, this.millisec_slider, 'millisec') : false,
				microsec = (this.microsec_slider) ? this.control.value(this, this.microsec_slider, 'microsec') : false,
				timezone = (this.timezone_select) ? this.timezone_select.val() : false,
				o = this._defaults,
				pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
				pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if (typeof(hour) == 'object') {
				hour = false;
			}
			if (typeof(minute) == 'object') {
				minute = false;
			}
			if (typeof(second) == 'object') {
				second = false;
			}
			if (typeof(millisec) == 'object') {
				millisec = false;
			}
			if (typeof(microsec) == 'object') {
				microsec = false;
			}
			if (typeof(timezone) == 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = (hour != this.hour || minute != this.minute || second != this.second || millisec != this.millisec || microsec != this.microsec 
								|| (this.ampm.length > 0 && (hour < 12) != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) 
								|| (this.timezone !== null && timezone != this.timezone));

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if(pickerTimeFormat === o.timeFormat){
					this.$timeObj.text(this.formattedTime + pickerTimeSuffix);
				}
				else{
					this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
			}
		},

		/*
		* call custom onSelect.
		* bind to sliders slidestop, and grid click.
		*/
		_onSelectHandler: function() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
		* update our input with the new date time..
		*/
		_updateDateTime: function(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
				formatCfg = $.datepicker._getFormatConfig(dp_inst),
				timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
			var formattedDateTime = this.formattedDate;
			
			// if a slider was changed but datepicker doesn't have a value yet, set it
			if(dp_inst.lastVal===""){
                dp_inst.currentYear=dp_inst.selectedYear;
                dp_inst.currentMonth=dp_inst.selectedMonth;
                dp_inst.currentDay=dp_inst.selectedDay;
            }

			/*
			* remove following lines to force every changes in date picker to change the input value
			* Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker. 
			* If the user manually empty the value in the input field, the date picker will never change selected value.
			*/
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
					altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator,
					altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
				
				if(!this._defaults.timeOnly){
					if (this._defaults.altFormat){
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg);
					}
					else{
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime){
						altFormattedDateTime += altSeparator;
					}
				}

				if(this._defaults.altTimeFormat){
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				}
				else{
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
					tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
		* Small abstraction to control types
		* We can add more, just be sure to follow the pattern: create, options, value
		*/
		_controls: {
			// slider methods
			slider: {
				create: function(tp_inst, obj, unit, val, min, max, step){
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl? val*-1 : val,
						min: rtl? max*-1 : min,
						max: rtl? min*-1 : max,
						step: step,
						slide: function(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl? ui.value*-1:ui.value);
							tp_inst._onTimeChange();
						},
						stop: function(event, ui) {
							tp_inst._onSelectHandler();
						}
					});	
				},
				options: function(tp_inst, obj, unit, opts, val){
					if(tp_inst._defaults.isRTL){
						if(typeof(opts) == 'string'){
							if(opts == 'min' || opts == 'max'){
								if(val !== undefined){
									return obj.slider(opts, val*-1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min, 
							max = opts.max;
						opts.min = opts.max = null;
						if(min !== undefined){
							opts.max = min * -1;
						}
						if(max !== undefined){
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if(typeof(opts) == 'string' && val !== undefined){
							return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function(tp_inst, obj, unit, val){
					if(tp_inst._defaults.isRTL){
						if(val !== undefined){
							return obj.slider('value', val*-1);
						}
						return Math.abs(obj.slider('value'));
					}
					if(val !== undefined){
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function(tp_inst, obj, unit, val, min, max, step){
					var sel = '<select class="ui-timepicker-select" data-unit="'+ unit +'" data-min="'+ min +'" data-max="'+ max +'" data-step="'+ step +'">',
						format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for(var i=min; i<=max; i+=step){						
						sel += '<option value="'+ i +'"'+ (i==val? ' selected':'') +'>';
						if(unit == 'hour'){
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig,'')), {hour:i}, tp_inst._defaults);
						}
						else if(unit == 'millisec' || unit == 'microsec' || i >= 10){ sel += i; }
						else {sel += '0'+ i.toString(); }
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function(e){
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
					});

					return obj;
				},
				options: function(tp_inst, obj, unit, opts, val){
					var o = {},
						$t = obj.children('select');
					if(typeof(opts) == 'string'){
						if(val === undefined){
							return $t.data(opts);
						}
						o[opts] = val;	
					}
					else{ o = opts; }
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min || $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function(tp_inst, obj, unit, val){
					var $t = obj.children('select');
					if(val !== undefined){
						return $t.val(val);
					}
					return $t.val();
				}
			}
		} // end _controls

	});

	$.fn.extend({
		/*
		* shorthand just to use timepicker..
		*/
		timepicker: function(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if (typeof o == 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function() {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
		* extend timepicker to datepicker
		*/
		datetimepicker: function(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof(o) == 'string') {
				if (o == 'getDate') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function() {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function() {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
	* Public Utility to parse date and time
	*/
	$.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRex.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
	* Public utility to parse time
	*/
	$.datepicker.parseTime = function(timeFormat, timeString, options) {		
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
			iso8601 = (timeFormat.replace(/\'.*?\'/g,'').indexOf('Z') !== -1);

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function(f, s, o){

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function(val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
					orders = {
						h: -1,
						m: -1,
						s: -1,
						l: -1,
						c: -1,
						t: -1,
						z: -1
					};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] == -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString()
					.replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
							var ml = match.length;
							switch (match.charAt(0).toLowerCase()) {
								case 'h': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 'm': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 's': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 'l': return '(\\d?\\d?\\d)';
								case 'c': return '(\\d?\\d?\\d)';
								case 'z': return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
								case 't': return getPatternAmpm(o.amNames, o.pmNames);
								default:    // literal escaped in quotes
									return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) { return "\\" + m; }) + ')?';
							}
						})
					.replace(/\s/g, '\\s?') +
					o.timeSuffix + '$',
				order = getFormatPositions(f),
				ampm = '',
				treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm == 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm == 'AM' && treg[order.h] == '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm == 'PM' && treg[order.h] != '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}


				return resTime;
			}
			return false;
		};// end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function(f,s,o){
			try{
				var d = new Date('2012-01-01 '+ s);
				if(isNaN(d.getTime())){
					d = new Date('2012-01-01T'+ s);
					if(isNaN(d.getTime())){
						d = new Date('01/01/2012 '+ s);
						if(isNaN(d.getTime())){
							throw "Unable to parse time with native Date: "+ s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset()*-1
				};
			}
			catch(err){
				try{
					return strictParse(f,s,o);
				}
				catch(err2){
					$.timepicker.log("Unable to parse \ntimeString: "+ s +"\ntimeFormat: "+ f);
				}				
			}
			return false;
		}; // end looseParse
		
		if(typeof o.parse === "function"){
			return o.parse(timeFormat, timeString, o);
		}
		if(o.parse === 'loose'){
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/*
	* Public utility to format the time
	* format = string format of the time
	* time = a {}, not a Date() for timezones
	* options = essentially the regional[].. amNames, pmNames, ampm
	*/
	$.datepicker.formatTime = function(format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			timezone: 0
		}, time);

		var tmptime = format,
			ampmName = options.amNames[0],
			hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|('.*?'|".*?"))/g, function(match) {
		switch (match) {
			case 'HH':
				return ('0' + hour).slice(-2);
			case 'H':
				return hour;
			case 'hh':
				return ('0' + convert24to12(hour)).slice(-2);
			case 'h':
				return convert24to12(hour);
			case 'mm':
				return ('0' + time.minute).slice(-2);
			case 'm':
				return time.minute;
			case 'ss':
				return ('0' + time.second).slice(-2);
			case 's':
				return time.second;
			case 'l':
				return ('00' + time.millisec).slice(-3);
			case 'c':
				return ('00' + time.microsec).slice(-3);
			case 'z':
				return $.timepicker.timezoneOffsetString(time.timezone === null? options.timezone : time.timezone, false);
			case 'Z':
				return $.timepicker.timezoneOffsetString(time.timezone === null? options.timezone : time.timezone, true);
			case 'T': 
				return ampmName.charAt(0).toUpperCase();
			case 'TT': 
				return ampmName.toUpperCase();
			case 't':
				return ampmName.charAt(0).toLowerCase();
			case 'tt':
				return ampmName.toLowerCase();
			default:
				return match.replace(/\'/g, "") || "'";
			}
		});

		tmptime = $.trim(tmptime);
		return tmptime;
	};

	/*
	* the bad hack :/ override datepicker so it doesnt close on select
	// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
	*/
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function(id, dateStr) {
		var inst = this._getInst($(id)[0]),
			tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			tp_inst._limitMinMaxDateTime(inst, true);
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
	* second bad hack :/ override datepicker so it triggers an event when changing the input field
	* and does not redraw the datepicker on every selectDate event
	*/
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function(inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst != inst && $.datepicker._datepickerShowing && $.datepicker._lastInput != input) {
			return;
		}

		if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
	* third bad hack :/ override datepicker so it allows spaces and colon in the input field
	*/
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function(event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
					tz = tp_inst._defaults.showTimezone !== null? tp_inst._defaults.showTimezone : tp_inst.support.timezone,					
					dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
					datetimeChars = tp_inst._defaults.timeFormat.toString()
											.replace(/[hms]/g, '')
											.replace(/TT/g, ampm ? 'APM' : '')
											.replace(/Tt/g, ampm ? 'AaPpMm' : '')
											.replace(/tT/g, ampm ? 'AaPpMm' : '')
											.replace(/T/g, ampm ? 'AP' : '')
											.replace(/tt/g, ampm ? 'apm' : '')
											.replace(/t/g, ampm ? 'ap' : '') + 
											" " + tp_inst._defaults.separator + 
											tp_inst._defaults.timeSuffix + 
											(tz ? tp_inst._defaults.timezoneList.join('') : '') + 
											(tp_inst._defaults.amNames.join('')) + (tp_inst._defaults.pmNames.join('')) + 
											dateChars,
					chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
	* Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
	*/
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	/* Update any alternate field to synchronise with the main field. */
	$.datepicker._updateAlternate = function(inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if(tp_inst){
			var altField = tp_inst._defaults.altField;
			if (altField) { // update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
					date = this._getDate(inst),
					formatCfg = $.datepicker._getFormatConfig(inst),
					altFormattedDateTime = '', 
					altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, 
					altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
					altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;
				
				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if(!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null){
					if(tp_inst._defaults.altFormat){
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					}
					else{
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(altFormattedDateTime);
			}
		}
		else{
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
	* Override key up event to sync manual input changes.
	*/
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function(event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
	* override "Today" button to also grab the time.
	*/
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function(id) {
		var inst = this._getInst($(id)[0]),
			$dp = inst.dpDiv;
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		selectLocalTimezone(tp_inst);
		var now = new Date();
		this._setTime(inst, now);
		$('.ui-datepicker-today', $dp).click();
	};

	/*
	* Disable & enable the Time in the datetimepicker
	*/
	$.datepicker._disableTimepickerDatepicker = function(target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function(target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create our own set time function
	*/
	$.datepicker._setTime = function(inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times.. 
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create new public method to set only time, callable as $().datepicker('setTime', date)
	*/
	$.datepicker._setTimeDatepicker = function(target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date == "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
				}
				if (tp_date.toString() == 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}

	};

	/*
	* override setDate() to allow setting time too within Date object
	*/
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function(target, date) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker'),
			tp_date = (date instanceof Date) ? new Date(date.getTime()) : date;
		
		// This is important if you are using the timezone option, javascript's Date 
		// object will only return the timezone offset for the current locale, so we 
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if(tp_inst && tp_inst.timezone != null){
			date = $.timepicker.timezoneAdjust(date, tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
	* override getDate() to allow getting time too within Date object
	*/
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function(target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if(inst.lastVal === undefined){
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);
			if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date 
				// object will only return the timezone offset for the current locale, so we 
				// adjust it accordingly.  If not using timezone option this won't matter..
				if(tp_inst.timezone != null){
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone);
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
	* override parseDate() because UI 1.8.14 throws an error about "Extra characters"
	* An option in datapicker to ignore extra format characters would be nicer.
	*/
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function(format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0,value.length-(err.length-err.indexOf(':')-2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
	* override formatDate to set date with time to the input
	*/
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function(inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
	* override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
	*/
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function(target, name, value) {
		var inst = this._getInst(target),
	        name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
				max = null,
				onselect = null,
				overrides = tp_inst._defaults.evnts,
				fns = {},
				prop;
		    if (typeof name == 'string') { // if min/max was set with the string
		        if (name === 'minDate' || name === 'minDateTime') {
		            min = value;
		        } else if (name === 'maxDate' || name === 'maxDateTime') {
		            max = value;
		        } else if (name === 'onSelect') {
		            onselect = value;
		        } else if (overrides.hasOwnProperty(name)) {
		            if (typeof (value) === 'undefined') {
		                return overrides[name];
		            }
		            fns[name] = value;
		            name_clone = {}; //empty results in exiting function after overrides updated
		        }
		    } else if (typeof name == 'object') { //if min/max was set with the JSON
		        if (name.minDate) {
		            min = name.minDate;
		        } else if (name.minDateTime) {
		            min = name.minDateTime;
		        } else if (name.maxDate) {
		            max = name.maxDate;
		        } else if (name.maxDateTime) {
		            max = name.maxDateTime;
		        }
		        for (prop in overrides) {
		            if (overrides.hasOwnProperty(prop) && name[prop]) {
		                fns[prop] = name[prop];
		            }
		        }
		    }
		    for (prop in fns) {
		        if (fns.hasOwnProperty(prop)) {
		            overrides[prop] = fns[prop];
		            if (!name_clone) { name_clone = $.extend({}, name);}
		            delete name_clone[prop];
		        }
		    }
		    if (name_clone && isEmptyObject(name_clone)) { return; }
		    if (min) { //if min was set
		        if (min === 0) {
		            min = new Date();
		        } else {
		            min = new Date(min);
		        }
		        tp_inst._defaults.minDate = min;
		        tp_inst._defaults.minDateTime = min;
		    } else if (max) { //if max was set
		        if (max === 0) {
		            max = new Date();
		        } else {
		            max = new Date(max);
		        }
		        tp_inst._defaults.maxDate = max;
		        tp_inst._defaults.maxDateTime = max;
		    } else if (onselect) {
		        tp_inst._defaults.onSelect = onselect;
		    }
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};
	
	/*
	* jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
	* it will return false for all objects
	*/
	var isEmptyObject = function(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(obj)) {
				return false;
			}
		}
		return true;
	};

	/*
	* jQuery extend now ignores nulls!
	*/
	var extendRemove = function(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
	* Determine by the time format which units are supported
	* Returns an object of booleans for each unit
	*/
	var detectSupport = function(timeFormat){
		var tf = timeFormat.replace(/\'.*?\'/g,'').toLowerCase(), // removes literals
			isIn = function(f, t){ // does the format contain the token?
					return f.indexOf(t) !== -1? true:false; 
				};
		return {
				hour: isIn(tf,'h'),
				minute: isIn(tf,'m'),
				second: isIn(tf,'s'),
				millisec: isIn(tf,'l'),
				microsec: isIn(tf,'c'),
				timezone: isIn(tf,'z'),
				ampm: isIn('t') && isIn(timeFormat,'h'),
				iso8601: isIn(timeFormat, 'Z')
			};
	};

	/*
	* Converts 24 hour format into 12 hour
	* Returns 12 hour without leading 0
	*/
	var convert24to12 = function(hour) {
		if (hour > 12) {
			hour = hour - 12;
		}

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	/*
	* Splits datetime string into date ans time substrings.
	* Throws exception when date can't be parsed
	* Returns [dateString, timeString]
	*/
	var splitDateTime = function(dateFormat, dateTimeString, dateSettings, timeSettings) {
		try {
			// The idea is to get the number separator occurances in datetime and the time format requested (since time has 
			// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
			var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator,
				format = timeSettings && timeSettings.timeFormat ? timeSettings.timeFormat : $.timepicker._defaults.timeFormat,
				timeParts = format.split(separator), // how many occurances of separator may be in our format?
				timePartsLen = timeParts.length,
				allParts = dateTimeString.split(separator),
				allPartsLen = allParts.length;

			if (allPartsLen > 1) {
				return [
						allParts.splice(0,allPartsLen-timePartsLen).join(separator),
						allParts.splice(0,timePartsLen).join(separator)
					];
			}

		} catch (err) {
			$.timepicker.log('Could not split the date from the time. Please check the following datetimepicker options' +
					"\nthrown error: " + err +
					"\ndateTimeString" + dateTimeString +
					"\ndateFormat = " + dateFormat +
					"\nseparator = " + timeSettings.separator +
					"\ntimeFormat = " + timeSettings.timeFormat);

			if (err.indexOf(":") >= 0) {
				// Hack!  The error message ends with a colon, a space, and
				// the "extra" characters.  We rely on that instead of
				// attempting to perfectly reproduce the parsing algorithm.
				var dateStringLength = dateTimeString.length - (err.length - err.indexOf(':') - 2),
					timeString = dateTimeString.substring(dateStringLength);

				return [$.trim(dateTimeString.substring(0, dateStringLength)), $.trim(dateTimeString.substring(dateStringLength))];

			} else {
				throw err;
			}
		}
		return [dateTimeString, ''];
	};

	/*
	* Internal function to parse datetime interval
	* Returns: {date: Date, timeObj: Object}, where
	*   date - parsed date without time (type Date)
	*   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
	*/
	var parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date;
		var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings);
		if (splitRes[1] !== '') {
			var timeString = splitRes[1],
				parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings);

			if (parsedTime === null) {
				throw 'Wrong time format';
			}
			return {
				date: date,
				timeObj: parsedTime
			};
		} else {
			return {
				date: date
			};
		}
	};

	/*
	* Internal function to set timezone_select to the local timezone
	*/
	var selectLocalTimezone = function(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = typeof date !== 'undefined' ? date : new Date();
			tp_inst.timezone_select.val(now.getTimezoneOffset()*-1);
		}
	};

	/*
	* Create a Singleton Insance
	*/
	$.timepicker = new Timepicker();

	/**
	 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
	 * @param  number if not a number this value is returned
	 * @param boolean if true formats in accordance to iso8601 "+12:45"
	 * @return string
	 */
	$.timepicker.timezoneOffsetString = function(tzMinutes, iso8601) {
		if(isNaN(tzMinutes) || tzMinutes > 840){
			return tzMinutes;
		}

		var off = tzMinutes,
			minutes = off % 60,
			hours = (off - minutes) / 60,
			iso = iso8601? ':':'',
			tz = (off >= 0 ? '+' : '-') + ('0' + (hours * 101).toString()).slice(-2) + iso + ('0' + (minutes * 101).toString()).slice(-2);
		
		if(tz == '+00:00'){
			return 'Z';
		}
		return tz;
	};

	/**
	 * Get the number in minutes that represents a timezone string
	 * @param  string formated like "+0500", "-1245"
	 * @return number
	 */
	$.timepicker.timezoneOffsetNumber = function(tzString) {
		tzString = tzString.toString().replace(':',''); // excuse any iso8601, end up with "+1245"

		if(tzString.toUpperCase() === 'Z'){ // if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if(!/^(\-|\+)\d{4}$/.test(tzString)){ // possibly a user defined tz, so just give it back
			return tzString;
		}

		return ((tzString.substr(0,1) =='-'? -1 : 1) * // plus or minus
					((parseInt(tzString.substr(1,2),10)*60) + // hours (converted to minutes)
					parseInt(tzString.substr(3,2),10))); // minutes
	};

	/**
	 * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
	 * @param  date
	 * @param  string formated like "+0500", "-1245"
	 * @return date
	 */
	$.timepicker.timezoneAdjust = function(date, toTimezone) {
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if(!isNaN(toTz)){
			var currTz = date.getTimezoneOffset()*-1,
				diff = currTz - toTz; // difference in minutes

			date.setMinutes(date.getMinutes()+diff);
		}
		return date;
	};

	/**
	 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * n.b. The input value must be correctly formatted (reformatting is not supported)
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the timepicker() call
	 * @return jQuery
	 */
	$.timepicker.timeRange = function(startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  string method Can be used to specify the type of picker to be added
	 * @return jQuery
	 */
	$.timepicker.datetimeRange = function(startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return jQuery
	 */
	$.timepicker.dateRange = function(startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  string method Can be used to specify the type of picker to be added
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return jQuery
	 */
	$.timepicker.handleRange = function(method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {},      // options for start picker
			end: {}         // options for end picker
		}, options);

		$.fn[method].call(startTime, $.extend({
			onClose: function(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			onClose: function(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);
		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
				enddt = endTime[method]('getDate'),
				changeddt = changed[method]('getDate');

			if(startdt !== null){
				var minDate = new Date(startdt.getTime()),
					maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if(options.minInterval > 0 && minDate > enddt){ // minInterval check
					endTime[method]('setDate',minDate);
				}
				else if(options.maxInterval > 0 && maxDate < enddt){ // max interval check
					endTime[method]('setDate',maxDate);
				}
				else if (startdt > enddt) {
					other[method]('setDate',changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if(date !== null && options.minInterval > 0){
				if(option == 'minDate'){
					date.setMilliseconds(date.getMilliseconds() + options.minInterval); 
				}
				if(option == 'maxDate'){
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}
			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}
		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
	 * Log error or data to the console during error or debugging
	 * @param  Object err pass any type object to log to the console during error or debugging
	 * @return void
	 */
	$.timepicker.log = function(err){
		if(window.console){
			console.log(err);
		}
	};

	/*
	* Rough microsecond support
	*/
	if(!Date.prototype.getMicroseconds){
		Date.microseconds = 0;
		Date.prototype.getMicroseconds = function(){ return this.microseconds; };
		Date.prototype.setMicroseconds = function(m){ this.microseconds = m; return this; };
	}

	/*
	* Keep up with the version
	*/
	$.timepicker.version = "1.3";

})(jQuery);

